<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>丘卡饮品店</title>
  
  
  <link href="http://zerolacqua.top/atom.xml" rel="self"/>
  
  <link href="http://zerolacqua.top/"/>
  <updated>2022-05-18T01:16:32.089Z</updated>
  <id>http://zerolacqua.top/</id>
  
  <author>
    <name>Zerol Acqua</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数学公式测试</title>
    <link href="http://zerolacqua.top/posts/67588483.html"/>
    <id>http://zerolacqua.top/posts/67588483.html</id>
    <published>2022-05-17T11:47:43.000Z</published>
    <updated>2022-05-18T01:16:32.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>公式渲染很魔幻，我也不懂是为啥。</p><h2 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h2><script type="math/tex; mode=display">\begin{equation}\begin{bmatrix}x-x_0\\\\ y-y_0\\\\ -f\end{bmatrix}=\lambda R^\mathrm{T}\cdot\begin{bmatrix}X-X_S\\\\ Y-Y_S\\\\ Z-Z_S\end{bmatrix}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\hat {y}_ {t}=\cfrac{1}{2l+1}(y_{t-l}+y_{t-(l-1)}+\cdots+y_{t-1}+y_{t}+y_{t+1}+\cdots+y_{t+l})\end{equation}</script><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><ul><li>这是行内公式：$\hat {y}_ {t}=\cfrac{1}{2l+1}(y_{t-l}+y_{t-(l-1)}+\cdots+y_{t-1}+y_{t}+y_{t+1}+\cdots+y_{t+l})$</li><li>这是行内公式：$\begin{bmatrix}x-x_0\\\\ y-y_0\\\\ -f\end{bmatrix}<br>=\lambda R^\mathrm{T}\cdot\begin{bmatrix}X-X_S\\\\ Y-Y_S\\\\ Z-Z_S\end{bmatrix}$</li></ul>]]></content>
    
    
    <summary type="html">测试数学公式的渲染情况。</summary>
    
    
    
    <category term="课外学习" scheme="http://zerolacqua.top/categories/%E8%AF%BE%E5%A4%96%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="博客搭建" scheme="http://zerolacqua.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="测试" scheme="http://zerolacqua.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯方块心得记录</title>
    <link href="http://zerolacqua.top/posts/531cccb5.html"/>
    <id>http://zerolacqua.top/posts/531cccb5.html</id>
    <published>2022-05-03T11:52:13.000Z</published>
    <updated>2022-05-16T00:28:31.218Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning modern"><p>具体内容待更新！</p></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从2021年3月开始，我正式开始接触现代方块(玩的是<a href="https://ch.tetr.io">tetr.io</a>)，到现在我写下这篇博客，已经有一年了。段位也从一开始的 <img class="inline-img" src="https://tetr.io/res/league-ranks/c.png" style="height:15px"/>，一点点地爬到了 <img class="inline-img" src="https://tetr.io/res/league-ranks/ss.png" style="height:15px"/>。</p><p>下面是tetr.io的段位，进步也是肉眼可见的。</p><p><img src="https://tetris.wiki/images/thumb/4/47/Tetra_League_TR_and_Rank_Information_-_Tetrio.png/800px-Tetra_League_TR_and_Rank_Information_-_Tetrio.png" alt="tetris.wiki上的段位信息"></p><p>但是要达到我的目标 <img class="inline-img" src="https://tetr.io/res/league-ranks/x.png" style="height:15px"/>，可能还有很远很远的一段距离吧……不过，至少到 <img class="inline-img" src="https://tetr.io/res/league-ranks/u.png" style="height:15px"/> 还是很有希望的，此博客也算是努力的记录吧。</p><hr><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><h3 id="成就记录"><a href="#成就记录" class="headerlink" title="成就记录"></a>成就记录</h3><ul><li><p>40L——在尽可能短的时间内消除40行</p><ul><li><a href="https://www.bilibili.com/video/BV1KP4y1N73j">sub60</a></li></ul></li><li><p>20TSD——连续完成20次T-spin doule</p><ul><li><p><a href="https://www.bilibili.com/video/BV1Av411K7ER">机械TSD</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1BU4y1o7sH">LST</a></p><details class="toggle" style="border: 1px solid  bg"><summary class="toggle-button" style="background-color:  bg;color:  color">[打块]真没有技术含量的20TSD</summary><div class="toggle-content"><div style="position: relative; padding: 30% 45%;"><iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="//player.bilibili.com/player.html?aid=682172282&bvid=BV1BU4y1o7sH&cid=547247380&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div></div></details></li></ul></li><li><p>Other——拼花</p><ul><li><a href="https://www.bilibili.com/video/BV1j5411g7m5">secret grade</a></li></ul></li></ul><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li><p>DPC</p></li><li><p>free style 20TSD</p></li><li><p>10PC</p></li></ul>]]></content>
    
    
    <summary type="html">嘛，就是一些关于入坑以来玩俄罗斯方块的一些感受吧。</summary>
    
    
    
    <category term="游戏" scheme="http://zerolacqua.top/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="俄罗斯方块" scheme="http://zerolacqua.top/tags/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>地理建模方法编程</title>
    <link href="http://zerolacqua.top/posts/ef2fa561.html"/>
    <id>http://zerolacqua.top/posts/ef2fa561.html</id>
    <published>2022-04-22T08:22:22.000Z</published>
    <updated>2022-05-17T09:43:37.876Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning modern"><p>具体内容待更新！</p></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了分析社会中人与人之间的合作关系，根据博弈论的基础概念与理论，通过 <a href="http://ccl.northwestern.edu/netlogo/">NetLogo</a> 软件构建合作关系模型，研究不同的社会奖惩倾向、参与者的类型、互动频率，以及互动中信息误传递等因素，对整个社会风气的影响。结果表明，惩恶扬善的社会体制，能约束坏的风气；社会中互动次数的增加，有利于构建良好的合作环境；错误会导致合作的崩解，适当的宽容有利于合作的维系。</p><p><code>NetLogo</code>具体使用方法参见<a href="https://ccl.northwestern.edu/netlogo/docs/NetLogo%20User%20Manual.pdf">官方用户手册</a>。</p><div class="note danger modern"><p><a href="http://ccl.northwestern.edu/netlogo/4.0.4/docs/NetLogo_manual_chinese.pdf">中文用户手册</a>已经过时，有很多语法是不支持的了，仅供参考使用</p></div><h2 id="选题"><a href="#选题" class="headerlink" title="选题"></a>选题</h2><p>选题灵感来自博弈论游戏——<strong>《信任的进化》</strong>，以及<strong>罗伯特·阿克塞尔罗德</strong>的<strong>《合作的进化》</strong></p><a class="btn-beautify blue" href="https://dccxi.com/trust/"   title="戳这里在线游玩《信任的进化》"><i class="far fa-hand-point-right"></i><span>戳这里在线游玩《信任的进化》</span></a><p>博弈论，作为数学学科的一个重要分支，是研究人们在不同的信息条件下如何进行互动决策的理论。它在经济学、生物学、政治学、军事战略，以及国际关系等学科中都有着广泛的应用。而“囚徒困境”，则是博弈论中研究最为广泛的模型之一，它揭示了在一次博弈过程中追求个人利益与公共利益之间存在的矛盾。</p><p>但是，在社会中合作行为时刻都在发生，而且人与人之间的合作基本不止一次，因此“囚徒困境”将从单次博弈变为重复博弈，对局双方的选择也会更多，不再是简单地选择欺骗策略。</p><p>罗伯特·阿克塞尔罗德所著的《合作的进化》一书，记述了作者组织的两次计算机程序重复博弈比赛。在这两场比赛中，采用“一报还一报”简单策略的程序都获得了第一名<sup>[1]</sup>。这个程序具有的一些特点，放在社会合作关系中也同样适用。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="思路与假设"><a href="#思路与假设" class="headerlink" title="思路与假设"></a>思路与假设</h3><p>在这个模型中，博弈方通过合作或是欺骗行为，获取尽可能高的分数。每种类型的人会采取不同的策略：</p><ul><li>老好人：永远选择合作</li><li>大恶人：永远选择欺骗</li><li>一报还一报的人：第一次选择合作，之后会重复对方上一次的选择</li></ul><p>根据社会中的合作关系，提出以下假设：</p><ul><li>人的社交范围是有限的：考虑瓦片的邻域作为进行比拼的范围；</li><li>人与人的接触是<strong>频繁</strong>的：考虑每局比拼中两个瓦片之间会进行多轮“比拼”；更重要的是，多次合作的具体次数是不可知的（即不知道最后一次合作是何时）</li><li>人会被<strong>淘汰</strong>：得分最低的瓦片会被清除；</li><li>人会<strong>繁衍</strong>：“无生命”的瓦片会变成有“生命”的瓦片；</li><li>人会受到<strong>周围</strong>人的影响：根据周围的“有生命”的瓦片类型的占比，决定繁殖出的瓦片的类型；</li><li><p>人还会受<strong>整体</strong>社会风气的影响：根据所有瓦片的占比，也会影响到繁殖出的的瓦片的类型。</p></li><li><p>人会<strong>犯错</strong>：人在“比拼”中可能会不小心做出相反的选择，在本模型中只讨论<strong>一报还一报的人</strong>之间、<strong>老好人与一报还一报</strong>的人之间的犯错可能性。</p></li></ul><blockquote><p>注意：这里的淘汰与繁衍不一定指的是生物进化论中的淘汰，可能是由于看到其他人的策略更成功，而转变了自己的策略。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>其中最为麻烦的就是选出得分最低的若干瓦片并淘汰的过程。一开始看的是中文文档，里面的语法已经过时，无法支持<code>sort-by</code>的操作。正确的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let score-list sort-by [ [a b] -&gt; [score] of a &lt; [score] of b ] patches</span><br></pre></td></tr></table></figure><p>上述代理的意思是将<code>patches</code>按<code>score</code>从小到大排序，得到一个列表<code>score-list</code>。然后根据设定的百分比，将排名靠后的瓦片清理。</p><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]罗伯特·阿克塞尔罗德.合作的进化[M].上海：上海人民出版社,2022:19-37</p><p>[2] Axelrod, Robert. The Complexity of Cooperation: Agent-Based Models of Competition and Collaboration. Princeton University Press, 1997, <a href="http://www.jstor.org/stable/j.ctt7s951">http://www.jstor.org/stable/j.ctt7s951</a>. Accessed 6 May 2022.</p><p>[3] Wilensky, U. 1999. NetLogo. <a href="http://ccl.northwestern.edu/netlogo/">http://ccl.northwestern.edu/netlogo/</a>. Center for Connected Learning and Computer-Based Modeling, Northwestern University. Evanston, IL.</p>]]></content>
    
    
    <summary type="html">地理建模方法编程作业记录。</summary>
    
    
    
    <category term="编程作业" scheme="http://zerolacqua.top/categories/%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="地理建模" scheme="http://zerolacqua.top/tags/%E5%9C%B0%E7%90%86%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>基于卫星遥感的西藏湖泊监测</title>
    <link href="http://zerolacqua.top/posts/1562fb12.html"/>
    <id>http://zerolacqua.top/posts/1562fb12.html</id>
    <published>2022-04-14T16:33:36.000Z</published>
    <updated>2022-05-02T07:09:13.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次作业是一项小组合作的论文，我负责的是利用 Jason-3 数据获取湖面高程时序变化成果，因此这里只我自己的一小部分。</p><hr><h2 id="研究区域"><a href="#研究区域" class="headerlink" title="研究区域"></a>研究区域</h2><p><strong>扎日南木错（Zhari Namco）</strong>位于西藏阿里地区错勤县境内，位置介于85°20′~85°54′E，30°44′~31°05′N，湖面海拔4613米，湖泊补给系数为15.5，地属藏北内陆湖区（沿冈底斯山脉及念青唐古拉山以北的广大藏北高原），湖泊形态不规则，南北两岸较窄，东西两岸地势开阔，该湖水主要靠冰雪融水补给，入湖河流主要有错勤藏布、达龙藏布，错勤藏布发源于冈底斯山。扎日南木错属于咸水湖，是阿地区境内最大的湖泊，也是西藏境内第三大湖泊<sup>[1]</sup>。</p><h2 id="研究意义"><a href="#研究意义" class="headerlink" title="研究意义"></a>研究意义</h2><p>湖泊具有涵养水源，调节生态环境的作用，是局部水循环的重要组成，对生态环境，地球科学等方面的研究有重大意义。水位是湖泊的一个重要的水文特征，能一定程度上反映湖泊蓄水量的多少，而水位的时序变化信息更反映了湖泊在一段时间内的变化情况，可以帮助我们分析预测其可能的发展走向，加深我们对气候变化的理解。</p><p>西藏地区湖泊众多，受人类活动影响较小，处于较为原始自然的状态。同时，这些湖泊的水补给多为冰川融水，其水位能一定程度反映冰川的消融情况，与我国淡水资源的利用研究有十分密切的联系，具有有很大的现实意义。</p><p>同时，由于青藏高原环境恶劣，很少有现场测量仪器可用于湖水位监测。而基于卫星测高技术具有快速的全球覆盖能力，能够大尺度、周期性地探测陆表水的各种自然现象及其变化，故在这类研究中具有其他观测技术无可比拟的优越性<sup>[2]</sup>。</p><h2 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h2><h3 id="Jason-3-卫星测高数据"><a href="#Jason-3-卫星测高数据" class="headerlink" title="Jason-3 卫星测高数据"></a>Jason-3 卫星测高数据</h3><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><p>Jason-3卫星是由法国空间研究中心（CNES），美国宇航局（NASA）、欧洲气象卫星组织（EUMETSAT）以及美国海洋和大气局（NOAA）等多个机构合作研制的一颗海洋测高卫星。轨道周期为10天，轨道高度为1336千米，倾角为66°。其延续了Jason-2的轨道，并对系统进行了许多增强<sup>[3]</sup>。</p><h4 id="数据获取方法"><a href="#数据获取方法" class="headerlink" title="数据获取方法"></a>数据获取方法</h4><p>通过将 Jason-3 扫描轨迹导入谷歌地球，我们可以知道具体哪一条扫描线通过了扎日南木错。下载此扫描线的历年数据（2016-2021年）</p><blockquote><p>Jason-3 的轨道周期为10天，因此数据的时间分辨率就是10天</p></blockquote><p><img src="/images/blogs/基于卫星遥感的西藏湖泊监测/1.png" alt="谷歌地球上的 Jason-3 扫描轨迹"></p><p>本实验使用 jason-3 的90号扫描线在2016年2月20日到2021年12月22日之间的总计214次高程测量数据。</p><h3 id="中国1km分辨率逐月平均气温数据集（1901-2020）"><a href="#中国1km分辨率逐月平均气温数据集（1901-2020）" class="headerlink" title="中国1km分辨率逐月平均气温数据集（1901-2020）"></a>中国1km分辨率逐月平均气温数据集（1901-2020）</h3><p>该数据为中国逐月平均温度数据，空间分辨率为0.0083333°（约1km），时间为1901.1-2020.12。数据格式为 NETCDF，即<code>.nc</code>格式。数据单位为0.1 ℃。该数据集是根据 CRU 发布的全球0.5°气候数据集以及 WorldClim 发布的全球高分辨率气候数据集，通过 Delta 空间降尺度方案在中国地区降尺度生成的。并且，使用496个独立气象观测点数据进行验证，验证结果可信。本数据集包含的地理空间范围是全国主要陆地（包含港澳台地区），不含南海岛礁等区域<sup>[4]</sup>。</p><h3 id="中国1km分辨率逐月降水量数据集（1901-2020）"><a href="#中国1km分辨率逐月降水量数据集（1901-2020）" class="headerlink" title="中国1km分辨率逐月降水量数据集（1901-2020）"></a>中国1km分辨率逐月降水量数据集（1901-2020）</h3><p>该数据为中国逐月平均温度数据，空间分辨率为0.0083333°（约1km），时间为1901.1-2020.12。数据格式为 NETCDF，即<code>.nc</code>格式。数据单位为0.1 ℃。该数据集是根据 CRU 发布的全球0.5°气候数据集以及 WorldClim 发布的全球高分辨率气候数据集，通过 Delta 空间降尺度方案在中国地区降尺度生成的。并且，使用496个独立气象观测点数据进行验证，验证结果可信。本数据集包含的地理空间范围是全国主要陆地（包含港澳台地区），不含南海岛礁等区域<sup>[5]</sup>。</p><h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><h3 id="水位测高计算原理"><a href="#水位测高计算原理" class="headerlink" title="水位测高计算原理"></a>水位测高计算原理</h3><p>Jason-3 测高是通过搭载在卫星上的雷达测高仪完成的，通过让测高仪上的雷达装置垂直向下发射脉冲信号，根据测量脉冲从发射经地球表面反射再到卫星天线接收的时间，来计算出卫星到星下点的距离，结合卫星搭载的GPS定位信息计算得到海（水、冰）平面高度</p><p>根据卫星测高的基本工作原理，湖面测高水位计算公式为<sup>[6]</sup>：</p><script type="math/tex; mode=display">\begin{equation}h=h_{alt}-h_{ran}-h_{geoid}-c\end{equation}</script><p>其中：$h$ 为湖泊水位正高；$h_{alt}$ 为测高仪的椭球高；$h_{ran}$ 为测高仪的观测距离；$h_{geoid}$ 为大地水准面相对于参考椭球面高度（即大地水准面差距，大地高与正高差）；$c$为各项观测误差修正。</p><p>在 Jason-3 的数据文件中，储存有扫描线经过点的经纬度坐标、测量时间、椭球高、测高仪的观测距离和大地水准面差距等数据。利用这些数据可以获取扫描行上测量点的高程，以及对应的时间和经纬度。</p><h3 id="高程选取方法"><a href="#高程选取方法" class="headerlink" title="高程选取方法"></a>高程选取方法</h3><p>理论上，对于平静湖面来说，其测高数据应当是相等的，只需要选择其中一点的高程测量值即可作为湖面高程。然而，在水陆交界处，雷达的回波会被污染，雷达高度计收到的返回波形与标准的 Brown 模型差异较大，返回波形的实际波形前缘中点与星载高度计预设跟踪点不一致，会造成高度计测量距离与实际距离的偏差，需要通过波形重跟踪进行修正<sup>[7]</sup>。本实验过程中并没有进行提高精度的波形重跟踪。</p><p>此外，雷达测高数据本身也存在误差，即使是高程相等的湖面，其测量的高程也会有一定的波动，甚至存在异常值。因此，需要对获得的数据进行一定的处理，以选出合理的数值代表整个湖面的高程。对于测高数据中的异常值，可以利用均值、拉依达准则（即三倍中误差准则）、RANSAC 等方法进行剔除。</p><p>本文实验是利用众数剔除异常数据得到湖面高程。由于众数对异常值的敏感度很低，而数据文件中正常的湖面高程值占相当大的比例，因此可以通过如下方法确定湖面高程的近似范围：</p><script type="math/tex; mode=display">\begin{equation}h_0=mode(round(H))\end{equation}</script><p>其中：$H$ 表示一次扫描的高程数据向量；$round()$ 表示对数据进行四舍五入；$mode()$ 表示计算数据中的众数。</p><p>然后由近似值，设定一定大小的邻域，以筛选出正常值。计算正常值的均值作为湖面的最终高程 $\overline{h}$</p><script type="math/tex; mode=display">\begin{equation}\overline{h}=mean(H_c)\end{equation}</script><script type="math/tex; mode=display">\begin{equation}H_c=\{abs(h-h_0)<\varepsilon|h \in H\}\end{equation}</script><p>其中：$H_c$ 表示与 $h_0$ 的距离小于 $\varepsilon$ 的高程数据集合；$mean()$ 表示计算数据的均值。</p><h3 id="时间序列分析"><a href="#时间序列分析" class="headerlink" title="时间序列分析"></a>时间序列分析</h3><p>时间序列的组合主要包含长期趋势（T）、季节变动（S）、循环变动（C）和不规则变动（I）四个成分。长期趋势是指时间序列随时间的变化而逐渐增加或减少的长期变化趋势。季节变动是指时间序列在一年中或固定时间内，呈现出的固定规则的变动。循环变动是指沿着趋势线如钟摆般地循环变动。不规则变动是指在时间序列中由于随机因素影响所引起的变动。</p><p>时间序列组合方式一般有加法模型和乘法模型两种。加法模型假定时间序列是基于四种成分相加而成的，长期趋势并不影响季节变动；而乘法模型假定时间序列是基于四种成分相乘而成的，假定季节变动与循环变动为长期趋势的函数。若以 Y 表示时间序列，则</p><p>加法模型：</p><script type="math/tex; mode=display">\begin{equation}Y=T+S+C+I\end{equation}</script><p>乘法模型：</p><script type="math/tex; mode=display">\begin{equation}Y=T\times S\times C\times I\end{equation}</script><p>为了研究湖面高程的变化趋势，本文采用滑动平均法进行拟合。其计算公式为：</p><script type="math/tex; mode=display">\begin{equation}\hat {y}_ {t}=\cfrac{1}{2l+1}(y_{t-l}+y_{t-(l-1)}+\cdots+y_{t-1}+y_{t}+y_{t+1}+\cdots+y_{t+l})\end{equation}</script><p>式中：$\hat{y}_t$ 为 $t$ 点的滑动平均值；$l$ 为单侧平滑时距。</p><h2 id="实验结果与分析"><a href="#实验结果与分析" class="headerlink" title="实验结果与分析"></a>实验结果与分析</h2><h3 id="湖面高程提取"><a href="#湖面高程提取" class="headerlink" title="湖面高程提取"></a>湖面高程提取</h3><p>根据前述的高程提取算法，提取2016年2月20日到2016年8月7日 Jason-3 的测高数据如下图。可以看到，本文采用的方法，对测高数据中的异常值有较强的抗干扰能力，不论是较平稳的数据（如下图第3行第1列曲线图），还是异常较多的数据（如下图第3行第4列曲线图），其提取的高程值均位于正常数据所在的水平线上。而根据拉依达准则（这里设置的是二倍中误差）提取的高程值，在大多情况下提取的高程与本文方法相近，而一旦遇到异常值较多的情况，提取的高程值就会有较大偏差（如下图第2行第1列曲线图）。</p><p>同时，注意到下图中的前三幅图没有绘制曲线。经过核对，第二、第三幅图像由于数据文件中数据缺失，无法进行绘制，而第一幅图则是因为数据整体出现了异常，高程超出绘图范围，故没有显示。根据 Jason-3 卫星的发射时间（2016年1月17日），可以猜测这是由于 Jason-3 卫星入轨后需进行一段时间的调试与检校工作，因而数据不稳定，甚至存在缺失。而 Jason-3 的2016年年度有效性报告验证了这一点，在相应时间段上确实有检校工作进行<sup>[8]</sup>。</p><p><img src="/images/blogs/基于卫星遥感的西藏湖泊监测/2.jpg" alt="扫描数据（实线）与本文算法选取的湖面高程（虚线）以及拉依达准则选取的湖面高程（点划线）"></p><h3 id="湖面高程时序变化"><a href="#湖面高程时序变化" class="headerlink" title="湖面高程时序变化"></a>湖面高程时序变化</h3><p>每次测量数据能获得湖面的一个高程值，按照数据文件中的测量时间，可以绘制湖面高程随时间变化的曲线。由于前述卫星检校调整的原因，某些时段选取的湖面高程可能会存在空值或是异常值。对于空值而言，由于 Jason-3 的时间分辨率在10天左右，所以，空值的存在对分析结果基本上没有影响。而对于异常值，虽然它会给分析带来很大的影响，但由于异常值非常突出，也很容易将其剔除。通过设置阈值，将高程大于阈值的数据点剔除，就可以达到消除异常数据的目的。此时湖面高程时序曲线如下图所示。</p><p><img src="/images/blogs/基于卫星遥感的西藏湖泊监测/3.jpg" alt="剔除异常之后的湖面高程时序曲线"></p><p>为了更好地描述水位的变化趋势，我们使用滑动平均法，以半年为窗口大小，对得到的湖面高程时序曲线进行平滑，然后再计算近似导数，也进行平滑处理。</p><p><img src="/images/blogs/基于卫星遥感的西藏湖泊监测/4.jpg" alt="平滑后的湖面高程时序曲线"></p><p>从以上湖面高程时序曲线中可以看出，扎日南木错水位的变化总体上呈逐年上涨趋势。在2016年年初到2020年年初之间湖水水位上涨十分显著，而在2020年年初到2022年年初之间，水位呈现出较为稳定的状态且略有回落。</p><p><img src="/images/blogs/基于卫星遥感的西藏湖泊监测/5.jpg" alt="平滑后的湖面高程时序曲线导数"></p><p>从以上湖面高程时序曲线导数可以看出，2016-2020年水位上涨集中发生在夏季的7月和8月，水位下降则发生在1-3月；2020年之后，夏季水位基本无上涨倾向，整体呈下降态势。</p><p>将本文得出的湖面高程时序曲线与文献【9】中所得的湖面高程时序曲线对应时段（2016年年初-2019年年底）进行比较，两者的走势基本吻合，证明了本文处理结果的有效性。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]普布次仁, 白玛央宗, 洛桑曲珍,等. 2002-2017年扎日南木错湖面面积变化分析[J]. 高原山地气象研究, 2018, 38(4):4.</p><p>[2]高乐. 基于卫星测高技术的青藏高原湖泊水位和冰川高程变化监测研究[D]. 中国科学院大学,2014.</p><p>[3] <a href="https://www.aviso.altimetry.fr/en/data/products-guide.html?id=601">https://www.aviso.altimetry.fr/en/data/products-guide.html?id=601</a> [EB/OL].</p><p>[4] Peng, S. (2019). 1-km monthly mean temperature dataset for china (1901-2020). National Tibetan Plateau Data Center, DOI: 10.11888/Meteoro.tpdc.270961. CSTR: 18406.11.Meteoro.tpdc.270961. </p><p>[5] Peng, S. (2020). 1-km monthly precipitation dataset for China (1901-2020). National Tibetan Plateau Data Center, DOI: 10.5281/zenodo.3185722.</p><p>[6]文京川, 赵红莉, 蒋云钟,等. 卫星测高数据筛选方法研究——以Jason-3数据和洪泽湖为例[J]. 南水北调与水利科技, 2018, 16(3):8.</p><p>[7]黄征凯. 利用多源卫星数据研究青藏高原湖泊水储量变化及其影响因素[D].武汉大学,2018.</p><p>[8] <a href="https://www.aviso.altimetry.fr/en/data/calval/systematic-calval/annual-reports/jason-3.html">https://www.aviso.altimetry.fr/en/data/calval/systematic-calval/annual-reports/jason-3.html</a> [EB/OL].</p><p>[9] Sun M, Guo J, Yuan J, Liu X, Wang H and Li C (2021) Detecting Lake Level Change From 1992 to 2019 of Zhari Namco in Tibet Using Altimetry Data of TOPEX/Poseidon and Jason-1/2/3 Missions. Front. Earth Sci. 9:640553. doi: 10.3389/feart.2021.640553</p><p>[10] Peng, S.Z., Ding, Y.X., Liu, W.Z., &amp; Li, Z. (2019). 1 km monthly temperature and precipitation dataset for China from 1901 to 2017. Earth System Science Data, 11, 1931–1946. <a href="https://doi.org/10.5194/essd-11-1931-2019">https://doi.org/10.5194/essd-11-1931-2019</a><br>[11] Peng, S.Z., Ding, Y.X., Wen, Z.M., Chen, Y.M., Cao, Y., &amp; Ren, J.Y. (2017). Spatiotemporal change and trend analysis of potential evapotranspiration over the Loess Plateau of China during 2011–2100. Agricultural and Forest Meteorology, 233, 183–194.<br>[12] Peng, S. Z, Gang, C. , Cao, Y. , &amp; Chen, Y. . (2017). Assessment of climate change trends over the loess plateau in china from 1901 to 2100. International Journal of Climatology.<br>[13] Ding, Y.X., &amp; Peng, S.Z. (2020). Spatiotemporal trends and attribution of drought across China from 1901–2100. Sustainability, 12(2), 477.</p>]]></content>
    
    
    <summary type="html">扎日南木错高程和面积监测。</summary>
    
    
    
    <category term="课程学习" scheme="http://zerolacqua.top/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="遥感" scheme="http://zerolacqua.top/tags/%E9%81%A5%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>卫星摄影测量编程</title>
    <link href="http://zerolacqua.top/posts/9df20c2d.html"/>
    <id>http://zerolacqua.top/posts/9df20c2d.html</id>
    <published>2022-04-11T10:53:17.000Z</published>
    <updated>2022-04-17T14:29:40.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>采用地形无关的控制方案建立 RPC 模型。本次作业是小组作业，成果为小组共同完成，上传博客经小组成员同意。</p><h2 id="数据组成"><a href="#数据组成" class="headerlink" title="数据组成"></a>数据组成</h2><p><code>DX_ZY3_NAD_att.txt</code>：记录卫星影像某一时刻的四元数（用于计算本体坐标系与 <em>J2000</em> 坐标系之间的变换矩阵），并没有用到本体到轨道坐标系姿态的三个欧拉角。</p><p><code>DX_ZY3_NAD_gps.txt</code>：记录卫星某一时刻在 <em>WGS84</em> 坐标系中的位置，并没有用到速度数据。</p><blockquote><p>本体到轨道坐标系姿态的三个欧拉角与 GPS 速度数据应该是计算本体坐标系到轨道坐标系、轨道坐标系到 <em>WGS84</em> 坐标系的数。这里我们是用本体坐标系与 <em>J2000</em> 坐标系，然后 <em>J2000</em> 坐标系到 <em>WGS84</em> 坐标系计算的。</p><p>此外将 GPS 相位中心坐标直接视为了投影中心坐标，忽视了两者之间的误差，是因为这一部分误差可以归在<strong>偏置矩阵</strong>中，可以结合光学卫星在轨几何定标相关知识理解。</p></blockquote><p><code>DX_ZY3_NAD_imagingTime.txt</code>：记录卫星的扫描行对应的时刻，以对应 GPS 定位数据和四元数数据。</p><p><code>NAD.cbr</code>：记录一个扫描行上的像元指向角，包括垂轨和沿轨方向的指向角。在本次作业中，沿轨方向 x 指向角均为0。</p><p><code>NAD.txt</code>：记录偏置矩阵数据。本次作业中该数据均为0，不需要使用。</p><p><code>zy3.tif</code>：卫星影像数据，从<code>.tif</code>文件中可以读取影像的范围，并由此获取相应区域的 DEM 。</p><blockquote><p>在美国地质调查局USGS官网下载航天飞机成像雷达地形测绘(SRTM) DEM 数据，按卫星影像范围裁剪，作为后续检查计算的基础。</p></blockquote><p><code>zy3_rpc.txt</code>：用途暂时未知。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><ul><li><p>控制点获取</p><ul><li><p>文件读取</p></li><li><p>格网划分</p></li><li><p>四元数计算</p></li><li><p>视向量计算</p></li><li><p>视向量与椭球的交点</p><p>计算特定 H 下， 椭球与视向量的交点直角坐标</p></li></ul></li><li><p>检查点获取</p><ul><li>格网划分</li><li>根据 DEM 中仿射参数，计算大地坐标 BL 对应的 DEM 像元坐标，获取高程 H</li><li>窗口二分法确定扫描行</li></ul></li></ul><blockquote><p>这两部分有很多相通的地方：</p><ul><li>包括读取、处理数据可以公用</li><li>直角坐标 XYZ 与大地坐标 BLH 相互转换函数</li></ul></blockquote><ul><li><p>RPC 解算</p><ul><li>这一部分的计算很迷，尤其是线性化的方式，和以往的不同</li></ul></li><li><p>精度检查</p></li></ul><h2 id="要注意的地方"><a href="#要注意的地方" class="headerlink" title="要注意的地方"></a>要注意的地方</h2><ul><li><p>坐标的对应关系</p><p>整个计算过程中涉及到很多种坐标，一定要理清它们之间的关系。</p><ol><li><p>像方坐标</p><ul><li><p>(x , y) 与 (line , sample) 是等价的</p></li><li><p>(height , width)</p></li><li><p>(r , c)</p></li></ul><blockquote><p>在本次作业中，sample 对应的是图像的 width, 因而可以看出 x 对应 r，y 对应 c</p></blockquote></li><li><p>地球坐标系</p><p>要注意大地坐标 BLH 与直角坐标 XYZ 之间的转化</p></li></ol></li><li><p>像元指向角</p><p>像元指向角文件中的数据是<u>指向角</u>，而不是正切值。</p></li><li><p>地球椭球的使用</p><p>在获取控制点时，我们是通过影像格网与高度计算的地面点坐标，但其中存在一个问题。使用 xyh 计算坐标的时候得到 XYZ 坐标，</p><p>然后 XYZ 计算 BLH 坐标也会得到一个高程 H 。如果这 xyh 和 BLH 的两个高程不相等，那就会麻烦不少。其解决方法详见 PPT 内容。</p></li><li><p>RPC 的线性化，根据我的理解，它甚至没有用到偏导数，是很不常规的解法。同时，它也不需要提供较为准确的初始值（解出参数的稳定堪忧）</p></li></ul><h2 id="本次编程的感想"><a href="#本次编程的感想" class="headerlink" title="本次编程的感想"></a>本次编程的感想</h2><p>这次的小组编程任务，给我的第一感觉就是难，在老师介绍编程的大致流程的时候，就涉及到了相当多的处理过程。比如获取虚拟控制点一部分就包括了文件读取、四元数、视向量旋转、与地球椭球求交等等过程。当然，由于是小组分工合作完成，大家都可以集中精力完成自己那一部分，所以这样一个巨大的任务就被大家分解逐步地完成了。在编程实践中，我们还遇到了很多上课没有讲的内容，这些都是需要结合课堂知识，自己亲自动手，才能理解的东西。</p><p>本次任务中，我虽然不需要参与代码的具体实现过程，但作为负责整合各模块代码的人，我需要对各个部分实现和原理都有一定的了解。同时，为了各模板之间的交互与独立性，我还需要对小组其它组员的代码进行一定的修改与调整。比如说，从影像到地面点的虚拟控制点获取，以及从地面点到影像的检查点获取，这两部分的代码都需要从文件中读取相关的数据，并进行相似的处理。在各模块编写的过程中，甚至会有引入其它模块的情况。虽然并不影响代码运行，但对于梳理程序的结构还是有一定的影响。此外，为了保证计算的正确和连续，我还要为其他组员的代码编写相关的测试代码，并及时把问题反馈给他们。在这个过程中我也认识到，良好的沟通与合作在一个项目中是非常重要的。</p><p>这次实习，我不仅对课程的知识有了更深刻的理解，还在学习、整合他人代码的过程中，学习到了很多编程的技巧。因为 python 有方便的 <code>numpy</code> 、<code>gdal</code> 库可以引用，同时不必像 C++ 那样考虑内存管理和类型等等麻烦的操作，所以大家商定的编程语言为 python 。但我对 python 的使用并不熟练，需要在整合大家代码的过程中学习 <code>numpy</code> 等库中函数的用法。此外在学习理解其他组员代码的过程，我还学到了 python 文档注释用法等等实用的知识。</p><p>总之，这次的实习任务虽然有难度，但也让我受益匪浅。我不仅获得了课程中的知识、代码上的技巧，而且还加深了对团队合作的理解。最后也感谢大家辛勤付出，让一开始模糊的构想逐渐清晰实现！</p>]]></content>
    
    
    <summary type="html">卫星摄影测量编程记录。</summary>
    
    
    
    <category term="编程作业" scheme="http://zerolacqua.top/categories/%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="摄影测量" scheme="http://zerolacqua.top/tags/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>TIN的三种构建方式</title>
    <link href="http://zerolacqua.top/posts/3cd52e14.html"/>
    <id>http://zerolacqua.top/posts/3cd52e14.html</id>
    <published>2022-04-05T15:02:38.000Z</published>
    <updated>2022-05-18T01:18:52.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三种TIN的生成方法"><a href="#三种TIN的生成方法" class="headerlink" title="三种TIN的生成方法"></a>三种TIN的生成方法</h1><h2 id="生长算法"><a href="#生长算法" class="headerlink" title="生长算法"></a>生长算法</h2><p>生长算法有两种：递归生长和凸闭包收缩算法。通俗来讲就是前者是从点集中心向外扩展，后者是由外向内收敛。</p><p>以递归生长算法为例，其基本步骤是：</p><ol><li><p>在数据点中任取一点 $P_1$ （一般是位于数据点的几何中心附近），并寻找距离此点最近的点 $P_2$ 。两者相连形成初始基线 $P_1P_2$ ，利用 <em>Delaunay</em> 三角网剖分准则，在点集中寻找第三点 $P_3$ ，形成第一个三角形 $\triangle P_1P_2P_3$ 。</p></li><li><p>以初始三角形的三条边为基线，利用 <em>Delaunay</em> 三角网剖分准则，分别寻找能与该三条基线形成 <em>Delaunay</em> 三角形的 $P_4,P_5,P_6$ 点，构造新的三角形。</p></li><li><p>重复步骤2，直到所有数据点处理完毕。</p><blockquote><p><em>Delaunay</em> 三角网剖分准则</p><ul><li>满足空外接圆特性</li><li>满足最大最小角特性</li></ul></blockquote></li></ol><p>三角网生长算法逻辑简单，易于计算机编程实现，其最大的问题就在于生成过程中搜寻数据点时间效率很低，因此这部分的选择的算法主要是对搜寻数据点进行的优化$^{[1]}$。由于时间有限，只能列出一篇主要论文。</p><h3 id="利用点角改进-Delaunay-三角网生长算法"><a href="#利用点角改进-Delaunay-三角网生长算法" class="headerlink" title="利用点角改进 Delaunay 三角网生长算法"></a>利用点角改进 <em>Delaunay</em> 三角网生长算法</h3><ol><li><p><strong>点角定义</strong></p><p><em>Delaunay</em> 三角网中，任一点的点角为该点所构成的三角形中该点的角度之和。如下图所示，在 <em>Delaunay</em> 三角网中，点 $P_4$ 所在的三角形有 $\triangle P_4P_6P_5,\ \triangle P_4P_3P_6,\ \triangle P_4P_2P_3,\ \triangle P_4P_1P_2,\ \triangle P_4P_5P_1$ ，易知 $P_4$ 的点角为:</p></li></ol><script type="math/tex; mode=display">\begin{equation}   \angle P_4=\angle 1+\angle 2+\angle 3+\angle 4+\angle 5=360°   \end{equation}</script><p>   显然，除了 <em>Delaunay</em> 三角网中凸包点（最外层多边形构成的点）外，其他任何点的点角都为 360°。为了保证统一且算法更易实现，规定凸包点的点角也为 360°，如下图中三角网点 $P_2$ 的点角为 $\angle P_2= \angle6+\angle7+\angle8=360°$。如此，在构造 <em>Delaunay</em> 三角形之前需先寻找离散点的凸包，计算边界点的点角。</p><p>   <img src="/images/blogs/TIN的三种构建方式/1.png" alt="图1"></p><ol><li><p><strong>计算凸壳</strong></p><p>常规的三角网生长算法不需要计算凸壳，这里主要是为查找凸包点并计算每个凸包点的外角，将其赋值为该点的点角，并为确定初始基线边做准备。</p><p>使用格雷厄姆方法来求点集的凸壳。</p><ul><li><p>设点集中纵坐标最小的点为 $P_1$；</p></li><li><p>将 $P_1$ 和点集中其他各点用有向线段连接，并计算这些线段与水平线的夹角；</p></li><li><p>线段按夹角大小排序（夹角相同时，按点到 $P_1$ 的距离排序），得到一序列 $P_1，P_2,\cdots,P_n$ ；</p></li><li><p>依次连接所有点，便得到一多边形。显然，$P_1，P_2,\cdots,P_n$ 是凸壳边界上的点（见下图）。依据“凸多边形的各顶点必在该多边形的任意一条边同侧”的原则，删去边界序列中的非凸点，从而得到凸壳点集，并以顺时针连接各凸壳点形成有向凸多边形（见下图）。</p></li></ul></li></ol><pre><code> ![图2](/images/blogs/TIN的三种构建方式/2.png)</code></pre><ol><li><p><strong>CCW 方位测试</strong></p><p>CCW 方位测试（简称 CCW 检测）主要用来查找符合条件的点构成 <em>Delaunay</em> 三角形，可以判断出点与方向线的相互关系，CCW 方位测试如图下所示。</p></li></ol><p>   <img src="/images/blogs/TIN的三种构建方式/3.png" alt="图3"></p><script type="math/tex; mode=display">\begin{equation}   CCW(c,a,b)=   \begin{vmatrix}   a_x&a_y&1\\\\   b_x&b_y&1\\\\   c_x&c_y&1\\\\   \end{vmatrix}=   \begin{vmatrix}   a_x-c_x&a_y-c_y\\\\   b_x-c_x&b_y-c_y\\\\   \end{vmatrix}   \end{equation}</script><p>   根据公式 $(2)$ 计算出来的结果的正负性 $(&gt;0,\ &lt;0,\ =0)$，可判断出点 $c$ 在 $\overrightarrow{ab}$ 的左侧、右侧或直线上。</p><p>   该论文在构造 <em>Delaunay</em> 三角形时，只有 $\overrightarrow{ab}$ 右侧的点才能与 $\overrightarrow{ab}$ 构成三角形。</p><ol><li><strong>构建三角网</strong></li></ol><ul><li><p>确定初始基线边，如下图 b 所示，子块的凸壳形成后，以纵坐标最小的点为初始基线边的第一点，从图中易知 $\overrightarrow {P_1 P_{11}}$ 便是初始基线边，且凸多边形每条有向边都是待扩展的基线边。</p></li><li><p>构建首个三角形，从所有离散点中查找能与 $\overrightarrow {P_1 P_{11}}$ 构三角形最优的点，形成首个三角形存入 <em>Triangle</em> 中。如下图 b，首个三角形为 $\triangle P_1P_{10}P_{11}$，同时，计算该三角形每个点的点角，其中 $P_{10}$ 的点角为 $\angle P_{10}= \angle 1$，$P_1$  的点角为 $\angle P1= \angle 2+\angle 3$，$P_{11}$  的点角 $\angle P_{11}= \angle 4+\angle 5$。首个三角形同时也形成了三条有向边，将 $\overrightarrow {P_{1} P_{10}},\ \overrightarrow {P_{10} P_{11}}$ 存入 <em>Edge</em>（待扩展基线边）中， $\overrightarrow {P_{11} P_{1}}$ 与 $\overrightarrow {P_1 P_{11}}$ 则不再需要扩展，从 Edge 中删除 $\overrightarrow {P_1 P_{11}}$ 的记录（ $\overrightarrow {P_{11} P_{1}}$ 直接不需存）。</p></li><li><p>扩展三角网，按顺序从 <em>Edge</em>（待扩展基线边）中取出一条边，从点角不为360°的点集中查找最优点构建 <em>Delaunay</em> 三角形。每扩展一个三角形，需要从 <em>Edge</em> 中删除该有向边，同时计算三个角的点角，生成两条新的有向边。判断 <em>Edge</em> 中有无与新生成的边方向相反且点相同的边，若有，则从 <em>Edge</em> 中删除该边，否则存入新生成的有向边。当 <em>Edge</em> 中无元素时子三角网构建完成，此时点集中所有点的点角为360°。</p></li></ul><pre><code> ![图4](/images/blogs/TIN的三种构建方式/4.png)</code></pre><h3 id="个人看法"><a href="#个人看法" class="headerlink" title="个人看法"></a>个人看法</h3><p>在另一个生长算法的论文$^{[3]}$中提到了几个概念，与上述论文有一定相通之处。</p><p><strong>排除封闭点</strong></p><p>在寻找第三点构网的过程中会不断产生封闭点。以 $P1$ 为起始点经过3次遍历后的结果如下图所示，此时点 $P3$ 已被三角形所包围，称之为封闭点。封闭点将不再参与下一次遍历边集寻找第三点的过程，因此第 4 次遍历前可将点 $P3$ 从备选点集中移除。通过动态地排除封闭点，可将第三点的备选范围不断缩小，以减少寻点时间。</p><p><img src="/images/blogs/TIN的三种构建方式/5.png" alt="图5"></p><p>这里的<strong>封闭点</strong>，其实和<strong>点角</strong>的概念相近，只不过<strong>点角</strong>是<strong>封闭点</strong>一个具体判断方法。</p><p>由于以前参加编程小组学习建TIN的时候，就是顺着相似的思路写了一个简陋的算法，看到<strong>点角</strong>就有种亲切感，所以生长算法篇幅就比较多。</p><h2 id="逐点插入法"><a href="#逐点插入法" class="headerlink" title="逐点插入法"></a>逐点插入法</h2><p>逐点插入法的基本步骤$^{[1]}$：</p><ul><li>定义一个包含所有数据点的初始多边形；</li><li>在初始多边形中建立初始三角网，然后迭代以下步骤，直至所有数据点都被处理；</li><li>插入一个数据点 $P$ ，在三角网中找出包含 $P$ 的三角形 $t$ ，把 $P$ 与 $t$ 的三个顶点相连，生成三个新的三角形；</li><li>用 <em>LOP</em> 算法优化三角网。</li></ul><p>可以看出，逐点插入算法的思路非常简单，先在包含所有数据点的一个多边形中建立初始三角网，然后将余下的点逐一插入，用 <em>LOP</em> 算法确保其成为 <em>Delaunay</em> 三角网。各种实现方法的差别在于其初始多边形的不同以及建立初始三角网的方法不同。</p><h3 id="一种改进的-Delaunay-三角剖分快速实现算法"><a href="#一种改进的-Delaunay-三角剖分快速实现算法" class="headerlink" title="一种改进的 Delaunay 三角剖分快速实现算法"></a>一种改进的 <em>Delaunay</em> 三角剖分快速实现算法</h3><p>对以往提出的逐点插入算法的研究发现，影响逐点插入法时间效率的主要因素为点的插入次序。针对这一特点，对逐点插入法进行改进。</p><ol><li><p>基本概念</p><ul><li><p>极大三角形</p><p>在平面内，加入三个点形成一个三角形，使其能够包含点集中的所有点。这个极大三角形就作为三角剖分的辅助初始三角形。</p></li><li><p>影响域</p><p>对每个插入点，外接圆包含该点的所有三角形所构成的多边形区域称为该点的影响域。</p></li></ul></li><li><p>数据结构</p><p>算法的执行效率与数据结构之间有着很密切的关系。该论文中使用的数据结构简要列出如下：</p><ul><li><p>有序顶点类</p><p>保存散乱点集和<strong>排序</strong>后的顶点序列。</p></li><li><p>有向边类</p><p>保存三角形的边以及与该边相邻的三角形信息。</p></li><li><p>三角形类</p></li><li><p>保存生成的各个三角形的顶点及边信息</p></li></ul></li><li><p>算法的主要步骤</p><ul><li><p>将点集中的点在平面内以 $X$ 轴为主，$Y$ 轴为辅进行升序排序；</p></li><li><p>虚构一个极大三角形成为最初的三角形，使其包含点集中的所有点；</p></li><li><p>插入第一个点，这个点肯定在初始三角形内，连接这个点和极大三角形的各个顶点，形成最初的三角网；</p></li><li><p>依次插入排好序的点到已生成的三角网中，对插入点找到该点的影响域，连接该插入点和它影响域的各个顶点，即重构了 <em>Delaunay</em> 三角网；</p></li><li><p>删除所有以极大三角形顶点为顶点的三角形，即多余三角形，最后得到的三角网就是所求的 <em>Delaunay</em> 三角网。</p></li></ul></li><li><p>新插入一个顶点的过程</p><ul><li>在已存在的 <em>Delaunay</em> 内新插入一个点，首先定位该点所在的三角形，由于<strong>对点集中的所有点进行了有序化</strong>，所有定位三角形时不像传统方法那样需要遍历当前所有三角形；</li><li>其次找出有哪些三角形的<strong>外接圆包含该插入点</strong>，即确定出该点的影响域，删除影响域内的三角形，形成一个空腔，连接新插入点与空腔的各个顶点，形成多个三角形；</li><li>最后把新生成的三角形放回三角网中。</li></ul></li></ol><h3 id="个人看法-1"><a href="#个人看法-1" class="headerlink" title="个人看法"></a>个人看法</h3><ol><li>在上述论文的描述中，虽然并没有明确地使用 <em>LOP</em> 算法。但是个人认为实际上在<strong>新插入一个顶点的过程</strong>中，“寻找外接圆包含插入点的三角形，并删去这些三角形，再连接新插入点”的操作，就等效于使用了 <em>LOP</em> 算法。</li><li><p>无论是在生长算法，还是逐点插入法中，排序都是很重要的一种优化思路，如论文 [3,4] 都提到了排序的必要性。并且能连接成三角形的点基本上距离很近。结合无人机摄影中学到的 <em>KD</em>-树的概念，我们是否能采用类似的树结构进行优化呢？在论文 [5] 中也确实有四叉树划分点云数据文件进行并行计算动态调度的思路。</p><h2 id="分割-合并算法"><a href="#分割-合并算法" class="headerlink" title="分割-合并算法"></a>分割-合并算法</h2></li></ol><p>将分治算法思想应用于生成 <em>Delaunay</em> 三角网，递归地分割点集，直至子集中只包含三个点而形成三角形，然后自下而上地逐级合并生成最终的三角网。其基本步骤如下<sup>[1]</sup>：</p><ul><li>把点集 $V$ 以横坐标为主，纵坐标为辅按升序排序，然后递归地执行以下步骤；</li><li>把点集 $V$ 分为近似相等的两个子集 $V_L$ 和 $V_R$ ；</li><li>$V_L$ 和 $V_R$ 中生成三角网；</li><li>用 <em>LOP</em> 算法优化所生成的三角网，使之成为 <em>Delaunay</em> 三角网；</li><li>找出连接 $V_L$ 和 $V_R$ 中两个凸壳的底线和顶线；</li><li>由底线至顶线合并  $V_L$ 和 $V_R$ 中两个三角网。</li></ul><p>以上步骤显示，这种算法的基本思路是使问题简化，把点集划分到足够小，使其易于生成三角网，然后把子集中的三角网合并生成最终的三角网，用 <em>LOP</em> 算法保证其成为 <em>Delaunay</em> 三角网。</p><h3 id="Delaunay-三角网的生成算法研究"><a href="#Delaunay-三角网的生成算法研究" class="headerlink" title="Delaunay 三角网的生成算法研究"></a><em>Delaunay</em> 三角网的生成算法研究</h3><ol><li><p>其基本步骤为：</p><ul><li><p>把点集 $V$ 以横坐标为主，纵坐标为辅按升序排序，然后递归地执行以下步骤；</p></li><li><p>若 $V$ 中数据量大于一给定值，把 $V$ 分为近似相等的两个子集 $V_L$ 和 $V_R$ ；</p></li><li><p>在 $V_L$ 和 $V_R$ 中用合成算法生成三角网；</p></li><li><p>找出连接 $V_L$ 和 $V_R$ 中两个凸壳的底线和顶线；</p></li><li><p>由底线至顶线合并 $V_L$ 和 $V_R$ 中两个三角网</p></li><li><p>否则生成基本三角网</p></li></ul></li><li><p>基本三角网生成过程</p><ul><li><p>生成凸壳过程</p><p>使用 <em>Larkin</em> 改进和完善了的凸壳生成算法。</p><p>把具有 $x,y,x+y,x-y$ 的极大值和极小值的点相连作为初始凸壳，然后用一个递归过程 $convex(I,J)$ 把位于其中相邻两点间凸壳上的其余点找出来。为提高搜索效率，先把数据分块。 $convex(I,J)$ 搜索包含线段 $\overrightarrow{IJ}$ （从 $I$ 到 $J$ 逆时针方向）的矩形内的数据块。找出位于 $\overrightarrow{IJ}$ 右侧与 $\overrightarrow{IJ}$ 距离最大的点。该点就是要找的凸壳上的点。如果最大距离为零，则要判断它是否位于 $I,J$ 之间。如是，它也是凸壳上的点。 </p></li><li><p>初始三角网生成过程</p></li><li><p>点插入过程</p></li><li><p>局部优化过程（<em>LOP</em>）</p><p>局部优化过程（<em>LOP</em>）是所有生成 <em>Delaunay</em> 三角网的算法都要用到的关键过程。理论上说，不论用何种方法生成的三角网，只要用 <em>LOP</em> 过程进行处理，就能使它变为 <em>Delaunay</em> 三角网。这样一个重要的过程其实非常简单，它就是运用 <em>Delaunay</em> 三角网的性质，对由两个有公共边的三角形组成的四边形进行判断。如果其中一个三角形的外接圆包含第四个顶点，则将这个四边形的对角线交换。</p><p><img src="/images/blogs/TIN的三种构建方式/6.png" alt="图6"></p></li></ul></li><li><p>寻找连接两个凸壳的底线过程</p><p>分治算法分两步进行，首先找出连接左右两个凸外界的顶线和底线，然后由底至顶合并两个子三角网。这两个过程都要用到函数 $pred(v_i,v_j)$ 和 $succ(v_i,v_j)$ 。函数 $pred(v_i,v_j)$ 找出在以 $v_i$ 为共同端点的一簇线段中，与 $v_iv_j$ 顺时针方向相邻线段的另一端点，$succ(v_i,v_j)$ 找出与 $v_iv_j$ 逆时针方向相邻线段的另一端点。</p><p>通过这两个函数，可以找到连接 $H_L,H_R$ 两个凸壳的底线和顶线。</p></li><li><p>子三角网归并过程</p><p>子三角网的合并过程也是一个迭代过程，它从连接 $H_L,H_R$ 的底线开始，在两个子三角网 $T_L,T_R$ 中寻找与底线组成 <em>Delaunay</em> 三角形的第三点 $L_1,R_1$ ，选其中外接圆半径小的一个插入到最最终的三角网中。新生成的连接左右两个子三角网的边成为新的底线，逐步上推直到顶线结束，如下图所示。</p><p><img src="/images/blogs/TIN的三种构建方式/7.png" alt="图7"></p></li></ol><h3 id="个人看法-2"><a href="#个人看法-2" class="headerlink" title="个人看法"></a>个人看法</h3><p>逐点插入算法实现比较简单，占用内存较小，但它的时间复杂度高；分治算法时间复杂度方面最好，但由于递归执行，内存占用大。为了均衡各种算法的不足，有不少新算法都是围绕着将多种算法融合的思路提出的，如论文 [6,7]，以及上面提到的论文 [1] 。</p><hr><h2 id="视频推荐"><a href="#视频推荐" class="headerlink" title="视频推荐"></a>视频推荐</h2><p>一个关于Graham算法的参考视频</p><ul><li><a href="https://www.bilibili.com/video/BV1v741197YM">[计算几何] Graham算法构造凸包（重制）</a></li></ul><p>一个逐点插入法的参考视频（和上面那个视频是同一个作者！）。讲得还不错，可以去看看！里面还提到了 <em>CCW</em> 方位测试</p><ul><li><a href="https://www.bilibili.com/video/BV1Ck4y1z7VT">[计算几何] 随机增量法构造德劳内三角网</a></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]武晓波, 王世新, 肖春生. Delaunay三角网的生成算法研究[J]. 测绘学报, 1999, 28(1):28-35.</p><p>[2]李建平,徐猛.利用点角改进Delaunay三角网生长算法[J].地理空间信息,2018,16(02):82-84+12.</p><p>[3]韦云舰,卢中.Delaunay三角网生长法的优化与应用[J].地理空间信息,2021,19(05):101-103+119+6.</p><p>[4]宋晓宇,王守金,王永会. 一种改进的Delaunay三角剖分快速实现算法[C]//.2008’中国信息技术与应用学术论坛论文集（二）.,2008:129-131.</p><p>[5]LI Jian, LI Deren, SHAO Zhenfeng. A Streaming Data Delaunay Triangulation Algorithm Based on Parallel Computing[J]. Geomatics and Information Science of Wuhan University, 2013, 38(7): 794-798.</p><p>[6]芮一康,王结臣.Delaunay三角形构网的分治扫描线算法[J].测绘学报,2007(03):358-362.</p><p>[7]刘云,夏兴东,黄北生.基于分治算法与逐点插入法的Delaunay三角网建立算法的改进[J].现代测绘,2010,33(04):14-16.</p>]]></content>
    
    
    <summary type="html">数字摄影测量小作业</summary>
    
    
    
    <category term="课程学习" scheme="http://zerolacqua.top/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="摄影测量" scheme="http://zerolacqua.top/tags/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>数字摄影测量编程与实习</title>
    <link href="http://zerolacqua.top/posts/4ee41539.html"/>
    <id>http://zerolacqua.top/posts/4ee41539.html</id>
    <published>2022-03-24T08:35:39.000Z</published>
    <updated>2022-05-18T01:17:37.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又是编程作业。</p><blockquote><p>工程文件请见：<a href="/resources#工程代码">数字摄影测量</a></p></blockquote><h2 id="影像匹配"><a href="#影像匹配" class="headerlink" title="影像匹配"></a>影像匹配</h2><blockquote><p> 相关系数+最小二乘匹配</p></blockquote><h3 id="Mat相关知识"><a href="#Mat相关知识" class="headerlink" title="Mat相关知识"></a>Mat相关知识</h3><ul><li>行列与坐标的对应关系，经常容易混</li></ul><p><code>opencv</code>影像矩阵<code>Mat</code>的<code>rows</code>对应<code>y</code>方向，<code>cols</code>对应<code>x</code>方向。</p><p>构造<code>Mat</code>时，<code>rows</code>在前，<code>cols</code>在后：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Mat</span>(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> type);</span><br></pre></td></tr></table></figure><p>使用<code>Mat::at&lt;_Tp&gt;</code>时，<code>rows</code>在前，<code>cols</code>在后：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">intereMat.<span class="built_in">at</span>&lt;<span class="type">int</span>&gt;(row, col);<span class="comment">//也就是(y,x)</span></span><br></pre></td></tr></table></figure><p>使用坐标时，顺序是正常的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point2f point=<span class="built_in">Point2f</span>(x,y);</span><br></pre></td></tr></table></figure><ul><li><p>数据类型</p><table><thead><tr><th>变量类型</th><th>大小</th><th>范围</th><th>Mat中对应的数据类型</th></tr></thead><tbody><tr><td>uchar</td><td>8bits</td><td>0~255</td><td>CV_8U</td></tr><tr><td>char</td><td>8bits</td><td>-128~127</td><td>CV_8S</td></tr><tr><td>ushort</td><td>16bits</td><td>0~65535</td><td>CV_16U</td></tr><tr><td>short int</td><td>16bits</td><td>-32768~32767</td><td>CV_16S</td></tr><tr><td>int</td><td>32bits</td><td>-2147483648~2147483647</td><td>CV_32S</td></tr><tr><td>float</td><td>32bits</td><td>1.18e-38~3.40e38</td><td>CV_32F</td></tr><tr><td>double</td><td>64bits</td><td>2.23e-308~1.79e308</td><td>CV_64F</td></tr></tbody></table><p>表格不全，但基本上可以看出类型的规律，数据类型以<code>CV_</code>+<code>位数</code>+<code>有无符号</code>(+<code>波段数</code>)组成。使用<code>Mat::at&lt;_Tp&gt;</code>时变量类型要与Mat的数据类型对应。</p><p>在数据类型后加上<code>C1</code>，<code>C2</code>，<code>C3</code>，可以指明<code>Mat</code>存储数据的波段数，此时变量类型使用对应的向量类型，源码如下。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">2</span>&gt; Vec2b;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">3</span>&gt; Vec3b;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;uchar, <span class="number">4</span>&gt; Vec4b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">short</span>, <span class="number">2</span>&gt; Vec2s;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">short</span>, <span class="number">3</span>&gt; Vec3s;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">short</span>, <span class="number">4</span>&gt; Vec4s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;ushort, <span class="number">2</span>&gt; Vec2w;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;ushort, <span class="number">3</span>&gt; Vec3w;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;ushort, <span class="number">4</span>&gt; Vec4w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">int</span>, <span class="number">2</span>&gt; Vec2i;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">int</span>, <span class="number">3</span>&gt; Vec3i;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">int</span>, <span class="number">4</span>&gt; Vec4i;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">int</span>, <span class="number">6</span>&gt; Vec6i;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">int</span>, <span class="number">8</span>&gt; Vec8i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">float</span>, <span class="number">2</span>&gt; Vec2f;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">float</span>, <span class="number">3</span>&gt; Vec3f;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">float</span>, <span class="number">4</span>&gt; Vec4f;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">float</span>, <span class="number">6</span>&gt; Vec6f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">double</span>, <span class="number">2</span>&gt; Vec2d;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">double</span>, <span class="number">3</span>&gt; Vec3d;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">double</span>, <span class="number">4</span>&gt; Vec4d;</span><br><span class="line"><span class="keyword">typedef</span> Vec&lt;<span class="type">double</span>, <span class="number">6</span>&gt; Vec6d;</span><br></pre></td></tr></table></figure></li></ul><h3 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h3><p>采用的是<code>Moravec</code>特征提取算法，为了使经验阈值能不受窗口大小变化的影响，算法中计算兴趣值时进行了归一化（除以了窗口大小）。</p><h3 id="相关系数匹配"><a href="#相关系数匹配" class="headerlink" title="相关系数匹配"></a>相关系数匹配</h3><p>从幻灯片里复制下来的左右影像对，其大小并不完全相同。因而先对影像进行了一次重采样，避免后续处理中的问题。</p><ul><li><p>用目标窗口直接对右影像进行整影像扫描</p><p>对于第一组影像来说，由于左右影像基本上可以视为只有平移变换的影像，因而直接用形状相同的正方形窗口进行相关系数匹配，结果也很好。但是对于第二组影像来说，由于影像存在倾斜，匹配效果明显下降。此外，在第一步特征提取时也可以发现，<code>Moravec</code>算法提取的第二组的特征点兴趣值，也比第一组低，这可能也是匹配效果不佳的一个原因。</p><p>此外，这种遍历整个影像的匹配算法，计算量大且浪费时间，匹配特征点的数量一旦变多，耗费时间就成倍增加，并不是一种可行的方案。</p></li><li><p>优化算法，减少重复计算</p><p>第一次扫描时，每次移动窗口，都把目标窗口（左影像上的窗口）重新计算了一遍，但是其实每次扫描中目标窗口都是不变的，所以进行了大量的无意义计算。同时，窗口移动时，右影像窗口的计算有一部分是重叠的，也可以进行优化。</p><p>计算速度虽然变快了，但能计算的点的数量依然有限，耗费时间依然太长。</p></li><li><p>优化算法，加入对上下视差和左右视差的预测</p><p>注意到第一组影像基本上没有倾斜与旋转的影像，因而考虑可以由前若干次的扫描结果预测一个大概的上下视差和左右视差，然后在此基础上，预测右影像待匹配的窗口。</p><p>匹配速度较上一次改进有很大的提升，并且匹配的效果也很好。</p><p>但是第二对影像的匹配效果依然差得离谱。</p><p>从理论上，对倾斜影像，如果依然采用正方形窗口（矩形窗口）而不根据倾斜的特点调整形状重采样的话，匹配效果是不可能有所改善的。因为相关系数本质上就是灰度分布相似的区域，而倾斜影像产生的像点位移会破坏掉原有的灰度分布（或者说是形状），导致相关系数失效。</p></li><li><p>对于透视变换的重采样</p><p>数字摄影测量课上所讲的核线重采样需要内方位元素，而题目所给数据并没有任何方位元素数据。虽然通过5对以上同名像点可以进行相对定向，但是缺少内方位元素不能直接运用。根据射影几何的知识，左右影像之间应该存在着射影变换关系。$n$维射影变换可用$n+2$对点确定，因此我们可以通过4对同名像点，确定左右影像像点之间的关系。将右影像按射影变换重采样到左影像上，然后相关系数匹配就可以使用相同大小的窗口进行匹配了。</p><blockquote><p>主要用到的函数：</p><p><code>getPerspectiveTransform</code>：由四对点计算透视变换矩阵。</p><p><code>warpPerspective</code>：根据透视变换矩阵，对图像进行透视变换。</p></blockquote><p>经过变换之后我们可以看到，这对影像基本上与第一对影像类似了。因此，我们可以使用对第一幅影像的处理方法进行处理。</p><p>结果虽然有小部分错点，但效果比未变换时要好很多很多。</p><p>参考：<a href="https://blog.csdn.net/weixin_42905141/article/details/100745097">Opencv学习（15）—warpPerspective()_华山令狐冲、的博客-CSDN博客_warpperspective</a></p></li></ul><h3 id="最小二乘匹配"><a href="#最小二乘匹配" class="headerlink" title="最小二乘匹配"></a>最小二乘匹配</h3><p>最小二乘匹配的前提是要有近似的匹配点作为初值。因此，需要先进行相关系数匹配之后，才能开始最小二乘匹配。</p><ul><li><p>几点需要注意的地方</p><ol><li><p>$\cfrac{\partial g_2}{\partial x_2},\cfrac{\partial g_2}{\partial y_2}$ 要怎么求？</p><p>虽然是对$x_2,y_2$求偏导，但实际上要理清楚，求导是在$g2$的影像上直接通过$\cfrac{g_2(x+1,y)-g_2(x-1,y)}{2}$计算，与$x_2,y_2$是无关的，更不要用$g_2$几何纠正之后的图计算偏导数。</p></li><li><p>插值公式</p><p>课件上的插值公式图中的$x$轴和$y$轴与<strong>opencv</strong>上的是相反的。</p></li><li><p>未知数更新的式子很奇怪</p><p>和正常情况下的线性化然后更新的过程不一样，但是实际上确实收敛了。</p></li></ol></li><li><p>代码太乱，不放上来了</p></li></ul><h2 id="核线重采样"><a href="#核线重采样" class="headerlink" title="核线重采样"></a>核线重采样</h2><p>使用”水平”影像法制作核线影像，卫星摄影测量中讲得很仔细。</p><h3 id="水平影像纠正关系"><a href="#水平影像纠正关系" class="headerlink" title="水平影像纠正关系"></a>水平影像纠正关系</h3><p>在解析摄影测量中，我们学习过倾斜影像与水平影像的关系，这种关系是基于共线条件方程建立的</p><script type="math/tex; mode=display">\begin{equation}\begin{bmatrix}x\\\\ y\\\\ -f\end{bmatrix}=\lambda R^\mathrm{T}\cdot\begin{bmatrix}X-X_S\\\\ Y-Y_S\\\\ Z-Z_S\end{bmatrix}\end{equation}</script><p>若要建立与水平影像的关系，就应该找到两者之间的联系——倾斜影像和水平影像对应的像点具有相同的地面坐标。</p><p>需要注意的是水平影像与倾斜影像的外方位线元素是相同的（纠正前后投影中心位置是不变的）</p><script type="math/tex; mode=display">\begin{equation}\begin{bmatrix}x_n\\\\ y_n\\\\ -f_n\end{bmatrix}=\lambda_n  R_n^\mathrm{T}\cdot\begin{bmatrix}X-X_S\\\\ Y-Y_S\\\\ Z-Z_S\end{bmatrix}\end{equation}</script><p>两式联立，求得</p><script type="math/tex; mode=display">\begin{equation}\cfrac{1}{\lambda_n}R_n\begin{bmatrix}x_n\\\\ y_n\\\\ -f_n\end{bmatrix}=\cfrac{1}{\lambda}R\begin{bmatrix}x\\\\ y\\\\ -f\end{bmatrix}\end{equation}</script><p>对于水平影像，其$R_n$是单位矩阵。</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}x_n&=-f\cfrac{a_1x+a_2y-a_3f}{c_1x+c_2y-c_3f}\\\\ y_n&=-f\cfrac{b_1x+b_2y-b_3f}{c_1x+c_2y-c_3f}\end{aligned}\end{equation}</script><h3 id="平行于基线的影像纠正关系"><a href="#平行于基线的影像纠正关系" class="headerlink" title="平行于基线的影像纠正关系"></a>平行于基线的影像纠正关系</h3><p>课本中所谓的“水平”影像实际上指平行于基线的影像。关系式依然是式（3），但是$R_n$不能简单地用单位矩阵表示。而是应该根据基线计算出一个旋转矩阵，使得经这个旋转矩阵旋转后，影像恰好能平行于基线。</p><blockquote><p>卫星摄影测量课程中这种核线重采样方法讲得很详细，但是具体如何计算旋转矩阵，还是要靠自己理解，否则计算的角度可能正负会反。</p></blockquote><p>建立了关系之后，利用间接法，对原始影像进行内插，灰度赋值，完成核线重采样工作。</p>]]></content>
    
    
    <summary type="html">数字摄影测量编程记录。</summary>
    
    
    
    <category term="编程作业" scheme="http://zerolacqua.top/categories/%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="摄影测量" scheme="http://zerolacqua.top/tags/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>卫星摄影测量知识整理</title>
    <link href="http://zerolacqua.top/posts/deb7f8ad.html"/>
    <id>http://zerolacqua.top/posts/deb7f8ad.html</id>
    <published>2022-03-21T08:09:21.000Z</published>
    <updated>2022-05-03T16:51:40.016Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning modern"><p>具体内容待更新！</p></div><h2 id="复习题"><a href="#复习题" class="headerlink" title="复习题"></a>复习题</h2><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><ol><li><strong>什么是瞬时像平面坐标系？</strong></li><li><strong>如何定义轨道坐标系、本体坐标系？</strong></li><li><strong>写出本体坐标系到地心直角坐标系的坐标变换的主要过程。</strong></li><li><strong>线阵相机成像原理？</strong></li><li><strong>卫星线阵相机立体影像获取的方式？各有什么特点?</strong></li><li><strong>如何建立卫星CCD传感器姿轨模型？</strong></li><li><strong>CCD传感器线性姿轨模型（12参数）？</strong></li><li><strong>基于共线方程的严格成像模型有什么优缺点？</strong></li><li><strong>线阵影像反投影原理？方法？主要过程？</strong></li><li><strong>卫星CCD影像光束法平差物方坐标系的选择？</strong></li><li><strong>如何理解中心投影与平行投影的关系？</strong></li><li><strong>平行投影的仿射变换模型等效替代严格模型？</strong></li><li><strong>高分辨率遥感卫星仿射变换成像模型建立的原理？有什么特点？</strong></li><li><strong>如何将中心投影转换为平行投影？（平坦地区、地形起伏地区）</strong></li><li><strong>如何计算平行投影的仿射变换模型参数？</strong></li><li><strong>非线性平行投影模型？</strong></li><li><strong>如何根据导航数据计算非线性平行投影模型参数？</strong></li></ol><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><ol><li><strong>物理传感器模型特点？</strong></li><li><strong>通用传感器模型特点？</strong></li><li><strong>有理函数模型？有何特点？</strong></li><li><strong>标准化参数？作用？</strong></li><li><strong>单片RFM解算的主要步骤？</strong></li><li><strong>简述单片RFM解算的两种控制方案？优缺点？</strong></li><li><strong>RFM三维重建算法。</strong></li><li><strong>RPC模型的系统误差补偿方案？</strong></li><li><strong>RPC扩展模型？像方系统误差补偿原理？</strong></li><li><strong>RPC模型区域网平差原理及主要过程?</strong></li></ol><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><ol><li><strong>框幅式相机成像特点？推扫式相机成像特点？</strong></li><li><strong>立体影像的核面、核线？</strong></li><li><strong>框幅式、推扫式相机影像的核线各有什么特点？</strong></li><li><strong>核线的应用、核线影像重采样的目的？</strong></li><li><strong>推导框幅式影像的核线模型。</strong></li><li><strong>推导线阵推扫影像的核线模型。</strong></li><li><strong>如何理解立体影像核线对的概念？</strong></li><li><strong>线阵推扫影像上，局部场景和全局场景的核线有何特点？</strong></li><li><strong>平行投影影像上核线的特点？</strong></li><li><strong>利用平行投影模型进行核线重采样的主要过程？</strong></li><li><strong>线性平行投影模型、非线性平行投影模型。</strong></li><li><strong>线阵推扫影像核曲线获取原理？核曲线与物方高程范围关系？</strong></li><li><strong>分段立体核曲线对生成原理？</strong></li><li><strong>分段核线影像重采样的方法？</strong></li><li><strong>基于RPC的分段核线影像生成的主要过程？</strong></li></ol>]]></content>
    
    
    <summary type="html">卫星摄影测量学习堆积处。</summary>
    
    
    
    <category term="课程学习" scheme="http://zerolacqua.top/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="摄影测量" scheme="http://zerolacqua.top/tags/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/"/>
    
    <category term="遥感" scheme="http://zerolacqua.top/tags/%E9%81%A5%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>近景摄影测量编程与实习</title>
    <link href="http://zerolacqua.top/posts/5f0fff90.html"/>
    <id>http://zerolacqua.top/posts/5f0fff90.html</id>
    <published>2022-03-20T12:25:02.000Z</published>
    <updated>2022-05-09T00:54:19.227Z</updated>
    
    <content type="html"><![CDATA[<div class="note warning modern"><p>具体内容待更新！</p></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录编程中的问题</p><h2 id="影像获取"><a href="#影像获取" class="headerlink" title="影像获取"></a>影像获取</h2><p>影像的拍摄在近景实验室检校场。检校场的空间较小，所以应当选用较小的焦距，同时为了保证检校场中的控制点能全都成像，还需要对光圈进行调整（因此选择光圈优先）。</p><p>由于需要获取立体像对，我们要尽量保证相机的内方位元素不变。因此，在拍摄影像的过程中，选用手动调焦最好。</p><p>后方交会时，解非线性方程，需要内外方位元素的初值，在拍摄时，要大概地进行记录。</p><h2 id="识别像点坐标"><a href="#识别像点坐标" class="headerlink" title="识别像点坐标"></a>识别像点坐标</h2><h3 id="圆形识别"><a href="#圆形识别" class="headerlink" title="圆形识别"></a>圆形识别</h3><p>采用的是边缘检测，并拟合椭圆的方法。这种方法简单有效，易于操作，但是对参数的设置要求较高。</p><p>主要函数：</p><ul><li><p><code>GaussianBlur</code>：进行高斯模糊，减小噪声。噪声会影响<code>Canny</code>算子提取边缘的效果。</p><blockquote><p>确实影响很大，不做高斯模糊有的很明显的圆都识别不出来，还困扰了我很久。</p></blockquote></li><li><p><code>Canny</code>：提取边缘。</p></li><li><p><code>findContours</code>：边缘追踪，得到轮廓。</p></li><li><p><code>contourArea</code>：计算轮廓包围的面积，可以控制识别圆形的大小。</p><blockquote><p>但是要注意<code>contourArea</code>算的面积是有误差的。</p></blockquote></li><li><p><code>arcLength</code>：计算轮廓的周长，结合面积可以计算圆形度。</p></li><li><p><code>fitEllipse</code>：根据轮廓拟合椭圆。</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cvtColor</span>(focusImg, grayImg, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//边缘提取</span></span><br><span class="line"><span class="built_in">GaussianBlur</span>(grayImg, grayImg, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Mat edgeImage;</span><br><span class="line"><span class="built_in">Canny</span>(grayImg, edgeImage, <span class="number">30</span>, <span class="number">70</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//边缘追踪</span></span><br><span class="line">vector&lt;vector&lt;Point&gt;&gt; contours;<span class="comment">// 轮廓</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">findContours</span>(edgeImage, contours, CV_RETR_LIST, CV_CHAIN_APPROX_NONE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> area = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> perimeter = <span class="number">0</span>;</span><br><span class="line">Mat cirImg = Mat::<span class="built_in">zeros</span>(edgeImage.<span class="built_in">size</span>(), CV_8UC3);</span><br><span class="line"><span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">Point center = <span class="built_in">Point</span>(<span class="number">-999</span>, <span class="number">-999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出并筛选圆形</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it1 = contours.<span class="built_in">begin</span>(); it1 != contours.<span class="built_in">end</span>(); )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拟合点个数筛选</span></span><br><span class="line">    count = it1-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        it1 = contours.<span class="built_in">erase</span>(it1);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//面积筛选与圆度筛选</span></span><br><span class="line">    <span class="comment">//这里面积的阈值如何确定？（可以用户输入）</span></span><br><span class="line">    area = <span class="built_in">contourArea</span>(*it1);</span><br><span class="line">    perimeter = <span class="built_in">arcLength</span>(*it1, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (area &lt;minArea || area&gt;maxArea)</span><br><span class="line">    &#123;</span><br><span class="line">        it1 = contours.<span class="built_in">erase</span>(it1);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">4</span> * <span class="number">3.1415926</span> * area / <span class="built_in">pow</span>(perimeter, <span class="number">2</span>) &lt; roundness)</span><br><span class="line">    &#123;</span><br><span class="line">        it1 = contours.<span class="built_in">erase</span>(it1);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Point temp = <span class="built_in">fitEllipse</span>(*it1).center;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sqrtf</span>(<span class="built_in">powf</span>((center.x - temp.x), <span class="number">2</span>) + <span class="built_in">powf</span>((center.y - temp.y), <span class="number">2</span>)) &lt; distance)</span><br><span class="line">    &#123;</span><br><span class="line">        it1 = contours.<span class="built_in">erase</span>(it1);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        center = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器后移</span></span><br><span class="line">    it1++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区域框选"><a href="#区域框选" class="headerlink" title="区域框选"></a>区域框选</h3><p>需要的主要函数是鼠标事件函数<code>setMouseCallback</code>。比较麻烦的就是鼠标事件获取坐标之后如何传递的问题，我现在还没有理清。<del>（我用的是全局变量，不得不说全局变量是真的丑）</del>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rect select;<span class="comment">//框选的矩形</span></span><br><span class="line"><span class="type">bool</span> select_flag = <span class="literal">false</span>;<span class="comment">//框选状态</span></span><br><span class="line">Point origin;<span class="comment">//框选的起点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标事件的回调函数，控制框选区域的是select(全局变量)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onMouse</span><span class="params">(<span class="type">int</span> event, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>, <span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (event == EVENT_LBUTTONDOWN)</span><br><span class="line">&#123;</span><br><span class="line">select_flag = <span class="literal">true</span>;<span class="comment">//左键按下赋真值</span></span><br><span class="line">origin = <span class="built_in">Point</span>(x, y);<span class="comment">//保存左键单击的坐标</span></span><br><span class="line">select = <span class="built_in">Rect</span>(x, y, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event == EVENT_LBUTTONUP)</span><br><span class="line">&#123;</span><br><span class="line">select_flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (select_flag)</span><br><span class="line">&#123;</span><br><span class="line">select.x = <span class="built_in">MIN</span>(origin.x, x);<span class="comment">//鼠标按下开始到弹起这段时间实时计算所选矩形框左上角点坐标</span></span><br><span class="line">select.y = <span class="built_in">MIN</span>(origin.y, y);</span><br><span class="line">select.width = <span class="built_in">abs</span>(x - origin.x);<span class="comment">//算矩形宽度和高度</span></span><br><span class="line">select.height = <span class="built_in">abs</span>(y - origin.y);</span><br><span class="line">select &amp;= <span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>, preImg.cols, preImg.rows);<span class="comment">//保证所选矩形框在图片区域之内</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码可以参考：<a href="https://www.cnblogs.com/tornadomeet/archive/2012/05/04/2483444.html">基础学习笔记之opencv(5)：实现鼠标选定矩形框 - tornadomeet - 博客园 (cnblogs.com)</a></p><h3 id="键盘操作"><a href="#键盘操作" class="headerlink" title="键盘操作"></a>键盘操作</h3><p>是很简单的输入流与<code>waitKey()</code>控制。输入输出流用于在控制台进行交互。<code>waitKey()</code>则读取按键信息。</p><p>奇怪的地方在于，<code>waitKey()</code>没办法识别<code>delete</code>、<code>shift</code>等等的按键，不知道是什么原因。</p><p>此外<code>waitKey()</code>有一个重要的功能就是让<code>imshow()</code>能显示出图像，特别是在与控制台交互输入点号信息的时候。如果不用<code>waitKey(30)</code>，窗口就会显示灰色而不是图像。</p>]]></content>
    
    
    <summary type="html">近景摄影测量编程记录与学习总结。</summary>
    
    
    
    <category term="编程作业" scheme="http://zerolacqua.top/categories/%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="摄影测量" scheme="http://zerolacqua.top/tags/%E6%91%84%E5%BD%B1%E6%B5%8B%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>坦克大战记录</title>
    <link href="http://zerolacqua.top/posts/8baa3f41.html"/>
    <id>http://zerolacqua.top/posts/8baa3f41.html</id>
    <published>2022-03-13T09:42:26.000Z</published>
    <updated>2022-05-03T16:49:23.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是大一时写的代码了，有时间了把它放上来，顺便看看自己现在写代码有没有长进。印象中大一写这个坦克大战时真的是被逼得死去活来的，难是真的难，不知道现在这门课还是不是这个坦克大战的作业了，如果要借鉴的话一定注意不要照搬啊！</p><blockquote><p>工程文件请见：<a href="/resources#工程代码">面向对象的程序设计</a></p></blockquote><hr><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>坦克大战程序实现了游戏中<strong>水池</strong>、<strong>石墙</strong>、<strong>草丛</strong>、<strong>铁墙</strong>的基本功能，还创新地添加了<strong>木箱</strong>。坦克、炮弹、方块之间可以进行<strong>碰撞检测</strong>。并且实现了游戏的<strong>结束判定</strong>。使用<code>WSAD</code>移动，<code>space</code>发射子弹，<code>K</code>自杀，<code>P</code>开启“作弊”（铁墙保护和生命增加等）</p><ul><li><p>生命值：被敌人击中生命会减少，并且回到重生点，生命值为0，游戏结束。</p></li><li><p>水池：子弹能通过，但坦克无法通过。</p></li><li><p>木箱：子弹不能通过，坦克无法通过，并且木箱在接触子弹或其它方块时被摧毁，可以是唯一可以被坦克推动的方块。</p></li><li><p>砖墙： 子弹不能通过，坦克无法通过，并且在接触子弹后被摧毁。</p></li><li><p>草丛：子弹、坦克均可通过，并且会被掩藏。</p></li><li><p>铁墙：任何物体都不可通过，无法摧毁。</p></li><li><p>基地：被子弹打中或被敌人入侵游戏即结束，友方坦克可以通过。</p></li></ul><h2 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h2><h3 id="object类"><a href="#object类" class="headerlink" title="object类"></a><code>object</code>类</h3><p><code>object</code>类是所有物体的基类。</p><p><strong>属性</strong></p><ul><li><code>m_rct</code>：位置</li><li><code>m_nDir</code>：方向</li><li><code>m_nSpeed</code>：速度</li><li><code>m_movable</code>：可否移动</li></ul><p><strong>函数</strong></p><ul><li>基本的碰撞的函数</li></ul><h3 id="Tank类"><a href="#Tank类" class="headerlink" title="Tank类"></a><code>Tank</code>类</h3><p><code>Tank</code>类继承自<code>object</code>类。</p><p><strong>属性</strong></p><ul><li><code>m_life</code>：生命</li></ul><p><strong>函数</strong></p><ul><li><p>虚函数</p><ul><li><code>show()</code></li><li><code>fire()</code></li></ul></li><li><p>普通函数</p><ul><li><code>life_decease()</code>：生命减少</li><li><code>TisOverlap()</code>：坦克碰撞函数</li><li><code>TOisOverlap()</code>：坦克碰撞函数</li></ul></li></ul><h3 id="MyTank类"><a href="#MyTank类" class="headerlink" title="MyTank类"></a><code>MyTank</code>类</h3><p><code>MyTank</code>类继承自<code>Tank</code>类。</p><p>属性</p><ul><li><code>m_move</code>：是否处于移动状态，是实现移动开炮同时进行的变量</li><li><code>m_respanpos</code>：重生点</li><li><code>m_img</code>：静态成员变量、存储贴图</li></ul><p>函数</p><ul><li><p>虚函数</p><ul><li><code>Show()</code>：重写虚函数</li></ul></li><li><p>普通函数</p><ul><li><code>respan()</code>：重生</li><li><code>gameover()</code>：游戏结束</li><li><code>show_life()</code>：生命显示</li><li><code>myMove()</code>：移动</li><li><code>setDir()</code>：转向</li></ul></li></ul><h3 id="EneTank类"><a href="#EneTank类" class="headerlink" title="EneTank类"></a><code>EneTank</code>类</h3><p><code>EneTank</code>类继承自<code>Tank</code>类。</p><p>属性</p><ul><li><code>ene_img</code>：静态成员变量，存储贴图</li><li><code>level</code>：静态成员变量，存储难度</li><li><p><code>total_num</code>：静态成员变量，存储消灭坦克数量</p></li><li><p><code>m_time</code>：记录开炮时间</p></li><li><code>m_firetime</code>：记录运动的时间</li><li><code>m_span</code>：开炮时间间隔</li><li><code>m_firespan</code>：开火时间间隔</li></ul><p>函数</p><ul><li><p>虚函数</p><ul><li><code>Show()</code>：重写虚函数</li></ul></li><li><p>普通函数</p><ul><li><code>AutoMove()</code>：自动移动</li><li><code>ChangeDir()</code>：自动转向</li><li><code>re_time()</code>：立即转向</li><li><code>fireClock()</code>：开炮计与重置时</li><li><code>eme_down()</code>：敌人死亡</li></ul></li></ul><h3 id="Shell类"><a href="#Shell类" class="headerlink" title="Shell类"></a><code>Shell</code>类</h3><p><code>Shell</code>类继承自<code>object</code>类。</p><p>属性</p><ul><li><code>m_inbox</code>：是否在界面内</li><li><code>m_time</code>：飞行时间</li><li><code>m_iniRct</code>：初始位置</li><li><code>s_img</code>：静态成员变量、存储贴图</li></ul><p>函数</p><ul><li>虚函数<code>Show()</code>：重写</li><li>其他函数<ul><li><code>create()</code>：创建</li><li><code>SSisOverlap()</code>：炮弹碰撞</li><li><code>UpdatePos()</code>：更新位置</li></ul></li></ul><h3 id="Wall类"><a href="#Wall类" class="headerlink" title="Wall类"></a><code>Wall</code>类</h3><p><code>Wall</code>类继承自<code>object</code>类。</p><p>属性</p><ul><li><code>type</code>：墙的类型<ul><li><code>ShellPass</code></li><li><code>TankPass</code></li></ul></li><li><code>destroyable</code>：是否可破坏</li><li><code>w_img</code>：静态成员变量、存储贴图</li></ul><p>函数</p><ul><li><p>虚函数</p><ul><li><code>Show()</code>：重写</li><li><code>Move()</code>：重写</li><li><code>disappear()</code></li></ul></li><li><p>其他函数</p></li></ul><h2 id="关键功能"><a href="#关键功能" class="headerlink" title="关键功能"></a>关键功能</h2><div class="note warning modern"><p>此部分内容待更新！</p></div><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><h3 id="屏幕绘制"><a href="#屏幕绘制" class="headerlink" title="屏幕绘制"></a>屏幕绘制</h3><h3 id="按键检测"><a href="#按键检测" class="headerlink" title="按键检测"></a>按键检测</h3><h3 id="随机行为"><a href="#随机行为" class="headerlink" title="随机行为"></a>随机行为</h3><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Fighting-h"><a href="#Fighting-h" class="headerlink" title="Fighting.h"></a><code>Fighting.h</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Fighting.h: PROJECT_NAME 应用程序的主头文件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __AFXWIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;在包含此文件之前包含 &#x27;pch.h&#x27; 以生成 PCH&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;resource.h&quot;</span><span class="comment">// 主符号</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CFightingApp:</span></span><br><span class="line"><span class="comment">// 有关此类的实现，请参阅 Fighting.cpp</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFightingApp</span> : <span class="keyword">public</span> CWinApp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CFightingApp</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> CFightingApp theApp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Fighting-cpp"><a href="#Fighting-cpp" class="headerlink" title="Fighting.cpp"></a><code>Fighting.cpp</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Fighting.cpp: 定义应用程序的类行为。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Fighting.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FightingDlg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CFightingApp</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CFightingApp, CWinApp)</span><br><span class="line"><span class="built_in">ON_COMMAND</span>(ID_HELP, &amp;CWinApp::OnHelp)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CFightingApp 构造</span></span><br><span class="line"></span><br><span class="line">CFightingApp::<span class="built_in">CFightingApp</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 支持重新启动管理器</span></span><br><span class="line">m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处添加构造代码，</span></span><br><span class="line"><span class="comment">// 将所有重要的初始化放置在 InitInstance 中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 唯一的 CFightingApp 对象</span></span><br><span class="line"></span><br><span class="line">CFightingApp theApp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CFightingApp 初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CFightingApp::InitInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果一个运行在 Windows XP 上的应用程序清单指定要</span></span><br><span class="line"><span class="comment">// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，</span></span><br><span class="line"><span class="comment">//则需要 InitCommonControlsEx()。  否则，将无法创建窗口。</span></span><br><span class="line">INITCOMMONCONTROLSEX InitCtrls;</span><br><span class="line">InitCtrls.dwSize = <span class="built_in">sizeof</span>(InitCtrls);</span><br><span class="line"><span class="comment">// 将它设置为包括所有要在应用程序中使用的</span></span><br><span class="line"><span class="comment">// 公共控件类。</span></span><br><span class="line">InitCtrls.dwICC = ICC_WIN95_CLASSES;</span><br><span class="line"><span class="built_in">InitCommonControlsEx</span>(&amp;InitCtrls);</span><br><span class="line"></span><br><span class="line">CWinApp::<span class="built_in">InitInstance</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">AfxEnableControlContainer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 shell 管理器，以防对话框包含</span></span><br><span class="line"><span class="comment">// 任何 shell 树视图控件或 shell 列表视图控件。</span></span><br><span class="line">CShellManager *pShellManager = <span class="keyword">new</span> CShellManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题</span></span><br><span class="line">CMFCVisualManager::<span class="built_in">SetDefaultManager</span>(<span class="built_in">RUNTIME_CLASS</span>(CMFCVisualManagerWindows));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准初始化</span></span><br><span class="line"><span class="comment">// 如果未使用这些功能并希望减小</span></span><br><span class="line"><span class="comment">// 最终可执行文件的大小，则应移除下列</span></span><br><span class="line"><span class="comment">// 不需要的特定初始化例程</span></span><br><span class="line"><span class="comment">// 更改用于存储设置的注册表项</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 应适当修改该字符串，</span></span><br><span class="line"><span class="comment">// 例如修改为公司或组织名</span></span><br><span class="line"><span class="built_in">SetRegistryKey</span>(_T(<span class="string">&quot;应用程序向导生成的本地应用程序&quot;</span>));</span><br><span class="line"></span><br><span class="line">CFightingDlg dlg;</span><br><span class="line">m_pMainWnd = &amp;dlg;</span><br><span class="line">INT_PTR nResponse = dlg.<span class="built_in">DoModal</span>();</span><br><span class="line"><span class="keyword">if</span> (nResponse == IDOK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此放置处理何时用</span></span><br><span class="line"><span class="comment">//  “确定”来关闭对话框的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nResponse == IDCANCEL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此放置处理何时用</span></span><br><span class="line"><span class="comment">//  “取消”来关闭对话框的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nResponse == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(traceAppMsg, <span class="number">0</span>, <span class="string">&quot;警告: 对话框创建失败，应用程序将意外终止。\n&quot;</span>);</span><br><span class="line"><span class="built_in">TRACE</span>(traceAppMsg, <span class="number">0</span>, <span class="string">&quot;警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除上面创建的 shell 管理器。</span></span><br><span class="line"><span class="keyword">if</span> (pShellManager != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> pShellManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(_AFXDLL) &amp;&amp; !defined(_AFX_NO_MFC_CONTROLS_IN_DIALOGS)</span></span><br><span class="line"><span class="built_in">ControlBarCleanUp</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，</span></span><br><span class="line"><span class="comment">//  而不是启动应用程序的消息泵。</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="FightingDlg-h"><a href="#FightingDlg-h" class="headerlink" title="FightingDlg.h"></a><code>FightingDlg.h</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// FightingDlg.h: 头文件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shell.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EneTank.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyTank.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CFightingDlg 对话框</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CFightingDlg</span> : <span class="keyword">public</span> CDialogEx</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CFightingDlg</span>(CWnd* pParent = <span class="literal">nullptr</span>);<span class="comment">// 标准构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AFX_DESIGN_TIME</span></span><br><span class="line"><span class="keyword">enum</span> &#123; IDD = IDD_FIGHTING_DIALOG &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>;<span class="comment">// DDX/DDV 支持</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> work;</span><br><span class="line"><span class="type">static</span> MyTank myTank;</span><br><span class="line"><span class="type">static</span> vector&lt;EneTank&gt;eneTank;</span><br><span class="line"><span class="type">static</span> vector&lt;Shell&gt;myvecShell;</span><br><span class="line"><span class="type">static</span> vector&lt;Shell&gt;enevecShell;</span><br><span class="line"><span class="type">static</span> vector&lt;wall&gt;vecWall;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> mutex mut;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Collide1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Collide2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//static void threadTT();</span></span><br><span class="line"><span class="comment">//static void threadSS();</span></span><br><span class="line"><span class="comment">//static void threadTS();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">HICON m_hIcon;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的消息映射函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">OnInitDialog</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">OnSysCommand</span><span class="params">(UINT nID, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">OnPaint</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">afx_msg HCURSOR <span class="title">OnQueryDragIcon</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">OnTimer</span><span class="params">(UINT_PTR nIDEvent)</span></span>;</span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">OnKeyDown</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span></span>;</span><br><span class="line"><span class="comment">//afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);</span></span><br><span class="line"><span class="function">afx_msg BOOL <span class="title">OnEraseBkgnd</span><span class="params">(CDC* pDC)</span></span>;</span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">OnDestroy</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> BOOL <span class="title">PreTranslateMessage</span><span class="params">(MSG* pMsg)</span></span>;</span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">OnKeyUp</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="FightingDlg-cpp"><a href="#FightingDlg-cpp" class="headerlink" title="FightingDlg.cpp"></a><code>FightingDlg.cpp</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// FightingDlg.cpp: 实现文件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Fighting.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FightingDlg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;afxdialogex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shell.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> new DEBUG_NEW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">CPoint EneTank::birth[<span class="number">3</span>] = &#123; <span class="built_in">CPoint</span>(<span class="number">100</span>,<span class="number">100</span>),<span class="built_in">CPoint</span>(<span class="number">300</span>,<span class="number">100</span>),<span class="built_in">CPoint</span>(<span class="number">500</span>,<span class="number">100</span>) &#125;;</span><br><span class="line"></span><br><span class="line">MyTank CFightingDlg::myTank;</span><br><span class="line">vector&lt;EneTank&gt; CFightingDlg::eneTank;</span><br><span class="line">vector&lt;Shell&gt; CFightingDlg::myvecShell;</span><br><span class="line">vector&lt;Shell&gt; CFightingDlg::enevecShell;</span><br><span class="line">vector&lt;wall&gt; CFightingDlg::vecWall;</span><br><span class="line">CString str;</span><br><span class="line"><span class="type">int</span> shell_num ;</span><br><span class="line"><span class="type">bool</span> CFightingDlg::work = <span class="literal">true</span>;</span><br><span class="line">mutex CFightingDlg::mut;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFightingDlg::Collide1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">CRect tank;</span><br><span class="line"><span class="keyword">while</span> (work)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mut.<span class="built_in">try_lock</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//////炮弹碰撞//////</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; myvecShell.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//我方炮弹出界</span></span><br><span class="line"><span class="keyword">if</span> (!myvecShell[i].m_inbox)</span><br><span class="line">&#123;</span><br><span class="line">myvecShell.<span class="built_in">erase</span>(myvecShell.<span class="built_in">begin</span>() + i);</span><br><span class="line">i--;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//敌我炮弹碰撞</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; enevecShell.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (myvecShell[i].<span class="built_in">SSisOverlap</span>(enevecShell[j]))</span><br><span class="line">&#123;</span><br><span class="line">myvecShell.<span class="built_in">erase</span>(myvecShell.<span class="built_in">begin</span>() + i);</span><br><span class="line">enevecShell.<span class="built_in">erase</span>(enevecShell.<span class="built_in">begin</span>() + j);</span><br><span class="line">i--;</span><br><span class="line">j--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//敌方炮弹出界</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;enevecShell.<span class="built_in">size</span>();i++)</span><br><span class="line"><span class="keyword">if</span> (!enevecShell[i].m_inbox)</span><br><span class="line">&#123;</span><br><span class="line">enevecShell.<span class="built_in">erase</span>(enevecShell.<span class="built_in">begin</span>() + i);</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////敌方坦克与我方炮弹//////</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; eneTank.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">tank = eneTank[i].<span class="built_in">GetPos</span>();</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; myvecShell.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (myvecShell[j].<span class="built_in">IsOverLap</span>(tank))</span><br><span class="line">&#123;</span><br><span class="line">myvecShell.<span class="built_in">erase</span>(myvecShell.<span class="built_in">begin</span>() + j);</span><br><span class="line">eneTank.<span class="built_in">erase</span>(eneTank.<span class="built_in">begin</span>() + i);</span><br><span class="line">EneTank::<span class="built_in">eme_down</span>();</span><br><span class="line">i--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//玩家坦克与敌方炮弹</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; enevecShell.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">tank = myTank.<span class="built_in">GetPos</span>();</span><br><span class="line"><span class="keyword">if</span> (enevecShell[i].<span class="built_in">IsOverLap</span>(tank))</span><br><span class="line">&#123;</span><br><span class="line">myTank.<span class="built_in">lifedecrease</span>();</span><br><span class="line">myTank.<span class="built_in">respan</span>();</span><br><span class="line">enevecShell.<span class="built_in">erase</span>(enevecShell.<span class="built_in">begin</span>() + i);</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////坦克碰撞//////</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; eneTank.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (myTank.<span class="built_in">TOisOverlap</span>(eneTank[i]))</span><br><span class="line">&#123;</span><br><span class="line">eneTank[i].<span class="built_in">re_time</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">myTank.<span class="built_in">IsOut</span>();</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; eneTank.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; eneTank.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i != j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (eneTank[i].<span class="built_in">TOisOverlap</span>(eneTank[j]))</span><br><span class="line">&#123;</span><br><span class="line">eneTank[i].<span class="built_in">re_time</span>();</span><br><span class="line">eneTank[j].<span class="built_in">re_time</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (eneTank[i].<span class="built_in">TOisOverlap</span>(myTank) || eneTank[i].<span class="built_in">IsOut</span>())</span><br><span class="line">&#123;</span><br><span class="line">eneTank[i].<span class="built_in">re_time</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mut.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFightingDlg::Collide2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> check = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (work)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mut.<span class="built_in">try_lock</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//炮弹与墙</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; myvecShell.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>, check = <span class="literal">false</span>; j &lt; vecWall.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].<span class="built_in">IsOverLap</span>(myvecShell[i].<span class="built_in">GetPos</span>()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].type == BASE)</span><br><span class="line">&#123;</span><br><span class="line">myTank.<span class="built_in">gameover</span>();</span><br><span class="line">work = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].ShellPass)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">check = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].destroyable)</span><br><span class="line">&#123;</span><br><span class="line">vecWall.<span class="built_in">erase</span>(vecWall.<span class="built_in">begin</span>() + j);</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check)</span><br><span class="line">&#123;</span><br><span class="line">myvecShell.<span class="built_in">erase</span>(myvecShell.<span class="built_in">begin</span>() + i);</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; enevecShell.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>, check = <span class="literal">false</span>; j &lt; vecWall.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].<span class="built_in">IsOverLap</span>(enevecShell[i].<span class="built_in">GetPos</span>()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].type == BASE)</span><br><span class="line">&#123;</span><br><span class="line">myTank.<span class="built_in">gameover</span>();</span><br><span class="line">work = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vecWall[j].ShellPass)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">check = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].destroyable)</span><br><span class="line">&#123;</span><br><span class="line">vecWall.<span class="built_in">erase</span>(vecWall.<span class="built_in">begin</span>() + j);</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check)</span><br><span class="line">&#123;</span><br><span class="line">enevecShell.<span class="built_in">erase</span>(enevecShell.<span class="built_in">begin</span>() + i);</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//坦克与墙</span></span><br><span class="line"><span class="comment">//敌方</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; eneTank.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vecWall.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].type == BASE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].<span class="built_in">IsOverLap</span>(eneTank[i].<span class="built_in">GetPos</span>()))</span><br><span class="line">&#123;</span><br><span class="line">myTank.<span class="built_in">gameover</span>();</span><br><span class="line">work = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].type!=GRASS&amp;&amp;eneTank[i].<span class="built_in">TOisOverlap</span>(vecWall[j]))</span><br><span class="line">&#123;</span><br><span class="line">eneTank[i].<span class="built_in">re_time</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//玩家</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vecWall.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!vecWall[j].TankPass)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (myTank.<span class="built_in">TOisOverlap</span>(vecWall[j]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//墙与墙</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; vecWall.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vecWall.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].m_movable &amp;&amp; j != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vecWall[j].<span class="built_in">IsOverLap</span>(vecWall[i].<span class="built_in">GetPos</span>())&amp;&amp; vecWall[i].type!=GRASS)</span><br><span class="line">&#123;</span><br><span class="line">vecWall.<span class="built_in">erase</span>(vecWall.<span class="built_in">begin</span>() + j);</span><br><span class="line">j--;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">vecWall[j].<span class="built_in">IsOut</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mut.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于应用程序“关于”菜单项的 CAboutDlg 对话框</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAboutDlg</span> : <span class="keyword">public</span> CDialogEx</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CAboutDlg</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AFX_DESIGN_TIME</span></span><br><span class="line"><span class="keyword">enum</span> &#123; IDD = IDD_ABOUTBOX &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>;    <span class="comment">// DDX/DDV 支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CAboutDlg::<span class="built_in">CAboutDlg</span>() : <span class="built_in">CDialogEx</span>(IDD_ABOUTBOX)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CAboutDlg::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CAboutDlg, CDialogEx)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CFightingDlg 对话框</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CFightingDlg::<span class="built_in">CFightingDlg</span>(CWnd* pParent <span class="comment">/*=nullptr*/</span>)</span><br><span class="line">: <span class="built_in">CDialogEx</span>(IDD_FIGHTING_DIALOG, pParent)</span><br><span class="line">&#123;</span><br><span class="line">m_hIcon = <span class="built_in">AfxGetApp</span>()-&gt;<span class="built_in">LoadIcon</span>(IDR_MAINFRAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFightingDlg::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CFightingDlg, CDialogEx)</span><br><span class="line"><span class="built_in">ON_WM_SYSCOMMAND</span>()</span><br><span class="line"><span class="built_in">ON_WM_PAINT</span>()</span><br><span class="line"><span class="built_in">ON_WM_QUERYDRAGICON</span>()</span><br><span class="line"><span class="built_in">ON_WM_TIMER</span>()</span><br><span class="line"><span class="built_in">ON_WM_KEYDOWN</span>()</span><br><span class="line"><span class="comment">//ON_WM_KEYUP()</span></span><br><span class="line"><span class="comment">//ON_WM_ERASEBKGND()</span></span><br><span class="line"><span class="built_in">ON_WM_ERASEBKGND</span>()</span><br><span class="line"><span class="built_in">ON_WM_DESTROY</span>()</span><br><span class="line"><span class="built_in">ON_WM_KEYUP</span>()</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CFightingDlg 消息处理程序</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CFightingDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将“关于...”菜单项添加到系统菜单中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IDM_ABOUTBOX 必须在系统命令范围内。</span></span><br><span class="line"><span class="built_in">ASSERT</span>((IDM_ABOUTBOX &amp; <span class="number">0xFFF0</span>) == IDM_ABOUTBOX);</span><br><span class="line"><span class="built_in">ASSERT</span>(IDM_ABOUTBOX &lt; <span class="number">0xF000</span>);</span><br><span class="line"></span><br><span class="line">CMenu* pSysMenu = <span class="built_in">GetSystemMenu</span>(FALSE);</span><br><span class="line"><span class="keyword">if</span> (pSysMenu != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">BOOL bNameValid;</span><br><span class="line">CString strAboutMenu;</span><br><span class="line">bNameValid = strAboutMenu.<span class="built_in">LoadString</span>(IDS_ABOUTBOX);</span><br><span class="line"><span class="built_in">ASSERT</span>(bNameValid);</span><br><span class="line"><span class="keyword">if</span> (!strAboutMenu.<span class="built_in">IsEmpty</span>())</span><br><span class="line">&#123;</span><br><span class="line">pSysMenu-&gt;<span class="built_in">AppendMenu</span>(MF_SEPARATOR);</span><br><span class="line">pSysMenu-&gt;<span class="built_in">AppendMenu</span>(MF_STRING, IDM_ABOUTBOX, strAboutMenu);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动</span></span><br><span class="line"><span class="comment">//  执行此操作</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, TRUE);<span class="comment">// 设置大图标</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, FALSE);<span class="comment">// 设置小图标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">SetTimer</span>(<span class="number">1</span>, <span class="number">40</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">SetTimer</span>(<span class="number">2</span>, <span class="number">20000</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">SetTimer</span>(<span class="number">3</span>, <span class="number">20</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>) * <span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">shell_num = <span class="number">2</span>;<span class="comment">//坦克可发射炮弹数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////贴图导入////////</span></span><br><span class="line">CString strFileName;</span><br><span class="line">TCHAR cPath[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, cPath, <span class="number">1024</span>);</span><br><span class="line">strFileName = cPath;</span><br><span class="line">CString str;</span><br><span class="line"><span class="comment">//对炮弹的静态成员变量赋值</span></span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\shell.png&quot;</span>;</span><br><span class="line">Shell::s_img.<span class="built_in">Load</span>(str);</span><br><span class="line"><span class="comment">//对敌方坦克的静态成员变量赋值</span></span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\eneTank0.png&quot;</span>;</span><br><span class="line">EneTank::ene_img[<span class="number">0</span>].<span class="built_in">Load</span>(str);</span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\eneTank1.png&quot;</span>;</span><br><span class="line">EneTank::ene_img[<span class="number">1</span>].<span class="built_in">Load</span>(str);</span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\eneTank2.png&quot;</span>;</span><br><span class="line">EneTank::ene_img[<span class="number">2</span>].<span class="built_in">Load</span>(str);</span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\eneTank3.png&quot;</span>;</span><br><span class="line">EneTank::ene_img[<span class="number">3</span>].<span class="built_in">Load</span>(str);</span><br><span class="line"><span class="comment">//墙</span></span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\0.png&quot;</span>;</span><br><span class="line">wall::w_img[BRICK].<span class="built_in">Load</span>(str);</span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\1.png&quot;</span>;</span><br><span class="line">wall::w_img[METAL].<span class="built_in">Load</span>(str);</span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\2.png&quot;</span>;</span><br><span class="line">wall::w_img[GRASS].<span class="built_in">Load</span>(str);</span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\3.png&quot;</span>;</span><br><span class="line">wall::w_img[WATER].<span class="built_in">Load</span>(str);</span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\4.png&quot;</span>;</span><br><span class="line">wall::w_img[WOOD].<span class="built_in">Load</span>(str);</span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\5.png&quot;</span>;</span><br><span class="line">wall::w_img[BASE].<span class="built_in">Load</span>(str);</span><br><span class="line"><span class="comment">//对坦克的静态成员变量赋值</span></span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\mytank0.png&quot;</span>;</span><br><span class="line">MyTank::m_img[<span class="number">0</span>].<span class="built_in">Load</span>(str);</span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\mytank1.png&quot;</span>;</span><br><span class="line">MyTank::m_img[<span class="number">1</span>].<span class="built_in">Load</span>(str);</span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\mytank2.png&quot;</span>;</span><br><span class="line">MyTank::m_img[<span class="number">2</span>].<span class="built_in">Load</span>(str);</span><br><span class="line">str = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;material\\mytank3.png&quot;</span>;</span><br><span class="line">MyTank::m_img[<span class="number">3</span>].<span class="built_in">Load</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////线程/////////////</span></span><br><span class="line"><span class="function">thread <span class="title">T</span><span class="params">(Collide1)</span></span>;</span><br><span class="line">T.<span class="built_in">detach</span>();</span><br><span class="line"><span class="function">thread <span class="title">W</span><span class="params">(Collide2)</span></span>;</span><br><span class="line">W.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////地图载入///////////</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; Y_MAX / <span class="number">100</span>; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; X_MAX / <span class="number">50</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((i+j)%<span class="number">4</span>)</span><br><span class="line">vecWall.<span class="built_in">push_back</span>(<span class="built_in">wall</span>(<span class="built_in">CPoint</span>(i * <span class="number">50</span>, j * <span class="number">100</span>), (i + j)% <span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line">vecWall.<span class="built_in">push_back</span>(<span class="built_in">wall</span>(<span class="built_in">CPoint</span>(<span class="number">250</span>, <span class="number">450</span>),BASE));</span><br><span class="line">vecWall.<span class="built_in">push_back</span>(<span class="built_in">wall</span>(<span class="built_in">CPoint</span>(<span class="number">200</span>, <span class="number">400</span>), BRICK));</span><br><span class="line">vecWall.<span class="built_in">push_back</span>(<span class="built_in">wall</span>(<span class="built_in">CPoint</span>(<span class="number">200</span>, <span class="number">450</span>), WOOD));</span><br><span class="line">vecWall.<span class="built_in">push_back</span>(<span class="built_in">wall</span>(<span class="built_in">CPoint</span>(<span class="number">300</span>, <span class="number">450</span>), WOOD));</span><br><span class="line"><span class="comment">///////////敌方坦克初始化///////////</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">EneTank <span class="title">eme</span><span class="params">(i)</span></span>;</span><br><span class="line">eneTank.<span class="built_in">push_back</span>(eme);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他</span></span><br><span class="line"><span class="built_in">SetWindowPos</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, X_MAX + <span class="number">200</span>, Y_MAX + <span class="number">40</span>+<span class="number">10</span>, SWP_NOMOVE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFightingDlg::OnSysCommand</span><span class="params">(UINT nID, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((nID &amp; <span class="number">0xFFF0</span>) == IDM_ABOUTBOX)</span><br><span class="line">&#123;</span><br><span class="line">CAboutDlg dlgAbout;</span><br><span class="line">dlgAbout.<span class="built_in">DoModal</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::<span class="built_in">OnSysCommand</span>(nID, lParam);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果向对话框添加最小化按钮，则需要下面的代码</span></span><br><span class="line"><span class="comment">//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，</span></span><br><span class="line"><span class="comment">//  这将由框架自动完成。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFightingDlg::OnPaint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsIconic</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">CPaintDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>; <span class="comment">// 用于绘制的设备上下文</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SendMessage</span>(WM_ICONERASEBKGND, <span class="built_in">reinterpret_cast</span>&lt;WPARAM&gt;(dc.<span class="built_in">GetSafeHdc</span>()), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使图标在工作区矩形中居中</span></span><br><span class="line"><span class="type">int</span> cxIcon = <span class="built_in">GetSystemMetrics</span>(SM_CXICON);</span><br><span class="line"><span class="type">int</span> cyIcon = <span class="built_in">GetSystemMetrics</span>(SM_CYICON);</span><br><span class="line">CRect rect;</span><br><span class="line"><span class="built_in">GetClientRect</span>(&amp;rect);</span><br><span class="line"><span class="type">int</span> x = (rect.<span class="built_in">Width</span>() - cxIcon + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> y = (rect.<span class="built_in">Height</span>() - cyIcon + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制图标</span></span><br><span class="line">dc.<span class="built_in">DrawIcon</span>(x, y, m_hIcon);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">CDialogEx::<span class="built_in">OnPaint</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//CMemDC memDC(*GetDC(), this);</span></span><br><span class="line"><span class="comment">//CDC* pDC = &amp;memDC.GetDC();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CRect   rc;</span><br><span class="line"><span class="comment">//CWnd* pWnd = GetDlgItem(IDC_IMAGE_BOX);</span></span><br><span class="line"><span class="comment">//pWnd-&gt;GetClientRect();</span></span><br><span class="line"><span class="built_in">GetClientRect</span>(&amp;rc);<span class="comment">// 获取客户区  </span></span><br><span class="line"></span><br><span class="line">CDC* pDC = <span class="built_in">GetDC</span>();<span class="comment">//这里通过在CmemDC中绘制，以解决闪烁问题</span></span><br><span class="line"><span class="function">CMemDC <span class="title">dcMem</span><span class="params">(*pDC, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">CDC&amp; dc = dcMem.<span class="built_in">GetDC</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//////敌方坦克//////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myTank.m_life &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (eneTank.<span class="built_in">size</span>() &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">EneTank eme;</span><br><span class="line">eneTank.<span class="built_in">push_back</span>(eme);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; eneTank.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">eneTank[i].<span class="built_in">AutoMove</span>();</span><br><span class="line"><span class="keyword">if</span> (eneTank[i].<span class="built_in">fireClock</span>())</span><br><span class="line">enevecShell.<span class="built_in">push_back</span>(eneTank[i].<span class="built_in">fire</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////绘制部分/////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////绘制背景//////</span></span><br><span class="line">dc.<span class="built_in">FillSolidRect</span>(&amp;Range, <span class="built_in">RGB</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vecWall.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="keyword">if</span> (vecWall[i].type == WATER</span><br><span class="line">|| vecWall[i].type == BASE</span><br><span class="line">|| vecWall[i].type == WOOD)</span><br><span class="line">&#123;</span><br><span class="line">vecWall[i].<span class="built_in">Show</span>(&amp;dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////炮弹//////</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; myvecShell.<span class="built_in">size</span>(); i++)</span><br><span class="line">myvecShell[i].<span class="built_in">Show</span>(&amp;dc);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; enevecShell.<span class="built_in">size</span>(); i++)</span><br><span class="line">enevecShell[i].<span class="built_in">Show</span>(&amp;dc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////敌方坦克//////</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; eneTank.<span class="built_in">size</span>(); i++)</span><br><span class="line">eneTank[i].<span class="built_in">Show</span>(&amp;dc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////玩家坦克//////</span></span><br><span class="line">myTank.<span class="built_in">Show</span>(&amp;dc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; vecWall.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vecWall[i].type != WATER </span><br><span class="line">&amp;&amp; vecWall[i].type != BASE</span><br><span class="line">&amp;&amp; vecWall[i].type!=WOOD)</span><br><span class="line">&#123;</span><br><span class="line">vecWall[i].<span class="built_in">Show</span>(&amp;dc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生命显示</span></span><br><span class="line"><span class="function">CRect <span class="title">rct</span><span class="params">(CPoint(<span class="number">620</span>, <span class="number">0</span>), CPoint(<span class="number">620</span> + <span class="number">30</span>, <span class="number">0</span> + <span class="number">30</span>))</span></span>;</span><br><span class="line">myTank.<span class="built_in">show_life</span>(&amp;dc,rct);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">work = <span class="literal">false</span>;</span><br><span class="line">str.<span class="built_in">Format</span>(<span class="string">L&quot;游戏结束!您消灭了%d个敌人&quot;</span>, EneTank::total_num);</span><br><span class="line">dc.<span class="built_in">TextOut</span>(<span class="number">250</span>, <span class="number">270</span>,str);</span><br><span class="line">eneTank.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当用户拖动最小化窗口时系统调用此函数取得光标</span></span><br><span class="line"><span class="comment">//显示。</span></span><br><span class="line"><span class="function">HCURSOR <span class="title">CFightingDlg::OnQueryDragIcon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;HCURSOR&gt;(m_hIcon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFightingDlg::OnTimer</span><span class="params">(UINT_PTR nIDEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="keyword">switch</span> (nIDEvent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">InvalidateRect</span>(Range, <span class="literal">true</span>); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span>(EneTank::level&lt;<span class="number">9</span>)</span><br><span class="line">EneTank::level++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">myTank.<span class="built_in">myMove</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CDialogEx::<span class="built_in">OnTimer</span>(nIDEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFightingDlg::OnKeyDown</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> used = <span class="literal">false</span>;</span><br><span class="line">CRect rct;</span><br><span class="line">CPoint pt;</span><br><span class="line"><span class="keyword">if</span> (myTank.m_life == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">switch</span> (nChar)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">myTank.<span class="built_in">setDir</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">myTank.<span class="built_in">setDir</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">myTank.<span class="built_in">setDir</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">myTank.<span class="built_in">setDir</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (myTank.m_life &lt; <span class="number">30</span>)</span><br><span class="line">&#123;</span><br><span class="line">myTank.m_life += <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!used)</span><br><span class="line">&#123;</span><br><span class="line">vecWall.<span class="built_in">push_back</span>(<span class="built_in">wall</span>(<span class="built_in">CPoint</span>(<span class="number">200</span>, <span class="number">400</span>), METAL));</span><br><span class="line">vecWall.<span class="built_in">push_back</span>(<span class="built_in">wall</span>(<span class="built_in">CPoint</span>(<span class="number">250</span>, <span class="number">400</span>), METAL));</span><br><span class="line">vecWall.<span class="built_in">push_back</span>(<span class="built_in">wall</span>(<span class="built_in">CPoint</span>(<span class="number">300</span>, <span class="number">400</span>), METAL));</span><br><span class="line">vecWall.<span class="built_in">push_back</span>(<span class="built_in">wall</span>(<span class="built_in">CPoint</span>(<span class="number">200</span>, <span class="number">450</span>), METAL));</span><br><span class="line">vecWall.<span class="built_in">push_back</span>(<span class="built_in">wall</span>(<span class="built_in">CPoint</span>(<span class="number">300</span>, <span class="number">450</span>), METAL));</span><br><span class="line">shell_num = <span class="number">1000</span>;</span><br><span class="line">myTank.<span class="built_in">setSpeed</span>(<span class="number">10</span>);</span><br><span class="line">used = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line">myTank.<span class="built_in">gameover</span>();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> VK_SPACE:</span><br><span class="line"><span class="keyword">if</span> (myvecShell.<span class="built_in">size</span>() &lt; shell_num)</span><br><span class="line">&#123;</span><br><span class="line">myvecShell.<span class="built_in">push_back</span>(myTank.<span class="built_in">Fire</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CDialogEx::<span class="built_in">OnKeyDown</span>(nChar, nRepCnt, nFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CFightingDlg::OnEraseBkgnd</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFightingDlg::OnDestroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">OnDestroy</span>();</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处添加消息处理程序代码</span></span><br><span class="line">work = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CFightingDlg::PreTranslateMessage</span><span class="params">(MSG* pMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CDialogEx::<span class="built_in">PreTranslateMessage</span>(pMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFightingDlg::OnKeyUp</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myTank.m_life == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">switch</span> (nChar)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">myTank.<span class="built_in">setDir</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">CDialogEx::<span class="built_in">OnKeyUp</span>(nChar, nRepCnt, nFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="EneTank-h"><a href="#EneTank-h" class="headerlink" title="EneTank.h"></a><code>EneTank.h</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Tank.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EneTank</span> :<span class="keyword">public</span> Tank</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">EneTank</span>();</span><br><span class="line"><span class="built_in">EneTank</span>(<span class="type">int</span> pos);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(CDC* pDC)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AutoMove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EneTank::ChangeDir</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">re_time</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fireClock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">eme_down</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">DWORD m_time;</span><br><span class="line">DWORD m_firetime;</span><br><span class="line"><span class="type">double</span> m_span;</span><br><span class="line"><span class="type">int</span> m_firespan;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消灭坦克的数量,是静态成员变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> total_num;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> level;</span><br><span class="line"><span class="comment">//贴图</span></span><br><span class="line"><span class="type">static</span> CImage ene_img[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">//固定的出生点,静态成员变量</span></span><br><span class="line"><span class="type">static</span> CPoint birth[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Object-h"><a href="#Object-h" class="headerlink" title="Object.h"></a><code>Object.h</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CORRECT 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//单位格子的大小</span></span><br><span class="line"><span class="comment">//const CSize unitSize(50, 50);</span></span><br><span class="line"><span class="comment">/*这一块地方很有问题，</span></span><br><span class="line"><span class="comment">不知道为什么mytank接收不到unitsize</span></span><br><span class="line"><span class="comment">可能是因为构造的时候，unitSize还未初始化*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方向对应的数字</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DIR_UP = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DIR_DOWN = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DIR_LEFT = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DIR_RIGHT = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//单元格子的大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">50</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Tank_size = <span class="number">45</span>;</span><br><span class="line"><span class="comment">//范围</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> X_MAX = <span class="number">600</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Y_MAX = <span class="number">500</span>;</span><br><span class="line"><span class="comment">//+20是为了防止出界判断的延迟出现图片残留</span></span><br><span class="line"><span class="comment">//具体解决还可以尝试加快判断速度</span></span><br><span class="line"><span class="function"><span class="type">const</span> CRect <span class="title">Range</span><span class="params">(CPoint(<span class="number">0</span>, <span class="number">0</span>), CPoint(X_MAX + <span class="number">200</span>, Y_MAX + <span class="number">40</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">(CDC* pDC)</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> Dir)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetPos</span><span class="params">(CRect rct)</span> </span>&#123; m_rct = rct; m_rct.<span class="built_in">NormalizeRect</span>(); &#125;;</span><br><span class="line"><span class="function">CRect <span class="title">GetPos</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_rct; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSpeed</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">this</span>-&gt;m_nSpeed = n;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> m_movable = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsOverLap</span><span class="params">(CRect&amp; rct)</span></span>;<span class="comment">//重叠、碰撞测试基础</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsOut</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">CRect m_rct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_nDir;<span class="comment">//0-3:up\down\left\right</span></span><br><span class="line"><span class="type">int</span> m_nSpeed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Object-cpp"><a href="#Object-cpp" class="headerlink" title="Object.cpp"></a><code>Object.cpp</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Object.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Object::Move</span><span class="params">(<span class="type">int</span> Dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//这里移动是将来的移动，能否实现，要通过碰撞测试</span></span><br><span class="line">m_nDir = Dir;</span><br><span class="line"><span class="keyword">if</span> (Dir == DIR_UP)</span><br><span class="line">&#123;</span><br><span class="line">m_rct.<span class="built_in">MoveToY</span>(m_rct.top - m_nSpeed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Dir == DIR_DOWN)</span><br><span class="line">&#123;</span><br><span class="line">m_rct.<span class="built_in">MoveToY</span>(m_rct.top + m_nSpeed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Dir == DIR_LEFT)</span><br><span class="line">&#123;</span><br><span class="line">m_rct.<span class="built_in">MoveToX</span>(m_rct.left - m_nSpeed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Dir == DIR_RIGHT)</span><br><span class="line">&#123;</span><br><span class="line">m_rct.<span class="built_in">MoveToX</span>(m_rct.left + m_nSpeed);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Object::IsOverLap</span><span class="params">(CRect&amp; rct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CRect tmp;</span><br><span class="line">rct.<span class="built_in">NormalizeRect</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">IntersectRect</span>(tmp, rct, m_rct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Object::IsOut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_rct.bottom &gt; Y_MAX || m_rct.top&lt;<span class="number">0</span></span><br><span class="line">|| m_rct.right&gt;X_MAX || m_rct.left &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_rct.bottom &gt; Y_MAX)</span><br><span class="line">m_rct.<span class="built_in">OffsetRect</span>(<span class="number">0</span>, -(m_rct.bottom - Y_MAX + CORRECT));</span><br><span class="line"><span class="keyword">if</span> (m_rct.top &lt; <span class="number">0</span>)</span><br><span class="line">m_rct.<span class="built_in">OffsetRect</span>(<span class="number">0</span>, -m_rct.top + CORRECT);</span><br><span class="line"><span class="keyword">if</span> (m_rct.right &gt; X_MAX)</span><br><span class="line">m_rct.<span class="built_in">OffsetRect</span>(-(m_rct.right - X_MAX + CORRECT), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (m_rct.left &lt; <span class="number">0</span>)</span><br><span class="line">m_rct.<span class="built_in">OffsetRect</span>(-m_rct.left + CORRECT, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tank-h"><a href="#Tank-h" class="headerlink" title="Tank.h"></a><code>Tank.h</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Object.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shell.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank</span>:<span class="keyword">public</span> Object</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里只定义了Show方法，fire方法在子类中定义</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Tank</span>();</span><br><span class="line"><span class="type">int</span> m_life;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">(CDC* pDC)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Shell <span class="title">fire</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//生命-1</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">lifedecrease</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_life--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TisOverlap</span><span class="params">(CRect rct)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TOisOverlap</span><span class="params">(Object&amp; ob)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Tank-cpp"><a href="#Tank-cpp" class="headerlink" title="Tank.cpp"></a><code>Tank.cpp</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Tank.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Tank::<span class="built_in">Tank</span>() </span><br><span class="line">&#123;</span><br><span class="line">m_nDir = <span class="number">3</span>;</span><br><span class="line">m_nSpeed = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Shell <span class="title">Tank::fire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Shell sh;</span><br><span class="line">CPoint pt = m_rct.<span class="built_in">CenterPoint</span>();</span><br><span class="line">sh.<span class="built_in">Create</span>(pt, m_nDir, m_nSpeed * <span class="number">50</span>);</span><br><span class="line"><span class="keyword">return</span> sh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Tank::TOisOverlap</span><span class="params">(Object&amp; ob)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CRect&amp; rct = ob.m_rct;</span><br><span class="line"><span class="type">bool</span> check = <span class="literal">false</span>;</span><br><span class="line">CRect tmp;</span><br><span class="line">rct.<span class="built_in">NormalizeRect</span>();</span><br><span class="line">check = <span class="built_in">IntersectRect</span>(tmp, rct, m_rct);</span><br><span class="line"><span class="keyword">if</span> (check)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp.<span class="built_in">Height</span>() &lt; tmp.<span class="built_in">Width</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp.bottom &lt; rct.bottom)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_rct.<span class="built_in">OffsetRect</span>(<span class="number">0</span>, -(tmp.<span class="built_in">Height</span>() - CORRECT));</span><br><span class="line"><span class="keyword">if</span> (ob.m_movable)</span><br><span class="line">&#123;</span><br><span class="line">rct.<span class="built_in">OffsetRect</span>(<span class="number">0</span>, (tmp.<span class="built_in">Height</span>() - CORRECT));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_rct.<span class="built_in">OffsetRect</span>(<span class="number">0</span>, (tmp.<span class="built_in">Height</span>() - CORRECT));</span><br><span class="line"><span class="keyword">if</span> (ob.m_movable)</span><br><span class="line">&#123;</span><br><span class="line">rct.<span class="built_in">OffsetRect</span>(<span class="number">0</span>, -(tmp.<span class="built_in">Height</span>() - CORRECT));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp.right &lt; rct.right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_rct.<span class="built_in">OffsetRect</span>(-tmp.<span class="built_in">Width</span>() - CORRECT, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ob.m_movable)</span><br><span class="line">&#123;</span><br><span class="line">rct.<span class="built_in">OffsetRect</span>(tmp.<span class="built_in">Width</span>() + CORRECT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_rct.<span class="built_in">OffsetRect</span>(tmp.<span class="built_in">Width</span>() - CORRECT, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ob.m_movable)</span><br><span class="line">&#123;</span><br><span class="line">rct.<span class="built_in">OffsetRect</span>(-(tmp.<span class="built_in">Width</span>() - CORRECT), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> check;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Tank::TisOverlap</span><span class="params">(CRect rct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">bool</span> check = <span class="literal">false</span>;</span><br><span class="line">CRect tmp;</span><br><span class="line">rct.<span class="built_in">NormalizeRect</span>();</span><br><span class="line">check = <span class="built_in">IntersectRect</span>(tmp, rct, m_rct);</span><br><span class="line"><span class="keyword">if</span> (check)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp.<span class="built_in">Height</span>() &lt; tmp.<span class="built_in">Width</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp.bottom &lt; rct.bottom)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_rct.<span class="built_in">OffsetRect</span>(<span class="number">0</span>, -(tmp.<span class="built_in">Height</span>()-CORRECT));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_rct.<span class="built_in">OffsetRect</span>(<span class="number">0</span>, (tmp.<span class="built_in">Height</span>()-CORRECT));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tmp.right &lt; rct.right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_rct.<span class="built_in">OffsetRect</span>(-tmp.<span class="built_in">Width</span>()-CORRECT,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_rct.<span class="built_in">OffsetRect</span>(tmp.<span class="built_in">Width</span>()-CORRECT,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> check;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tank::Show</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//pDC-&gt;Rectangle(m_rct);</span></span><br><span class="line"><span class="comment">//pDC-&gt;MoveTo(m_rct.CenterPoint());</span></span><br><span class="line"><span class="comment">//if (m_nDir == 0)</span></span><br><span class="line"><span class="comment">//pDC-&gt;LineTo(m_rct.CenterPoint().x, m_rct.CenterPoint().y - 20);</span></span><br><span class="line"><span class="comment">//else if (m_nDir == 1)</span></span><br><span class="line"><span class="comment">//pDC-&gt;LineTo(m_rct.CenterPoint().x, m_rct.CenterPoint().y + 20);</span></span><br><span class="line"><span class="comment">//else if (m_nDir == 2)</span></span><br><span class="line"><span class="comment">//pDC-&gt;LineTo(m_rct.CenterPoint().x - 20, m_rct.CenterPoint().y);</span></span><br><span class="line"><span class="comment">//else if (m_nDir == 3)</span></span><br><span class="line"><span class="comment">//pDC-&gt;LineTo(m_rct.CenterPoint().x + 20, m_rct.CenterPoint().y);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////贴图的实现/////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*pDC-&gt;Rectangle(m_rct);</span></span><br><span class="line"><span class="comment">pDC-&gt;MoveTo(m_rct.CenterPoint());*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MyTank-h"><a href="#MyTank-h" class="headerlink" title="MyTank.h"></a><code>MyTank.h</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Tank.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTank</span> : <span class="keyword">public</span> Tank</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">Shell <span class="title">Fire</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">MyTank</span>();</span><br><span class="line"><span class="type">bool</span> m_move = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">respan</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">gameover</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">show_life</span><span class="params">(CDC* pDC,CRect rct)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(CDC* pDC)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDir</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myMove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">static</span> CImage m_img[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CPoint m_respanpos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="MyTank-cpp"><a href="#MyTank-cpp" class="headerlink" title="MyTank.cpp"></a><code>MyTank.cpp</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyTank.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mmsystem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;winmm.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CImage MyTank::m_img[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">Shell <span class="title">MyTank::Fire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Shell sh;</span><br><span class="line">CPoint pt = m_rct.<span class="built_in">CenterPoint</span>();</span><br><span class="line">sh.<span class="built_in">Create</span>(pt, m_nDir, m_nSpeed*<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//播放声音</span></span><br><span class="line">CString strFileName;</span><br><span class="line">TCHAR cPath[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, cPath, <span class="number">1024</span>);</span><br><span class="line">strFileName = cPath;</span><br><span class="line">CString strSound = strFileName.<span class="built_in">Left</span>(strFileName.<span class="built_in">ReverseFind</span>(<span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span>) + <span class="string">L&quot;fire.wav&quot;</span>;</span><br><span class="line"><span class="built_in">PlaySound</span>(strSound, <span class="number">0</span>, SND_FILENAME | SND_ASYNC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyTank::Show</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//显示坦克</span></span><br><span class="line"><span class="keyword">if</span> (m_nDir == DIR_UP)</span><br><span class="line">m_img[DIR_UP].<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), m_rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_nDir == DIR_DOWN)</span><br><span class="line">m_img[DIR_DOWN].<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), m_rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_nDir == DIR_LEFT)</span><br><span class="line">m_img[DIR_LEFT].<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), m_rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_nDir == DIR_RIGHT)</span><br><span class="line">m_img[DIR_RIGHT].<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), m_rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTank::<span class="built_in">MyTank</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_respanpos = <span class="built_in">CPoint</span>(<span class="number">150</span>, <span class="number">450</span>);</span><br><span class="line">m_rct = <span class="built_in">CRect</span>(m_respanpos, <span class="built_in">CSize</span>(Tank_size,Tank_size));</span><br><span class="line">m_life = <span class="number">5</span>;</span><br><span class="line">m_nSpeed = <span class="number">4</span>;</span><br><span class="line">m_nDir = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyTank::show_life</span><span class="params">(CDC* pDC,CRect rct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_life; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_img[DIR_UP].<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line">rct.<span class="built_in">OffsetRect</span>(rct.<span class="built_in">Width</span>() + <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m_img[DIR_UP].<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line">rct.<span class="built_in">OffsetRect</span>(-(rct.<span class="built_in">Width</span>() + <span class="number">2</span>)*<span class="number">4</span>, rct.<span class="built_in">Height</span>() + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyTank::respan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_rct = <span class="built_in">CRect</span>(m_respanpos, <span class="built_in">CSize</span>(Tank_size, Tank_size));</span><br><span class="line">m_nDir = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyTank::gameover</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_life = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyTank::setDir</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_move = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m_nDir = i;</span><br><span class="line">m_move = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyTank::myMove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_move)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Move</span>(m_nDir);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EneTank-cpp"><a href="#EneTank-cpp" class="headerlink" title="EneTank.cpp"></a><code>EneTank.cpp</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EneTank.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量初始化</span></span><br><span class="line">CImage EneTank::ene_img[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//消灭坦克数</span></span><br><span class="line"><span class="type">int</span> EneTank::total_num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//难度</span></span><br><span class="line"><span class="type">int</span> EneTank::level = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">EneTank::<span class="built_in">EneTank</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_firetime = m_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line">m_nSpeed = <span class="number">1</span>+level;</span><br><span class="line">m_nDir = <span class="number">1</span>;</span><br><span class="line">m_life = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机方向和持续时间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="built_in">rand_s</span>(&amp;i);</span><br><span class="line">m_rct = <span class="built_in">CRect</span>(birth[total_num % <span class="number">3</span>],<span class="built_in">CSize</span>(Tank_size,Tank_size));</span><br><span class="line"><span class="built_in">rand_s</span>(&amp;i);</span><br><span class="line">m_span = <span class="number">1</span> + i % <span class="number">2</span>;</span><br><span class="line">m_firespan = <span class="number">5</span> + i % <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EneTank::<span class="built_in">EneTank</span>(<span class="type">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">m_firetime = m_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line">m_nSpeed = <span class="number">1</span>+level;</span><br><span class="line">m_nDir = <span class="number">1</span>;</span><br><span class="line">m_life = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//随机运动时间和开火间隔</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="built_in">rand_s</span>(&amp;i);</span><br><span class="line">m_rct = <span class="built_in">CRect</span>(birth[pos%<span class="number">3</span>], <span class="built_in">CSize</span>(Tank_size, Tank_size));</span><br><span class="line"><span class="built_in">rand_s</span>(&amp;i);</span><br><span class="line">m_span = <span class="number">1</span> + i % <span class="number">2</span>;</span><br><span class="line">m_firespan = <span class="number">2</span> + (i % <span class="number">12</span>) / level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EneTank::re_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_span = <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EneTank::fireClock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//原理和AutoMove相似，随机开炮时间间隔</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">GetTickCount</span>() - m_firetime) / <span class="number">1000</span> &lt; m_firespan)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="built_in">rand_s</span>(&amp;i);</span><br><span class="line">m_firetime = <span class="built_in">GetTickCount</span>();</span><br><span class="line">m_firespan = <span class="number">1</span>+(i % <span class="number">6</span>) / (<span class="number">0.5</span>*level);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EneTank::Show</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_nDir == DIR_UP)</span><br><span class="line">ene_img[DIR_UP].<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), m_rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_nDir == DIR_DOWN)</span><br><span class="line">ene_img[DIR_DOWN].<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), m_rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_nDir == DIR_LEFT)</span><br><span class="line">ene_img[DIR_LEFT].<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), m_rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_nDir == DIR_RIGHT)</span><br><span class="line">ene_img[DIR_RIGHT].<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), m_rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EneTank::AutoMove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">////随机部分（后期实现时可以不用，改为遇墙再随机即可）</span></span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">GetTickCount</span>()-m_time)/<span class="number">1000.0</span>&lt;m_span )</span><br><span class="line"><span class="built_in">Move</span>(m_nDir);</span><br><span class="line"><span class="keyword">else</span><span class="comment">//否则重新随机方向和持续时间</span></span><br><span class="line"><span class="built_in">ChangeDir</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EneTank::ChangeDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="built_in">rand_s</span>(&amp;i);</span><br><span class="line">m_nDir = (i % <span class="number">6</span>);<span class="comment">//方向,可调节向下运动的权重</span></span><br><span class="line"><span class="keyword">if</span> (m_nDir &gt; <span class="number">3</span>)</span><br><span class="line">m_nDir = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">rand_s</span>(&amp;i);</span><br><span class="line">m_nSpeed = <span class="number">1</span> + level;</span><br><span class="line">m_span = <span class="number">3</span> + i % <span class="number">5</span>;<span class="comment">//持续时间</span></span><br><span class="line">m_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EneTank::eme_down</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">total_num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shell-h"><a href="#Shell-h" class="headerlink" title="Shell.h"></a><code>Shell.h</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Object.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shell</span> :<span class="keyword">public</span> Object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Shell</span>();</span><br><span class="line">CImage <span class="type">static</span> s_img;</span><br><span class="line"><span class="type">bool</span> m_inbox;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(CDC* pDC)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(CPoint pos, <span class="type">int</span> nDir, <span class="type">int</span> nSpeed)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SSisOverlap</span><span class="params">(Shell&amp; sh)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdatePos</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">DWORD m_time;</span><br><span class="line">CRect m_iniRct;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Shell-cpp"><a href="#Shell-cpp" class="headerlink" title="Shell.cpp"></a><code>Shell.cpp</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Shell.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CImage Shell::s_img;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Shell::<span class="built_in">Shell</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_inbox = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Shell::SSisOverlap</span><span class="params">(Shell&amp; sh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsOverLap</span>(sh.<span class="built_in">GetPos</span>()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shell::Show</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">UpdatePos</span>();</span><br><span class="line">s_img.<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), m_rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shell::UpdatePos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD tm = <span class="built_in">GetTickCount</span>();</span><br><span class="line"><span class="type">int</span> nDis = (tm - m_time) * m_nSpeed / <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">switch</span> (m_nDir)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DIR_UP:</span><br><span class="line">m_rct.<span class="built_in">MoveToY</span>(m_iniRct.top - nDis);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DIR_DOWN:</span><br><span class="line">m_rct.<span class="built_in">MoveToY</span>(m_iniRct.top + nDis);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DIR_LEFT:</span><br><span class="line">m_rct.<span class="built_in">MoveToX</span>(m_iniRct.left - nDis);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DIR_RIGHT:</span><br><span class="line">m_rct.<span class="built_in">MoveToX</span>(m_iniRct.left + nDis);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_rct.top&lt;<span class="number">0</span> || m_rct.bottom&gt;Y_MAX</span><br><span class="line">|| m_rct.left&lt;<span class="number">0</span> || m_rct.right&gt;X_MAX)</span><br><span class="line">m_inbox = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shell::Create</span><span class="params">(CPoint pos, <span class="type">int</span> nDir, <span class="type">int</span> nSpeed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_nDir = nDir;</span><br><span class="line">m_nSpeed = nSpeed;</span><br><span class="line"><span class="type">int</span> nShellSize = <span class="number">4</span>;</span><br><span class="line">m_rct = <span class="built_in">CRect</span>(pos.x - nShellSize, pos.y - nShellSize, pos.x + nShellSize, pos.y + nShellSize);</span><br><span class="line">m_iniRct = m_rct;</span><br><span class="line">m_time = <span class="built_in">GetTickCount</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="wall-h"><a href="#wall-h" class="headerlink" title="wall.h"></a><code>wall.h</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Object.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BRICK 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> METAL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GRASS 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WATER 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WOOD 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wall</span> :<span class="keyword">public</span> Object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">wall</span>(CPoint pt,<span class="type">int</span> type);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> Dir)</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">disappear</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(CDC* pDC)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//墙的类型和属性</span></span><br><span class="line"><span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> ShellPass = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> TankPass = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> destroyable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//贴图</span></span><br><span class="line"><span class="type">static</span> CImage w_img[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试用的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="wall-cpp"><a href="#wall-cpp" class="headerlink" title="wall.cpp"></a><code>wall.cpp</code></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wall.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CImage wall::w_img[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">wall::<span class="built_in">wall</span>(CPoint pt,<span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">CRect <span class="title">temp</span><span class="params">(pt, CSize(size, size))</span></span>;</span><br><span class="line">type = mode;</span><br><span class="line">m_movable = <span class="literal">false</span>;</span><br><span class="line">m_rct = temp;</span><br><span class="line"><span class="keyword">switch</span> (type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> BRICK:</span><br><span class="line">destroyable = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> GRASS:</span><br><span class="line">ShellPass = <span class="literal">true</span>;</span><br><span class="line">TankPass = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WATER:</span><br><span class="line">ShellPass = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WOOD:</span><br><span class="line">destroyable = <span class="literal">true</span>;</span><br><span class="line">m_movable = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BASE:</span><br><span class="line">destroyable = <span class="literal">true</span>;</span><br><span class="line">TankPass = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wall::Show</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">w_img[type].<span class="built_in">Draw</span>(pDC-&gt;<span class="built_in">GetSafeHdc</span>(), m_rct, Gdiplus::InterpolationModeHighQuality);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">当初上“面向对象的程序设计”时写的坦克大战。</summary>
    
    
    
    <category term="编程作业" scheme="http://zerolacqua.top/categories/%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="c++" scheme="http://zerolacqua.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>移动编程记录</title>
    <link href="http://zerolacqua.top/posts/79ac647.html"/>
    <id>http://zerolacqua.top/posts/79ac647.html</id>
    <published>2022-02-26T12:15:37.000Z</published>
    <updated>2022-04-17T10:04:38.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你可能会觉得很奇怪，这博客是怎么建起来的。不过，我确实是零前端基础，这博客都是按照教程用别人的主题弄的2333</p><hr><h2 id="初次尝试三件套"><a href="#初次尝试三件套" class="headerlink" title="初次尝试三件套"></a>初次尝试三件套</h2><p>先把这次的源码贴上:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>学习和实践H5<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">120px</span> auto auto auto</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">form</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">500px</span>; <span class="comment">/*设置宽度*/</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">50px</span> auto auto auto; </span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">label</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">180px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: left;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">input</span><span class="selector-class">.align</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">250px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">input</span><span class="selector-class">.button</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    Register in</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;./xxxx&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">legend</span>&gt;</span>Basic Information:<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>User Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;align&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Password:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;align&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Email:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;align&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Tel:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">class</span>=<span class="string">&quot;align&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;return validate()&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 75px;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Reset&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 100px;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">validate</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> username = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> password = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> email = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;email&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> tel = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (username == <span class="string">&quot;&quot;</span> || password == <span class="string">&quot;&quot;</span> || email == <span class="string">&quot;&quot;</span> || tel == <span class="string">&quot;&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;please complete the form!&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表单其实有现成的，但是如何排版对齐，我还是没什么好主意的。最后是网上找别人的代码现学的。然后不禁感慨，啊原来可以这么对齐，可以用这个东西……这次主要学到的是这几个</p><p>这里利用<code>label class = &quot;align&quot;</code> 和 <code>label class = &quot;button&quot;</code> 区分<code>Input</code>，然后就可以在CSS中分别指定样式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Tel:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">class</span>=<span class="string">&quot;align&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;return validate()&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 75px;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>题目中还要求用JS判断提交时输入的文本框中是否为空，这就涉及到Submit 按钮与JS函数的执行顺序的问题。</p><p><code>return validate()</code>的作用，就是在<code>validate()</code>返回<code>false</code>时终止Submit按钮的提交。如果不加<code>return</code>，在执行完<code>validate()</code>后，无论返回的是<code>true</code>还是<code>false</code>，都不会影响Submit按钮会提交表单</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;return validate()&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 75px;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="angular、cordova和ionic应用的配置"><a href="#angular、cordova和ionic应用的配置" class="headerlink" title="angular、cordova和ionic应用的配置"></a>angular、cordova和ionic应用的配置</h2><p>这部分给我的感觉就是累，非常累，几乎花掉了我整个周末（虽然让我对<code>npm</code>的理解稍微有了点进步）。本来能记得详细些的，不过时间紧张，只能水一水了。</p><p><code>angular</code>的配置没啥太多的印象了，不难。</p><p><code>cordova</code>可折磨了我好久。低版本的<code>cordova</code>似乎需要<code>1.8</code>以下的<code>JDK</code>，我的是<code>13.x</code>（相当于原来的<code>1.13</code>）的了。高版本的<code>cordova</code>又不能单独用<code>android SDK</code>，于是我又下了<code>Android Studio</code>，然后发现还是不行，只能再单独下一个<code>gradle</code>。这样才把<code>cordova</code>的应用在模拟机上运行成功.</p><p><code>ionic</code>则目前还没有什么进展，<code>apk</code>在虚拟机中运行依然是白屏。不过有一点值得记录，<code>ionic</code>改名为了<code>@ionic/cli</code>，所以如果有报错说找不到某个<code>option</code>，可能就是用的是老版本了。比如说这个问题：<a href="https://github.com/ionic-team/capacitor/issues/4603">unknown option ‘—npm-client’ for ‘ionic integrations enable capacitor’ command</a>（事实证明，到<strong>github</strong>上找issue确实是个好办法）</p><p>最后不得不吐槽一下这门课，感觉这课教的东西有点老掉牙了，跑命令的时候看到了满屏幕的<code>deprecated</code>，我的内心是崩溃的……</p><p>更新一下，<code>ionic</code>的问题找到了，是虚拟机的锅……白忙活半天哈哈哈哈哈哈。</p><h2 id="div、回调函数、Promise和NPM"><a href="#div、回调函数、Promise和NPM" class="headerlink" title="div、回调函数、Promise和NPM"></a>div、回调函数、Promise和NPM</h2><p>用<code>div</code>居中比较简单，没什么好多说的。</p><p>回调函数是我花时间最多的部分，毕竟JS的回调函数和一般意义上的回调函数有不小的区别。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>回调函数<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>按下按钮后显示数据<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;call_back_test(&#x27;data.json&#x27;,displayer)&quot;</span>&gt;</span></span><br><span class="line">            点击这里</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;data&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">call_back_test</span>(<span class="params">url, callback</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> request;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123; <span class="comment">//检查浏览器的XMLHttpRequest属性，如果为真则支持XMLHttpRequest</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// IE7+, Firefox, Chrome, Opera, Safari 浏览器支持XMLHttpRequest </span></span></span><br><span class="line"><span class="language-javascript">                    request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// IE6, IE5 浏览器使用ActiveXObject</span></span></span><br><span class="line"><span class="language-javascript">                    request = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                request.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, url); <span class="comment">/*设置请求方法与路径*/</span></span></span><br><span class="line"><span class="language-javascript">                request.<span class="title function_">send</span>(<span class="literal">null</span>); <span class="comment">/*不发送数据到服务器*/</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">/*XHR对象获取到返回信息后执行*/</span></span></span><br><span class="line"><span class="language-javascript">                request.<span class="property">onload</span> = <span class="function">() =&gt;</span> <span class="title function_">callback</span>(request)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">displayer</span>(<span class="params">request</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (request.<span class="property">status</span> == <span class="number">200</span>) &#123; <span class="comment">/*返回状态为200，即为数据获取成功*/</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> json = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(request.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;data&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; json.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;data&quot;</span>).<span class="property">innerHTML</span> += (<span class="string">&quot; id:&quot;</span> + json[i].<span class="property">id</span> + <span class="string">&quot; email:&quot;</span> + json[i].<span class="property">email</span> </span></span><br><span class="line"><span class="language-javascript">                        + <span class="string">&quot; name:&quot;</span> + json[i].<span class="property">name</span> + <span class="string">&quot; password:&quot;</span> + json[i].<span class="property">password</span> + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;data&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;Fail to load.&quot;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>弄清了回调函数，<code>Promise</code>使用起来也不难。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>生产-消费模型<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>显示数据<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;data&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> request;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123; <span class="comment">//检查浏览器的XMLHttpRequest属性，如果为真则支持XMLHttpRequest</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// IE7+, Firefox, Chrome, Opera, Safari 浏览器支持XMLHttpRequest </span></span></span><br><span class="line"><span class="language-javascript">                    request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// IE6, IE5 浏览器使用ActiveXObject</span></span></span><br><span class="line"><span class="language-javascript">                    request = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">                request.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;data.json&quot;</span>); <span class="comment">/*设置请求方法与路径*/</span></span></span><br><span class="line"><span class="language-javascript">                request.<span class="title function_">send</span>(<span class="literal">null</span>); <span class="comment">/*不发送数据到服务器*/</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">/*XHR对象获取到返回信息后执行*/</span></span></span><br><span class="line"><span class="language-javascript">                request.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (request.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">resolve</span>(request);</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">reject</span>(<span class="string">&quot;File not Found&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            promise.<span class="title function_">then</span>(</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">var</span> json = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(value.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; json.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;data&quot;</span>).<span class="property">innerHTML</span> += (<span class="string">&quot; id:&quot;</span> + json[i].<span class="property">id</span> + <span class="string">&quot; email:&quot;</span> + json[i].<span class="property">email</span></span></span><br><span class="line"><span class="language-javascript">                            + <span class="string">&quot; name:&quot;</span> + json[i].<span class="property">name</span> + <span class="string">&quot; password:&quot;</span> + json[i].<span class="property">password</span> + <span class="string">&quot;&lt;br&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">function</span> (<span class="params">error</span>) &#123; <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;data&quot;</span>).<span class="property">innerHTML</span> = error; &#125;</span></span><br><span class="line"><span class="language-javascript">            );</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>npm</code>今天没时间弄了，明天再弄。</p><p>这是创建的包</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-package-ttt&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Zerol Acqua&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>和对应的<code>index.js</code>文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js </span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">add</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">sub</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">mul</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">div</span> = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是测试文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">require</span>(<span class="string">&quot;../myPackage&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">add</span>(<span class="number">10</span>,<span class="number">5</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">sub</span>(<span class="number">10</span>,<span class="number">5</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">mul</span>(<span class="number">10</span>,<span class="number">5</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">div</span>(<span class="number">10</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>本地测试时，在模块和项目目录下分别执行<code>npm link</code>和<code>npm link module_name</code>进行链接，测试结束则执行<code>npm unlink module_name</code></p><p>要想清除掉在<code>node_global\node_modules</code>中链接的包，还需要加上<code>-g</code>选项。</p><h2 id="Angular移动端信息采集和展示"><a href="#Angular移动端信息采集和展示" class="headerlink" title="Angular移动端信息采集和展示"></a>Angular移动端信息采集和展示</h2><p>我真的是难顶啊，老师的源代码在我这里会报错，要疯掉了。</p><p>遇到的几个麻烦的问题：</p><ol><li><p>Can’t bind to <code>ngForOf</code> since it isn’t a known property of <code>tr</code></p><p>原因：<code>ngFor</code>所对应的<code>component</code>没有添加到<code>app.module.ts</code>的<code>declarations</code>中</p><p>解决方法：</p> <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="comment">// 需要添加在这里</span></span><br><span class="line">  <span class="attr">declarations</span>: [</span><br><span class="line">    <span class="title class_">AppComponent</span>,</span><br><span class="line">    <span class="title class_">DatacollectComponent</span>,</span><br><span class="line">    <span class="title class_">DatashowComponent</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    <span class="title class_">BrowserModule</span>,</span><br><span class="line">    <span class="title class_">AppRoutingModule</span>,</span><br><span class="line">    <span class="title class_">FormsModule</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">providers</span>: [],</span><br><span class="line">  <span class="attr">bootstrap</span>: [<span class="title class_">AppComponent</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 参见：<a href="https://stackoverflow.com/questions/60533597/cant-bind-to-ngforof-since-it-isnt-a-known-property-of-tr-in-angular-9">stackoverflow</a></p></li><li><p>类型<code>Sitedata</code>的参数不能赋给类型<code>never</code>的参数</p><p> 原因：数组需要定义类型，默认为<code>Array&lt;never&gt;</code></p><p> 解决方法：</p> <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SitedataserviceService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">  sitedatalist = [] <span class="keyword">as</span> <span class="title class_">Sitedata</span>[]</span><br><span class="line">  <span class="title function_">getSiteDataList</span>(): <span class="title class_">Sitedata</span>[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">sitedatalist</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addSiteData</span>(<span class="params">sitedata: Sitedata</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sitedatalist</span>.<span class="title function_">push</span>(sitedata);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 参见：<a href="https://segmentfault.com/q/1010000040727394?bd_source_light=4746641">SegmentFault</a></p></li><li><p>Property <code>value</code> does not exist on type <code>EventTarget</code>.</p><p>原因：在模板中，<code>$event.target</code> 的类型只是 <code>EventTarget</code>。在 <code>getValue()</code> 方法中，把此目标转为 <code>HTMLInputElement</code> 类型，以允许对其 <code>value</code> 属性进行类型安全的访问。</p><p>解决方法：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getValue</span>(<span class="attr">event</span>: <span class="title class_">Event</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (event.<span class="property">target</span> <span class="keyword">as</span> <span class="title class_">HTMLInputElement</span>).<span class="property">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参见：<a href="https://angular.cn/guide/event-binding-concepts">Angular - 事件绑定的工作原理</a></p></li><li><p>表单数据重复</p><p>原因：根据调试结果可以推测，在没有切换到其它页面时，通过<code>summmit</code>加入数组的<code>Sitedata</code>是同一个数据的引用（？），因而<code>addSiteData</code>加入数组的所有数据全是最后一次修改的数据。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">submit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sitedata</span>.<span class="property">projName</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sitedataserviceservice</span>.<span class="title function_">addSiteData</span>(<span class="variable language_">this</span>.<span class="property">sitedata</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sitedataserviceservice</span>.<span class="title function_">getSiteDataList</span>());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">submit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sitedata</span>.<span class="property">projName</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sitedataserviceservice</span>.<span class="title function_">addSiteData</span>(<span class="variable language_">this</span>.<span class="property">sitedata</span>);</span><br><span class="line">    <span class="comment">// 加在这里！！新开一个数据对象</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sitedata</span> = <span class="keyword">new</span> <span class="title class_">Sitedata</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sitedataserviceservice</span>.<span class="title function_">getSiteDataList</span>());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="H5和原生应用交互调用（Android-和-JS-交互实践）"><a href="#H5和原生应用交互调用（Android-和-JS-交互实践）" class="headerlink" title="H5和原生应用交互调用（Android 和 JS 交互实践）"></a>H5和原生应用交互调用（Android 和 JS 交互实践）</h2><p>难啊，这是真的难，这次作业我甚至都不知道该做什么了。看代码我还勉强能懂，但是让我改UI我实在是不知道怎么下手……</p><p>不过还好在 Andriod Studio 里试了试，发现有类似的 UI 设计交互界面，因此 UI 的设计就省了不少事了，主要还是HTML的样式。</p><blockquote><p>以下部分为教学内容</p></blockquote><p><code>Android</code> 与 <code>JS</code> 交互实际上是通过 <code>WebView</code> 互相调用方法：</p><ul><li><code>Android</code> 去调用 <code>JS</code> 的代码；</li><li><code>JS</code> 去调用 <code>Android</code> 的代码。</li></ul><h3 id="JS-调用-Android-方法"><a href="#JS-调用-Android-方法" class="headerlink" title="JS 调用 Android 方法"></a>JS 调用 Android 方法</h3><ul><li><p>方法一：通过 <code>WebView</code> 的 <code>addJavascriptInterface()</code> 进行对象映射</p><blockquote><p>优点：使用简单，仅将Android对象和JS对象映射即可</p><p>缺点：存在漏洞问题</p></blockquote><ol><li><p>允许 <code>WebView</code> 加载 JS</p><p><code>webView.getSettings().setJavaScriptEnabled(true);</code></p></li><li><p>编写 JS 接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsInterface</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;JsInterface&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> JsBridge jsBridge;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsInterface</span><span class="params">(JsBridge jsBridge)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jsBridge = jsBridge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法由 JS 调用， 不在主线程执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callAndroid</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line">        jsBridge.setTextValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给 <code>WebView</code> 添加 JS 接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">JsInterface</span>(<span class="built_in">this</span>), <span class="string">&quot;launcher&quot;</span>);<span class="comment">// 此处的 launcher 可以自定义，最终是 JS 中要使用的对象 </span></span><br></pre></td></tr></table></figure></li><li><p>JS 代码中调用 Java 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">launcher</span>)&#123; <span class="comment">// 判断 launcher 对象是否存在</span></span><br><span class="line">   <span class="comment">// 此处的 launcher 要和 第3步中定义的 launcher 保持一致</span></span><br><span class="line">    <span class="comment">// JS 调用 Android 的方法</span></span><br><span class="line">    launcher.<span class="title function_">callAndroid</span>(str);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;launcher not found!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>方法二：通过 <code>WebViewClient</code> 的 <code>shouldOverrideUrlLoading()</code> 方法回调拦截 <code>url</code> </p><blockquote><p>优点：不存在方式一的漏洞；</p><p>缺点：JS获取Android方法的返回值复杂。 </p></blockquote><ol><li><p>JS 代码中，约定协议</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callAndroid</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 约定的 url 协议为：js://webview?arg1=111&amp;arg2=222</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">location</span> = <span class="string">&quot;js://webview?arg1=&quot;</span>+inputEle.<span class="property">value</span>+<span class="string">&quot;&amp;arg2=222&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Android 代码中，通过设置 <code>WebViewClient</code> 对协议进行拦截处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">WebViewClient</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;</span><br><span class="line">        <span class="comment">// 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span></span><br><span class="line">        <span class="comment">// 例如：url = &quot;js://webview?arg1=111&amp;arg2=222&quot;</span></span><br><span class="line">        <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(url);</span><br><span class="line">        <span class="comment">// 如果url的协议 = 预先约定的 js 协议</span></span><br><span class="line">        <span class="keyword">if</span> (uri.getScheme().equals(<span class="string">&quot;js&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 拦截url,下面JS开始调用Android需要的方法</span></span><br><span class="line">            <span class="keyword">if</span> (uri.getAuthority().equals(<span class="string">&quot;webview&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 执行JS所需要调用的逻辑</span></span><br><span class="line">                Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;JS 调用了 Android 的方法&quot;</span>);</span><br><span class="line">                Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line">                Iterator&lt;String&gt; it = collection.iterator();</span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    result += uri.getQueryParameter(it.next()) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tv_result.setText(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.shouldOverrideUrlLoading(view, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>方法三：通过 <code>WebChromeClient</code> 的<code>onJsAlert()</code> 、 <code>onJsConfirm()</code> 、<code>onJsPrompt()</code>方法回调拦截 JS 对话框 <code>alert()</code> 、 <code>confirm()</code>、<code>prompt()</code> 消息</p><blockquote><p>处理方式和方法二差不多</p></blockquote><ol><li><p>JS代码中，约定协议 </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 prompt()</span></span><br><span class="line"><span class="keyword">var</span> result=<span class="title function_">prompt</span>(<span class="string">&quot;js://prompt?arg1=&quot;</span>+inputEle.<span class="property">value</span>+<span class="string">&quot;&amp;arg2=222&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;prompt：&quot;</span> + result);</span><br></pre></td></tr></table></figure></li><li><p>Android 代码中，通过设置 <code>WebChromeClient</code> 对协议进行拦截处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webView.setWebChromeClient(<span class="keyword">new</span> <span class="title class_">WebChromeClient</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsPrompt</span><span class="params">(WebView view, String url, String message, String defaultValue, JsPromptResult result)</span> &#123;</span><br><span class="line">        <span class="comment">// 一般根据scheme（协议格式） &amp; authority（协议名）判断（前两个参数）</span></span><br><span class="line">        <span class="comment">// 例如：url = &quot;js://webview?arg1=111&amp;arg2=222&quot;</span></span><br><span class="line">        <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(message);</span><br><span class="line">        Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;----onJsPrompt---&gt;&gt;&quot;</span> + url + <span class="string">&quot;,&quot;</span> + message);</span><br><span class="line">        <span class="comment">// 如果url的协议 = 预先约定的 js 协议</span></span><br><span class="line">        <span class="keyword">if</span> (uri.getScheme().equals(<span class="string">&quot;js&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 拦截url,下面JS开始调用Android需要的方法</span></span><br><span class="line">            <span class="keyword">if</span> (uri.getAuthority().equals(<span class="string">&quot;prompt&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 执行JS所需要调用的逻辑</span></span><br><span class="line">                Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;JS 调用了 Android 的方法&quot;</span>);</span><br><span class="line">                Set&lt;String&gt; collection = uri.getQueryParameterNames();</span><br><span class="line">                Iterator&lt;String&gt; it = collection.iterator();</span><br><span class="line">                <span class="type">String</span> <span class="variable">result2</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    result2 += uri.getQueryParameter(it.next()) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tv_result.setText(result2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onJsPrompt(view, url, message, defaultValue, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsAlert</span><span class="params">(WebView view, String url, String message, JsResult result)</span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;----onJsAlert---&gt;&gt;&quot;</span> + url+ <span class="string">&quot;,&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onJsAlert(view, url, message, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onJsConfirm</span><span class="params">(WebView view, String url, String message, JsResult result)</span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;----onJsConfirm---&gt;&gt;&quot;</span> + url+ <span class="string">&quot;,&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.onJsConfirm(view, url, message, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="Android-调用-JS-方法"><a href="#Android-调用-JS-方法" class="headerlink" title="Android 调用 JS 方法"></a>Android 调用 JS 方法</h3><ul><li><p>方法一： 通过 <code>WebView</code> 的 <code>loadUrl()</code></p><ol><li><p>编写 JS 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callJS = <span class="keyword">function</span>(<span class="params">str</span>)&#123;</span><br><span class="line">    inputEle.<span class="property">value</span> = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>webView.loadUrl()</code>调用 JS 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android 调用 JS 方法</span></span><br><span class="line">webView.loadUrl(<span class="string">&quot;javascript:if(window.callJS)&#123;window.callJS(&#x27;&quot;</span> + str + <span class="string">&quot;&#x27;);&#125;&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>方法二： 通过 <code>WebView</code> 的 <code>evaluateJavascript()</code></p><blockquote><ul><li>该方法比第一种方法效率更高，使用更简洁；</li><li>该方法执行不会刷新页面，而第一种方法（ <code>loadUrl</code> ）则会；</li><li>Android 4.4 以后才能使用。</li></ul></blockquote>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    webView.evaluateJavascript(<span class="string">&quot;javascript:if(window.callJS)&#123;window.callJS(&#x27;&quot;</span> + str + <span class="string">&quot;&#x27;);&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">ValueCallback</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceiveValue</span><span class="params">(String value)</span> &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;---------&gt;&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>最终还是没能捱过去，时间吃紧选择中期撤课了。不知道是好还是坏啊，不过至少还是学到了一点点有用的东西吧。</p>]]></content>
    
    
    <summary type="html">前端零基础，还头铁选了门空间信息移动编程，太难顶了（</summary>
    
    
    
    <category term="编程作业" scheme="http://zerolacqua.top/categories/%E7%BC%96%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
    <category term="html" scheme="http://zerolacqua.top/tags/html/"/>
    
    <category term="css" scheme="http://zerolacqua.top/tags/css/"/>
    
    <category term="javascript" scheme="http://zerolacqua.top/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>可爱的水伊布</title>
    <link href="http://zerolacqua.top/posts/a04972d8.html"/>
    <id>http://zerolacqua.top/posts/a04972d8.html</id>
    <published>2022-02-25T06:07:47.000Z</published>
    <updated>2022-05-03T14:30:37.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="水伊布太可爱了"><a href="#水伊布太可爱了" class="headerlink" title="水伊布太可爱了"></a>水伊布太可爱了</h2><!-- spoiler-1ffd9:black -->  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur spoiler-1ffd9">完全没有抵抗力啊啊啊！！！</span>  </span><hr><div class="fj-gallery"><p><img src="/images/blogs/可爱的水伊布/Vaporeon1.png" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon2.png" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon3.png" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon4.png" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon5.png" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon6.png" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon7.png" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon8.png" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon9.png" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon10.jpg" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon11.jpg" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon12.png" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon13.jpg" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon14.jpg" alt=""></p><p><img src="/images/blogs/可爱的水伊布/Vaporeon15.png" alt=""></p>          </div><hr><h2 id="伊布串串"><a href="#伊布串串" class="headerlink" title="伊布串串"></a>伊布串串</h2><p><img src="/images/blogs/可爱的水伊布/Vaporeon16.jpg" alt=""></p>]]></content>
    
    
    <summary type="html">图库与各种测试。</summary>
    
    
    
    <category term="图库" scheme="http://zerolacqua.top/categories/%E5%9B%BE%E5%BA%93/"/>
    
    
    <category term="博客搭建" scheme="http://zerolacqua.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="测试" scheme="http://zerolacqua.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>逻辑学导论复习</title>
    <link href="http://zerolacqua.top/posts/342e7773.html"/>
    <id>http://zerolacqua.top/posts/342e7773.html</id>
    <published>2022-02-25T04:11:59.000Z</published>
    <updated>2022-03-31T16:16:34.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ul><li><p>逻辑学的定义及其对象</p></li><li><p>逻辑学的基本作用</p></li><li><p>学习逻辑学的意义</p></li><li><p>逻辑学的研究方法</p></li><li><p>课程内容</p><ul><li><p>逻辑学的基本概念</p></li><li><p>语言和定义</p></li><li><p>演绎</p><ul><li><p>直言命题</p></li><li><p>直言三段论</p></li><li><p>符号逻辑</p></li><li><p>演绎方法</p></li></ul></li><li><p>归纳逻辑</p></li></ul></li><li><p>真实性与有效性</p><ul><li><p>前提真而结论假，则推理无效；</p></li><li><p>前提真，推理有效，则结论必真。</p></li><li><p>一个推理是有效的还是无效的，最直接的方法就是找一个与它的形式相同并且前提真而结论假的推理。</p></li></ul></li><li><p>逻辑的基本规律</p><ul><li><p>同一律</p><ul><li>在统一思维过程中，一切思想（包括概念和命题）都必须与自身保持同一。</li></ul></li><li><p>矛盾律</p><ul><li>两个互相矛盾的命题不能同时为真，也不能同为假。</li></ul></li><li><p>排中律</p><ul><li>两个互相矛盾的命题不能同为假，必有一真。</li></ul></li><li><p>充足理由律</p><ul><li>在同一思维和论证过程中，一个思想被确定为真，要有充足的理由</li></ul></li></ul></li></ul><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ul><li><p>命题和推理</p><ul><li><p>命题、判断和语句</p><ul><li><p>语句 是一组表示事物情况的声音或笔画，是命题的物质载体。</p></li><li><p>命题 是通过语句来反映事物情况（属性或关系）的思维形式。<br>两者之间有区别：只有表达了一种或真或假的思想的语句才是命题。</p></li><li><p>判断就是被断定了的命题。</p></li><li><p>语句与命题的区别</p><ul><li><p>同一命题可在不同语句中被断定。</p></li><li><p>同一语句可以表达不同的命题</p></li></ul></li></ul></li><li><p>命题的形式及其种类</p><ul><li><p>真值与真值承担者</p><ul><li>逻辑学只把命题视作真值承担者。</li></ul></li><li><p>命题形式</p><ul><li><p>命题可以分为简单命题和复合命题。</p></li><li><p>按照对一个命题的结构分析的层次不同，可以分成词项逻辑和命题逻辑。</p></li><li><p>简单命题与复合命题</p><ul><li><p>简单命题是不包含其他命题的命题。</p></li><li><p>原子命题是不能再进行分析的单个命题。</p></li><li><p>复合命题是由其他命题构成的命题，通常借助一些联结词来联结。</p></li><li><p>在复合命题中，构成复合命题的简单命题叫“肢命题”，联结肢命题的语词叫逻辑联结词，通常简称为“联结词”。不过，复合命题的肢命题也可能是复合命题。</p></li><li><p>根据逻辑联结词的不同，复合命题又可以分为联言、选言、假言命题和负命题。</p></li></ul></li></ul></li></ul></li><li><p>推理及其种类</p><ul><li><p>推理是一个命题序列，它是从一个或几个已知命题推出一个新命题的思维形式。</p><ul><li><p>从认识进程的角度来分：</p><ul><li><p>演绎推理：从一般到个别。</p></li><li><p>归纳推理：从个别到一般；但完全归纳法是演绎推理。</p></li><li><p>类比推理：从个别到个别。</p></li></ul></li><li><p>从结论的可靠性角度来分：</p><ul><li><p>必然推理：前提真则结论必然真的推理，它是保真性推理.</p></li><li><p>或然推理：前提真，结论不一定真；前提只为结论提供一定程度的支持。</p></li></ul></li></ul></li></ul></li></ul></li><li><p>联言命题及其推理</p><ul><li><p>定义</p><ul><li><p>联言命题是反映若干事物情况同时存在的命题，通常由“并且”这类联结词联结两个或多个肢命题形成的复合命题。</p></li><li><p>“联言”的逻辑符号都表示为“$\land$”（读作“合取”），因此又叫合取命题。</p></li></ul></li><li><p>联言命题的逻辑值</p><ul><li><p>一个联言命题的所有肢命题同时为真，该命题才为真；否则为假。</p></li><li><p>一个命题有两个命题变项时，真值表共有4行；有n个命题变项时，真值表共有$2^n$行。</p></li></ul></li><li><p>联言命题的种类和省略式</p><ul><li><p>复合谓项联言命题</p><ul><li>由两个或两个以上的并列谓项和一个相同的主项构成的联言命题。它反映同一客观对象具有或不具有多种不同事物情况，通常只写一次主项，其余都承前省略。</li></ul></li><li><p>复合主项联言命题</p><ul><li>由两个或两个以上并列的主项和一个相同的谓项所构成的联言命题。它反映两个或两个以上的对象具有或不具有某种共同的情况。通常只写一次谓项，其余都承后省略。</li></ul></li><li><p>复合主谓项联言命题</p><ul><li>由两个或两个以上并列的主项和谓项所构成的命题。它反映两个或两个以上的客观对象同时具有或不具有两种或两种以上的事物情况。</li></ul></li></ul></li><li><p>联言命题推理#命题推理</p><ul><li><p>合成式：如果分别肯定两个联言支，那么就可以肯定它们组成的联言命题。</p><ul><li>$(p, q) \models(p\land q)$</li></ul></li><li><p>分解式：如果肯定一个联言命题，那么就可以分别肯定其中的每一个联言支。</p><ul><li>$p\land q\models q$</li></ul></li></ul></li></ul></li><li><p>选言命题及其推理</p><ul><li><p>定义</p><ul><li><p>反映在若干事物情况中至少有一个存在的命题。</p></li><li><p>构成选言命题的简单（肢）命题叫选言肢。一个选言命题可以有多个选言肢，不同选言肢之间通常由表示选言的联结词联结。</p></li></ul></li><li><p>分类</p><ul><li><p>相容选言命题：各选言肢之间彼此相容，可以同真。<br>只有当所有选言肢都为假时，相容选言命题才为假。</p></li><li><p>不相容选言命题<br>选言肢之间是相互排斥的，即如果其中的一个为真，则其余的不可能为真。</p></li></ul></li><li><p>选言命题推理#命题推理</p><ul><li><p>相容选言推理</p><ul><li>$((p\lor q)\land \lnot p) \models q$<br>注意：肯定否定式是错误的，也即在肯定一个选言肢后，并不能必定肯定或否定另一个选言肢。</li></ul></li><li><p>不相容选言推理</p><ul><li><p>肯定否定式：肯定一个选言肢，必否定另一个选言肢</p><ul><li>$((p\lor q)\land p)\models \lnot q$</li></ul></li><li><p>否定肯定式：否定一个选言肢，必肯定另一个选言肢</p><ul><li>$((p\lor q)\land \lnot p)\models  q$</li></ul></li></ul></li><li><p>联言命题与选言命题对当方阵</p></li></ul></li></ul></li><li><p>假言命题及其推理</p><ul><li><p>定义</p><ul><li><p>断定一事物情况是另一事物情况存在的条件的命题。</p></li><li><p>假言命题都是表示条件的复合命题。每一个假言命题包括两个肢命题，其中表示条件的肢命题叫“前件”，表示依赖条件而成立的另一个命题叫“后件”。</p></li><li><p>联结前、后件这两个肢命题的语词叫“假言联结词”。通常有：“如果，那么”；“只有，才”，“当且仅当”等等</p></li></ul></li><li><p>分类</p><ul><li><p>充分条件假言命题：</p><p>断定一事物情况是另一事物情况存在的充分条件的假言命题</p><ul><li><p>$p\implies q$</p></li><li><p>$ p\implies q$为真的条件：</p></li><li><p>在p真时q一定为真。至于p为假时，q可真可假。</p></li><li><p>$p\implies q$为假的条件：</p></li><li><p>在p真时q为假，因为这与充分条件的含义不符。</p></li></ul></li><li><p>必要条件假言命题</p><p>断定某事物情况是另一事物情况存在的必要条件的命题</p><ul><li><p>$p \ \Longleftarrow  \  q$</p></li><li><p>$p \ \Longleftarrow  \  q$为假的条件：在p假时q为真，因为这与必要条件的含义不符。</p></li></ul></li><li><p>充分必要条件假言命题</p><p>反映某事物情况是另一个事物情况的充分且必要条件的命题。</p><ul><li>$ p\iff q$</li><li>$p\iff q$的真假条件：前后件p和q具有相同的真值（即同真或同假）时，该命题才为真；其余情形下为假。</li></ul></li></ul></li><li><p>假言命题推理#命题推理 </p><ul><li><p>假言推理</p><ul><li><p>前提中有一个假言命题，并且根据假言命题前后件之间的逻辑关系来推出结论的推理。</p></li><li><p>充分条件假言推理</p><p>前提中有一个充分条件假言命题的推理。</p><ul><li><p>肯定前件就要肯定后件：$ ((p\implies q ) \land p )\models q$</p></li><li><p>否定后件就要否定前件：$((p\implies q ) \land \lnot q) \models \lnot p$</p></li><li><p>充分条件假言推理的有效形式是肯定前件式和否定后件式，而肯定后件式和否定前件式都是无效式</p></li></ul></li><li><p>必要条件假言推理</p><p>一个前提为必要条件假言命题</p><ul><li><p>否定前件必否定后件：$((p \ \Longleftarrow  \  q ) \land \lnot p) \models \lnot q$</p></li><li><p>肯定后件必肯定前件：$((p \ \Longleftarrow  \  q ) \land q) \models p$</p></li></ul></li><li><p>充分必要条件假言推理</p><p>前件是后件的充分条件，并且前件是后件的必要条件。</p><ul><li><p>肯定前件必肯定后件： $((p\iff q ) \land p) \models q $</p></li><li><p>否定前件必否定后件：$((p\iff q ) \land\lnot p) \models \lnot q$</p></li><li><p>肯定后件必肯定前件：$((p\iff q ) \land q) \models p$</p></li><li><p>否定后件必否定前件：$((p\iff q ) \land\lnot q) \models \lnot p$</p></li></ul></li></ul></li><li><p>假言易位推理</p><ul><li><p>假言易位推理是通过变换前提中的前后件的位置，推出一个假言命题作为结论的推理。</p></li><li><p>充分条件假言易位推理：$(p\implies q) \models(\lnot q \implies \lnot p))$</p></li><li><p>必要条件假言易位推理：$(p \ \Longleftarrow  \  q) \models(q\implies p)$</p></li><li><p>充分必要条件假言易位推理：$(p\iff q) \models(q\iff p)$</p></li></ul></li><li><p>假言联锁推理</p><p>纯假言推理</p><ul><li><p>充分条件假言连锁推理</p><p>以充分条件假言命题作前提和结论的推理。</p><ul><li><p>肯定式：$(p\implies q)\land (q\implies r) \models (p\implies r)$</p></li><li><p>否定式：$(p\implies q)\land (q\implies r) \models (\lnot r\implies \lnot p)$⟹¬p)</p></li></ul></li><li><p>必要条件假言连锁推理</p><p>以必要条件假言命题作前提。</p><ul><li><p>肯定式：$(p \ \Longleftarrow  \ q)\land (q \ \Longleftarrow  \ r) \models (p \ \Longleftarrow  \  r)$</p></li><li><p>否定式：$(p \ \Longleftarrow  \ q)\land (q \ \Longleftarrow  \ r) \models (\lnot r \ \Longleftarrow  \ \lnot p)$ </p></li></ul></li><li><p>混合条件假言联锁推理</p><p>以几种不同的假言命题做前提的假言连锁推理。</p><ul><li><p>$(p \iff q)\land (q \implies r) \models(p\implies r)$</p></li><li><p>$(p \iff q)\land (q  \ \Longleftarrow  \ r) \models(p \ \Longleftarrow  \ r)$</p></li></ul></li></ul></li></ul></li></ul></li><li><p>负命题及其推理</p><ul><li><p>定义</p><ul><li>负命题就是某个（简单或复合）命题的否定命题。<br>原命题为真，则其负命题为假；原命题为假，则其负命题为真。需要注意，它否定整个原命题，而非部分</li></ul></li><li><p>负命题推理#命题推理 </p><ul><li><p>简单命题的负命题及其推理</p><ul><li>$p\models\lnot \lnot p$<br>双否律</li></ul></li><li><p>复合命题的负命题及其推理</p><ul><li><p>联言命题的负命题及其推理</p><ul><li>$\lnot (p \land q) \models\lnot p \lor \lnot q$<br>德摩根律</li></ul></li><li><p>相容选言命题的负命题及其推理</p><ul><li>$\lnot (p \lor q) \models\lnot p \land\lnot q$</li></ul></li><li><p>不相容选言命题的负命题及其推理</p><ul><li>$\lnot (p \lor q) \models(\lnot p \land\lnot q)\lor( p \land q)$<br>实际上是这样的：$\lnot ((p \lor q)\land \lnot (p \land q)) \models(\lnot p \land\lnot q)\lor( p \land q)$</li></ul></li><li><p>充分条件假言命题的负命题及其推理</p><ul><li>$\lnot (p \implies q) \models (p \land \lnot q)$<br>实际上是这样的：$\lnot (\lnot p\lor  q) \models (p \land \lnot q)$</li></ul></li><li><p>必要条件假言命题的负命题及其推理</p><ul><li>$\lnot (p \ \Longleftarrow  \ q) \models (\lnot p \land  q)$<br>实际上是这样的：$\lnot (\lnot q\lor  p) \models (q \land \lnot p)$</li></ul></li><li><p>充分必要条件假言命题的负命题及其推理</p><ul><li>$\lnot (p \iff q)\models(p \land \lnot q) \lor (\lnot p \land q)$<br>实际上是这样的：$\lnot( (\lnot p\lor  q) \land(\lnot q\lor  p)) \models(p \land \lnot q) \lor (\lnot p \land q)$</li></ul></li></ul></li></ul></li></ul></li><li><p>复合命题的其他推理</p><ul><li><p>假言选言推理</p><ul><li><p>以充分条件假言命题和选言命题作为前提的推理</p></li><li><p>如果由两个假言命题和一个二肢的选言命题作为前提所构成的假言选言推理，叫二难推理。</p></li><li><p>如果由三个或四个假言命题和一个三肢或四肢的选言命题作为前提所构成的假言选言推理，分别叫三难推理或四难推理。<br>我们主要研究二难推理。它反映的是：只有两种客观情况供选择，但无论选择哪一种情况，其结论都是令人难以接受的，即处于“左右为难”的尴尬境地。</p></li><li><p>二难推理#命题推理 </p><ul><li><p>这种推理是在前提中肯定两个假言命题的前件，在结论中肯定其后件。（前提中的后件相同）</p></li><li><p>$((p\implies r)\land (q\implies r))\land (p \lor q)\models r$</p></li></ul></li></ul></li><li><p>假言联言推理#命题推理 </p><p>是由两个充分条件假言命题和一个联言命题作前提，推出另一个联言命题为结论的推理形式。</p><ul><li><p>肯定式</p><ul><li>$((p\implies q)\land(r\implies s))\land(p\land r)\models(q\land s)$</li></ul></li><li><p>否定式</p><ul><li>$((p\implies q)\land(r\implies s))\land(\lnot q\land \lnot s)\models(\lnot p\land \lnot r)$</li></ul></li></ul></li><li><p>反三段论</p><p>前提和结论都是假言型多重复合命题。</p><ul><li><p>反映某几种事物情况（条件）共同构成了另一个事物情况的充分条件，那么，当这一事物情况不出现时，就可以推出这几个条件中至少有一个不具备</p></li><li><p>$((p\land q)\implies r)\implies((p\land \lnot r)\implies \lnot q)$</p></li></ul></li><li><p>归谬推理</p><p>一种使用归谬法进行推理的推理形式</p><ul><li>$((p\implies q)\land(p\implies\lnot q))\models\lnot p$</li></ul></li></ul></li><li><p>逻辑联结词的优先级</p><ul><li><p>联结词$\lnot$,$\land$,$\lor$,$\implies$,$\iff$中，$\lnot$是一元联结词，其它都是连接两个命题的二元联结词</p></li><li><p>我们定义优先级$\lnot,[\land,\lor],\implies$,$\iff$</p></li><li>除非有括号，否则按照优先级从高到低，从左到右的次序结合<br>$\lnot p\lor q$等同于$((\lnot p)\lor q)$​</li></ul></li><li><p>重言式</p><ul><li>真值形式：由真值联结词和命题变项构成的形式结构，也称之为公式</li><li>真值联结词</li><li><p>五种基本的真值形式</p><ul><li><p>$\lnot p$</p></li><li><p>$p\land q$</p></li><li><p>$p\lor q$</p></li><li><p>$p\implies q$</p></li><li><p>$p \iff q$</p></li></ul></li><li>真值表：表示公式中原子的真假和公式真假值之间的关系</li><li><p>重言式：重言的真值形式的简称，无论其中的命题变项取何种真值，该真值形式的值都是“真”，因此，又叫永真式。</p><ul><li><p>同一律：$p\implies p$</p></li><li><p>矛盾律：$\lnot (p \land \lnot p)$</p></li><li><p>排中律：$p \lor \lnot p$</p></li></ul></li><li>永假式：无论其中的命题变项取何种真值，该真值形式的值都是假的。</li><li>可满足式：真值形式的值至少在某种情况下是真的。</li><li><p>常见的重言式#命题推理 </p><ul><li>同一律：$p\implies p$</li><li>矛盾律：$\lnot(p\land \lnot p)$</li><li>排中律：$p\lor \lnot p$</li><li>分离律：$(p \implies q)\land p \implies q$</li><li>否后律：$(p \implies q)\land \lnot q \implies \lnot p$</li><li>析否律：$(p \lor q) \land\lnot q \implies p$</li><li>合取简化律：$(p \land q)\implies p$</li><li>析取引入律：$p\implies p \lor q$</li><li>幂等律：<ul><li>$p \lor p \iff p$</li><li>$p \land p\iff p$</li></ul></li><li>假言易位律：$(p\implies q)\iff(\lnot q \implies \lnot p)$</li><li>德·摩根律：<ul><li>$\lnot(p\land q)\iff(\lnot p \lor\lnot q)) $</li><li>$\lnot(p\lor q)\iff(\lnot p \land\lnot q))$</li></ul></li><li>交换律：<ul><li>$ p\land q\iff q\land p $</li><li>$ p \lor q \iff q\lor p$</li></ul></li><li>双否律： $\lnot \lnot p \iff p$</li><li>结合律：<ul><li>$ (p\land q)\land r \iff p \land (q \land r)$</li><li>$(p\lor q)\lor r \iff p \lor (q \lor r)$</li></ul></li><li>分配律：<ul><li>$p \land (q \lor r)\iff(p\land q)\lor (p \land r)$</li><li>$p \lor  (q \land r)\iff(p\lor q)\land (p \lor r)$</li></ul></li><li>蕴析律：$(p\implies q)\iff (\lnot p \lor q)$</li><li>等值律：<ul><li>$(p\iff q)\iff (p\implies q)\land (q\implies p)  $</li><li>$(p\iff q)\iff (p \land q)\lor (\lnot p \land \lnot q)$</li></ul></li></ul></li><li><p>替换、代入、子公式</p><ul><li><p>代入原理</p><ul><li>将重言式A中的某个命题变元p的所有出现都代换为命题公式B，得到的命题公式依然是重言式</li></ul></li><li><p>替换原理</p><ul><li>将命题公式A中的子公式C的部分出现替换为和C逻辑等价的公式D，得到的新命题公式B，则A和B逻辑等价</li></ul></li></ul></li></ul></li><li><p>命题真值的判定方法</p><ul><li><p>真值表法</p></li><li><p>归谬赋值法</p><ul><li><p>为了证明一个蕴涵式是重言式，必须证明它不可能前件真而后件假。</p></li><li><p>如果在这样的赋值过程中出现了矛盾赋值，即必须给同一个命题变项既赋“真”值又赋“假”值，那么，原假设不成立，因而该蕴涵式是重言式。</p></li><li><p>反之，如果不出现矛盾赋值，则说明存在一组赋值满足前件真而后件假，因而不是重言式。</p></li></ul></li><li><p>命题的自然推理</p><ul><li><p>确定一些推理规则，这些规则具有保真性。即依据这些规则，从真前提只会推出真结论。因此，从所要判定的推理的前提出发，如果依据这些推理规则，能形式地推出预期的结论，这就说明该推理有效。</p></li><li><p>自然推理的主要规则#命题推理 #自然推理</p><ul><li><p>$A\models A$</p></li><li><p>$A,A\implies B\models B$    蕴涵消去规则$\implies _-  $</p></li><li><p>$[A]…B\models A\implies B$   蕴涵引入规则$\implies _+$</p></li><li><p>$A,B\models A\land B$  合取引入规则$\land _+$</p></li><li><p>$A \land B \models A(B)$   合取消去规则$\land_-$</p></li><li><p>$A\models A\lor B$   析取引入规则$\lor _+$</p></li><li><p>$A\lor B,[A]…C,[B]…C \models C$   析取消去规则$\lor _-$</p></li><li><p>$[A]…B\land \lnot B \models \lnot A$   否定引入规则$\lnot _+$</p></li><li><p>$\lnot\lnot A \models A$   否定消去规则$\lnot _-$</p></li><li><p>$[A]…B,[B]…A\models A\iff B$   等值引入规则$\iff _+$  </p></li></ul></li><li><p>蕴涵命题的证明思路$P^N$推演</p><ul><li><p>先假设整个蕴涵命题的前件</p></li><li><p>如果该前件是一个蕴涵式，则继续假设此次一层级蕴涵式的前件，</p></li><li><p>如后件是一个蕴涵式，则继续假设该后件的前件，依此类推</p></li><li><p>每增加一个假设就把该假设向后缩进一个单位。</p></li><li><p>推理规则：自然推理的主要规则#命题推理 #自然推理</p></li><li><p>试证明：$(A\implies (B\implies C))\implies ((A\implies B)\implies (A \implies C)) $</p><ul><li><p>证明：</p></li><li><p>(1)$A\implies (B\implies C)$                        假设</p><ul><li><p>(2)$A\implies B$                                          假设</p><ul><li><p>(3)$A$                                                       假设</p><ul><li><p>(4)$B$                                              (2)(3)$\implies_-$</p></li><li><p>(5)$B\implies C$                         (1)(3)$\implies_- $ </p></li><li><p>(6)$C$                                              (4)(5)$\implies_- $ </p></li></ul></li><li><p>(7)$A\implies C$                               (3)(6)$\implies_+ $ </p></li></ul></li><li><p>(8)$(A\implies B)\implies (A \implies C)$</p></li><li><p>​                                                                        (2)(7)$\implies_+ $</p></li></ul></li><li><p>(9)$(A\implies (B\implies C))\implies ((A\implies B)\implies (A \implies C))$</p></li><li><p>​                                                                        (1)(9)$\implies_+ $</p></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ul><li><p>关系命题</p><ul><li><p>定义</p><ul><li>反映事物与事物之间关系或性质的命题。</li></ul></li><li><p>结构</p><ul><li><p>主项：关系命题中表示某种关系的承担者的那些词项。</p></li><li><p>谓项：关系命题中表示对象之间的关系的那个词项。</p></li><li><p>量项：关系命题中表示关系者数量的那个词项。</p></li></ul></li><li><p>关系命题的符号化</p><ul><li><p>甲和乙是一对父子</p><ul><li><p>$aRb$              (中置法)</p></li><li><p>$R(a,b)$       (前置法)</p></li><li><p>$abR$              (后置法)</p></li></ul></li><li><p>有的甲班学生比有的乙班学生学习刻苦</p><ul><li>$\exists x \exists y (F (x)\land G(y)\land R (x, y))$</li></ul></li><li><p>所有甲班学生比所有乙班学生学习刻苦</p><ul><li>$\forall x \forall y (F (x)\implies (G (y)  \implies R (x, y)))$</li></ul></li></ul></li><li><p>二元关系命题的种类：</p><ul><li><p>单称-单称命题：xRy</p></li><li><p>单称-特称命题：xR有些y</p></li><li><p>单称-全称命题：xR所有y</p></li><li><p>特称-单称命题：有些xRy</p></li><li><p>特称-特称命题：有些xR有些y</p></li><li><p>特称-全称命题：有些xR所有y</p></li><li><p>全称-单称命题：所有xRy</p></li><li><p>全称-特称命题：所有xR有些y</p></li><li><p>全称-全称命题：所有xR所有y</p></li><li><p>单称-单称命题被称为“非量化关系命题”，其余的都被叫做“量化关系命题”。</p></li></ul></li><li><p>关系的逻辑特性</p><ul><li><p>关系的对称性问题</p><p>当一个对象与另一个对象具有某种关系时，另一个对象与这个对象是否也具有这种关系的问题</p><ul><li><p>对称性</p></li><li><p>反对称性</p></li><li><p>非对称性</p></li></ul></li><li><p>关系的传递性问题</p><p>当一个对象甲与另一个对象乙具有某种关系，乙与第三个对象丙也具有此种关系时，对象甲与对象丙是否也具有此种关系的问题。</p><ul><li><p>传递性</p></li><li><p>反传递性</p></li><li><p>非传递性</p></li></ul></li><li><p>关系的自反性问题</p><p>一个对象与自身具有某种关系<br>​</p><ul><li><p>自反性</p></li><li><p>反自反性</p></li><li><p>非自反性</p></li></ul></li></ul></li><li><p>关系推理</p><ul><li><p>关系推理是前提中至少一个是关系命题的推理，它是根据前提中“关系”的逻辑特性进行推演的。</p></li><li><p>纯关系推理</p><ul><li><p>对称性关系推理<br>根据前提中的关系具有对称性而理进行的推</p></li><li><p>反称性关系推理</p></li><li><p>传递性关系推理</p><ul><li>通过传递关系的推理包括n个关系命题，其中的关系都是相同的传递关系，第一个前提与结论具有相同的前关系项，第n-1个前提与结论具有相同的后关系项，同时，每个前提的后关系项都是下一个前提的前关系项</li></ul></li></ul></li></ul></li></ul></li><li><p>第四章</p><ul><li><p>直言命题及其直接推理</p><ul><li><p>性质命题概述</p><ul><li><p>性质命题是直接陈述对象具有或不具有某属性的命题，因此，又叫直言命题。</p></li><li><p>标准式直言命题的构成</p><ul><li>标准式直言命题一般由四个部分组成：首先是量词，其次是主项，再次是联项，最后是谓项。可以记为：量项＋主项＋联项＋谓项。</li></ul></li><li><p>命题的质：针对命题的联项而言的，有肯定和否定之分。</p><ul><li><p>肯定：不管是全部地还是部分地，那么，它的质就是肯定的。因此全称肯定命题和特称肯定命题的质都是肯定的。简写为A和I，就分别来自于拉丁文“<strong><em>A</em></strong>Iff<strong><em>I</em></strong>rmo”，意思是“我肯定”</p></li><li><p>否定：全称否定命题和特称否定命题的质都是否定的。简写为E和O，它们分别来自于拉丁文“n<strong><em>E</em></strong>g<strong><em>O</em></strong>”，意思是“我否定”</p></li></ul></li><li><p>命题的量：针对命题的主项而言的，有全称、特称和单称之分</p></li><li><p>四种基本的性质命题形式</p><ul><li><p>SAP：全称肯定</p><p>所有S都是P</p></li><li><p>SIP：特称肯定</p><p>有S是P</p></li><li><p>SEP：全称否定</p><p>所有S都不是P</p></li><li><p>SOP：特称否定</p><p>有S不是P</p></li></ul></li><li><p>A、E、I、O四种命题之间的真假关系</p><ul><li><p>一个性质命题所表达的内容实际上是其主谓项所反映对象的集合之间的关系。</p></li><li><p>两个概念的外延之间的关系有五种情况。</p></li><li><p>同一、包含、包含于、交叉、全异</p></li><li><p>判断一个性质命题的真假就看命题的主谓项的外延与这五种情况当中的哪一（些）个符合，在相符合的情况该命题是真的。</p></li><li><p>譬如：SAP为真就是说S的全部外延都在P的外延之中。从概念的外延之间的关系来看，在全同和真包含于情形下满足这一要求，其他情形都不满足。因此，在S和P全同，或S真包含于P时， SAP为真。</p></li><li><p>A：S和P是全同关系、真包含于关系时为真；其他情形下为假。<br>E：S和P是全异关系时为真；其他情形下为假。<br>I：S和P是全同、真包含、真包含于、交叉关系时为真；其余情形下为假。<br>O：S和P是真包含、交叉和全异关系时为真；其余情形下为假。</p></li></ul></li><li><p>四种基本性质命题的周延性</p><ul><li><p>周延性指的是在某形式的性质命题中，该命题对主项或谓项外延数量的断定情况。</p></li><li><p>如果一个性质命题涉及了某个词项（主项或谓项）所指称的类的全部对象，那么，我们就说该命题使得该词项是周延的。否则，该词项是不周延的。</p></li><li><p>全称时主项周延，否定时谓项周延</p></li></ul></li><li><p>四种基本性质命题之间的真假关系</p><ul><li><p>A和E：两者不可同真，但可以同假。（反对关系）</p></li><li><p>A和I：A真则I真，A假时I可真可假；但I真时A可真可假，而I假时则A必假。（差等关系）</p></li><li><p>A和O：两者不可同真也不可同假。 （矛盾关系）</p></li><li><p>E和I：两者不可同真也不可同假。（矛盾关系）</p></li><li><p>E和O：E真则O真，E假时O可真可假；O真时，E可真可假，O假时则E必假。（差等关系）</p></li><li><p>I和O：两者可以同真但不可同假。（下反对关系）</p></li><li><p>对当方阵</p></li></ul></li></ul></li><li><p>命题变形推理#命题推理 </p><ul><li><p>定义</p><ul><li>就是通过改变性质命题的联项，或者改变性质命题主谓项的位置，或既改变联项又改变主谓项的位置，从而得出一个新命题作为结论的推理。</li></ul></li><li><p>换质法：通过改变命题的质来进行推理的方法。</p><ul><li><p>规则：</p><ul><li><p>只改变作为前提的命题的质</p></li><li><p>结论中的谓项是前提中的谓项的矛盾概念</p></li></ul></li><li><p>$SAP\implies SE\bar{P}$</p></li><li>$SEP\implies SA\bar{P}$</li><li>$SIP\implies SO\bar{P}$</li><li>$ SOP\implies SI\bar{P}$</li></ul></li><li><p>换位法：通过改变命题主项与谓项的位置来得出一个新命题的推理方法。</p><ul><li><p>规则：</p><ul><li><p>只改变前提中主谓项的位置，命题的质不变。</p></li><li><p>原命题中不周延的项结论中也不能周延。</p></li></ul></li></ul></li><li><p>换位质法：</p><ul><li><p>规则：</p><ul><li><p>把换质法和换位法结合起来交替运用的命题变形方法。</p></li><li><p>通常先换质，然后进行换位；换质和换位法交替运用。</p></li><li><p>分别遵守换质法和换位法的规则。</p></li><li><p>$SAP\implies SE\bar{P}\implies \bar{P}ES\implies \bar{P}A\bar{S}$</p></li><li>$SEP\implies SA\bar{P}\implies \bar{P}IS\implies \bar{P}O\bar{S}$</li><li>$SOP\implies SI\bar{P}\implies \bar{P}IS$</li><li>$SIP\implies PIS \implies PO\bar{S}\text{（换质位无效。不能先换质，但可先换位）}$</li></ul></li></ul></li></ul></li><li><p>对当关系推理#命题推理 </p><ul><li><p>根据矛盾关系进行的直接推理</p></li><li><p>根据反对关系进行的推理</p></li><li><p>根据下反对关系的推理</p></li><li><p>根据差等关系进行的推理</p></li></ul></li></ul></li><li><p>三段论</p><ul><li><p>直言三段论是由三个直言命题构成的一种推理形式，并满足下面三个条件：</p><ul><li><p>这三个直言命题以且只以三个不同的词项作主项和谓项。</p></li><li><p>每个词项在任意一个命题中至多出现一次，但在这三个直言命题中共出现两次。</p></li><li><p>以其中的两个命题为前提，以第三个命题为结论。</p></li></ul></li><li><p>前提中出现两次，该词项称为中项，常用M表示；结论中的主项称为小项，常用S表示；结论中的谓项称为大项，常用P表示。包含大项的前提叫做大前提；包含小项的前提叫做小前提。</p></li><li><p>三段论的规则</p><ul><li><p>5条基本规则</p><ul><li><p>规则1 ：三段论有且只有三个项。<br>违反这一规则的错误称为“四项谬误”</p></li><li><p>规则2：中项至少在一个前提中周延。<br>违反这条规则的错误称为“中项不周延谬误”</p></li><li><p>规则3：  前提中不周延的项在结论中也不得周延。<br>违反这一规则的错误称为“大项不当周延”（大项扩张）或“小项不当周延”（小项扩张）。</p></li><li><p>规则4 ：两否定前提推不出结论。<br>违反这一规则的错误称为“排斥前提谬误”</p></li><li><p>规则5 ：前提有一否定，当且仅当结论否定。<br>违反这一规则的错误称为“从否定推肯定谬误”</p></li><li><p>（规则6：两个全称前提得不出特称结论）<br>违反这一规则的错误称为“存在谬误”。属于布尔解释的设定</p></li></ul></li><li><p>2条导出规则</p><ul><li><p>规则6 ：两前提不能都是特称的。</p><ul><li><p>II：中项不周延【规则2：中项至少在一个前提中周延。】</p></li><li><p>IO：前提中只有一个项周延，必是中项。而结论是否定的【规则5 ：前提有一否定，当且仅当结论否定。】，大项周延，违反“前提中不周延的项结论中也不得周延”【规则3：  前提中不周延的项在结论中也不得周延。】</p></li><li><p>OO：两否定前提推不出结论。【规则4 ：两否定前提推不出结论。】</p></li></ul></li><li><p>规则7 ：如果前提有一特称，则结论特称。</p><ul><li><p>AI：两个前提肯定，而其中有一个是特称，于是只能中项是全称命题的主项，其余的主谓项都不能周延，因此，结论只能是特称，否则，违反【规则3：  前提中不周延的项在结论中也不得周延。】。</p></li><li><p>EI：前提中有一个是否定命题，所以结论必定是否定命题，则大项在结论中周延。根据【规则3：  前提中不周延的项在结论中也不得周延。】，大项在前提中也应该周延。而EI两个前提表明前提中只有两个项周延，其中大项和中项【规则2：中项至少在一个前提中周延。】都应该周延，所以，小项不周延，因此小项在结论中也不周延，于是结论只能是特称。</p></li><li><p>AO：道理同上。</p></li><li><p>EO：违反【规则4 ：两否定前提推不出结论。】</p></li></ul></li></ul></li></ul></li><li><p>三段论的格</p><ul><li><p>格的种类</p><ul><li><p>第一格</p><ul><li>中项M在大前提中是主项，在小前提中是谓项。<br>凡绿色植物都是有光合作用的     M     P<br>​柳树是绿色植物                                   S     M<br>所以，柳树是有光合作用的。     S     P</li></ul></li><li><p>第二格</p><ul><li>中项M在两个前提中都是谓项。<br>凡马克思主义者都是唯物主义者    P     M<br>某甲不是唯物主义者                             S     M<br>​ 所以，某人不是马克思主义者。   S     P</li></ul></li><li><p>第三格</p><ul><li>中项M在两个前提中都是主项。<br>所有大学教师都是知识分子                  M          P<br>有的大学教师是中共党员                       M          S<br>所以，有的中共党员是知识分子。   S          P      </li></ul></li><li><p>第四格</p><ul><li>中项M在大前提中是谓项，在小前提中是主项。<br>所有物理学家都是科学家                P           M<br>所有科学家都不是文盲                     M           S<br>所以，有的文盲不是物理学家。  S           P       </li></ul></li></ul></li><li><p>格的特殊规则</p><ul><li><p>第一格的特殊规则</p><ul><li><p>小前提必须是肯定命题</p><ul><li>如果小前提是否定命题，大前提必然肯定，否则推不出结论；结论必定否定，于是大项在结论中周延，则大项必须在大前提中周延。如果大项不周延，则违反【规则3：  前提中不周延的项在结论中也不得周延。】；如果大项在前提中周延，由于第一格中大项是大前提的谓项，大前提必须否定，这样就违反规则【规则4 ：两否定前提推不出结论。】</li></ul></li><li><p>大前提必须是全称命题</p><ul><li>中项不周延，所以根据【规则2：中项至少在一个前提中周延。】，大前提必须是全称命题中项才能周延。</li></ul></li></ul></li><li><p>第二格的特殊规则</p><ul><li><p>两前提中必有一个是否定命题</p><ul><li>如果都是肯定命题，由于第二格中，中项是大小前提的谓项，这样就违反了【规则2：中项至少在一个前提中周延。】。</li></ul></li><li><p>大前提必须是全称命题</p><ul><li>，结论必为否定，则大项在结论中周延，而大项在第二格中是大前提的主项，大项在大前提中周延就要求大前提必须是全称命题。否则犯“大项扩张”的错误【规则3：  前提中不周延的项在结论中也不得周延。】</li></ul></li></ul></li><li><p>第三格的特殊规则</p><ul><li><p>小前提必须肯定</p><ul><li>如小前提否定，结论必定否定【规则5 ：前提有一否定，当且仅当结论否定。】，大项在结论中周延；而大项在第三格中是大前提的谓项，大前提必须是否定，否则犯“大项扩张”错误【规则3：  前提中不周延的项在结论中也不得周延。】；如果大前提否定，则两否定前提推不出结论【规则4 ：两否定前提推不出结论。】。</li></ul></li><li><p>结论必须是特称</p><ul><li>小项在第三格中是小前提的谓项，据【小前提必须肯定】，所以，它是在结论中也不得周延，否则会犯“小项扩张”的错误【规则3：  前提中不周延的项在结论中也不得周延。】；而小项在结论中是主项，所以结论必定是特称。</li></ul></li></ul></li><li><p>第四格的特殊规则</p><ul><li><p>如果两个前提中有一个是否定命题，那么，大前提必是全称命题。</p><ul><li>一个前提否定，则结论必定否定【规则5 ：前提有一否定，当且仅当结论否定。】，于是，大项在结论中周延；大项在第四格中是大前提的主项，它要周延就要求大前提必须全称。否则，就会犯“大项扩张”错误【规则3：  前提中不周延的项在结论中也不得周延。】。</li></ul></li><li><p>如大前提肯定，则小前提全称。</p><ul><li>在第四格中，中项是大前提的谓项和小前提的主项，如大前提肯定，则中项在大前提中不周延，因此，它必须在小前提中周延，所以小前提必须全称。否则犯“中项两次不周延”的错误【规则2：中项至少在一个前提中周延。】。</li></ul></li><li><p>如果小前提是肯定命题，结论必须是特称命题。</p><ul><li>在第四格中，小项是小前提的谓项，如小前提肯定，则小项不周延；如结论不是特称，则小项在结论中周延，犯了“小项不当周延”的错误【规则3：  前提中不周延的项在结论中也不得周延。】。所以，结论必须特称。</li></ul></li><li><p>任何一个前提都不能是特称否定。</p><ul><li><p>大前提特称否定，第四格中，大项在大前提是主项，不周延。【如果两个前提中有一个是否定命题，那么，大前提必是全称命题。】</p></li><li><p>小前提特称否定，第四格中，中项在小前提中是主项，不周延；但中项必须周延一次【规则2：中项至少在一个前提中周延。】，它是大前提的谓项，因此必须大前提否定；而两否定前提推不出结论【规则4 ：两否定前提推不出结论。】，因此，小前提不能特称否定。</p></li><li><p>大小前提都是特称否定：两否定前提推不出结论，【规则4 ：两否定前提推不出结论。】得证。</p></li></ul></li><li><p>结论不能是全称肯定命题</p><ul><li>结论全肯则小项在结论中周延，第四格中，小项在小前提中是谓项，要周延就必须小前提否定【规则3：  前提中不周延的项在结论中也不得周延。】，而前提中有一个否定，结论必定否定【规则5 ：前提有一否定，当且仅当结论否定。】。</li></ul></li></ul></li></ul></li><li><p>格的在认识方面的特点</p><ul><li><p>第一格在认识方面的特点是：把普遍原理应用于特殊场合。</p><p>（完善的格）</p><ul><li>第一格的一般原则：如果某类的一切分子都具有或缺乏某种性质，那么属于该类的任一对象也具有或缺乏这种性质。（“所有和没有的原则”或“全与零的原则”）</li></ul></li><li><p>第二格在认识方面的作用是确立事物之间的区别</p><ul><li>一般原则：如果某类的分子都具有或缺乏某种性质，那么任何不具有或不缺乏这种性质的对象就不属于该类。（“差异原则”）</li></ul></li><li><p>第三格在认识方面的作用是用一部分事物的例外的情形来否定一条普遍论断。</p><ul><li>一般原则：如果任何属于某类的对象具有或缺乏某种性质，那么该类有些分子具有或缺乏这种性质，并非该类的一切分子都缺乏或具有这种性质。（结论是肯定的，就叫“例证原则”；结论是否定的，就叫“例外原则”。）</li></ul></li><li><p>第四格不自然。</p><ul><li>很少被人使用</li></ul></li><li><p>总结：</p><ul><li><p>第一格是证明和反驳各种类型的传统直言命题的方法。（审判格）</p></li><li><p>第二格是证明否定命题和反驳肯定命题的方法。（区别格）</p></li><li><p>第三格是证明特称命题和反驳全称命题的方法。（反驳格）</p></li></ul></li></ul></li></ul></li><li><p>三段论的式</p><ul><li><p>定义</p><ul><li><p>由A、E、I、O四种命题在两个前提和一个结论中的不同组合而形成的不同的三段论形式。</p></li><li><p>这样的组合每一个格共有4×4×4 ＝644×4×4＝644×4×4 ＝644×4×4＝64种。</p></li><li><p>同样，以其他形式的命题为大前提也有16种，共16×4。</p></li><li><p>四个格共有64×4＝256个式。</p></li></ul></li><li><p>有效式</p><ul><li><p>第一格的有效式：</p><ul><li>AAA，AII，EAE，EIO，[AAI]，[EAO]</li></ul></li><li><p>第二格的有效式：</p><ul><li>AEE，EAE，EIO，AOO，[AEO]，[EAO]</li></ul></li><li><p>第三格的有效式：</p><ul><li>AAI，AII，EAO，EIO，IAI，OAO</li></ul></li><li><p>第四格的有效式：</p><ul><li>AAI，AEE，EAO，EIO，IAI，[AEO]</li></ul></li><li><p>说明</p><ul><li><p>括号里的是弱式，即本来可以得出全称的，却得出了特称。去掉五个弱式，还剩下19个有效式。</p></li><li><p>同一个形式的三段论在不同的格里有效性是不一样的。譬如：AAA在第一格是有效式，而它在第二格是无效的。因为中项一次也没周延。</p></li></ul></li></ul></li></ul></li><li><p>用欧拉图解判定三段论的有效性</p></li><li><p>三段论的省略式</p><ul><li><p>形式</p><ul><li><p>省略大前提</p></li><li><p>省略小前提</p></li><li><p>省略结论</p></li></ul></li><li><p>逻辑分析</p><ul><li><p>一个省略式可能有不同的补全方式</p><ul><li><p>首先，确定结论是否被省略；</p></li><li><p>其次，当结论没有被省略时，根据结论就可以确定大、小项。 如果大项在省略三段论的前提中没有出现，说明省略的是大前提；如果小项在省略三段论的前提中没有出现，那么省略的就是小前提。</p></li><li><p>最后，把省略部分补充进去，还原为一个完整的三段论。</p></li></ul></li></ul></li></ul></li><li><p>复合三段论</p></li></ul></li></ul><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ul><li><p>概述</p><ul><li>谓词逻辑是研究谓词命题和这类命题之间推理关系的科学。又称一阶逻辑，数理逻辑的分支学科</li></ul></li><li><p>原子命题的内部结构</p><ul><li><p>结构</p><ul><li><p>谓词</p><ul><li><p>在谓词逻辑中，把刻画个体属性的词项通常称作谓词。</p></li><li><p>一个谓词可以是一个形容词、名词或者动词</p></li><li><p>谓词：它表示属性（性质或关系），通常用大写字母$F,G,H$等表示。（谓词常项、谓词变项）</p></li><li><p>一元谓词：刻画一个个体的属性的谓词。如$F(a)$中的$F$。</p></li><li><p>二元谓词：刻画两个个体相互关系的谓词。譬如，$H(b, c)$中的$H$</p></li><li><p>一般地，刻画n个个体相互关系的谓词叫n元谓词。</p></li><li><p>n个个体具有某种属性，可以记为$F（x_1, … , x_n）$称为谓词$F$的主目。</p></li></ul></li><li><p>个体词</p><ul><li><p>在谓词逻辑中，通常把指称某特定个体的词项叫个体词</p></li><li><p>个体常项：表示一个确定的个体，通常用$a, b, c$等表示。</p></li><li><p>个体变项：它表示某个个体，但并不确定是哪一个具体的个体，通常用$x, y, z$等表示。</p></li></ul></li><li><p>量词</p><ul><li><p>$F(a)$是命题，它有真假；$F(x)$不是命题。</p></li><li><p>使$F(x)$成为命题的途径有两种</p><ul><li><p>代入:$F(a), F(b)…$</p></li><li><p>量化:$\forall xF(x),\exists xF(x)$</p></li></ul></li><li><p>全称量词断定所有个体都具有相应谓词所表达的属性或关系。通常用符号$\forall x$表示，其含义是对任何个体（事物）来说。</p></li><li><p>存在量词断定存在个体具有相应谓词所表达的属性或关系。通常用符号$\exists x$表示。</p></li></ul></li><li><p>联结词</p></li></ul></li><li><p>个体域</p><ul><li><p>定义：个体变项的取值范围。</p></li><li><p>个体域可根据需要作特殊限制，如不作特殊限制，个体域指全域，即所有能被思考的对象所组成的域。</p></li><li><p>请注意： $F(x), \exists xF(x), F(a)$三者表达的不同含义。</p></li></ul></li><li><p>量词的辖域</p><ul><li><p>在一个谓词逻辑表达式中，量词的约束范围叫量词的辖域</p></li><li><p>约定：紧靠量词的括号内的表达式是该量词的辖域，括号外的不是；如果紧靠量词没有括号，那么紧靠量词的不包含联结词的最短表达式是该量词的辖域，其他则不是。</p></li></ul></li><li><p>约束个体变项</p><ul><li>在相关量词的辖域中出现的个体变项，称为该量词约束的个体变项</li></ul></li><li><p>自由个体变项</p><ul><li>不被量词约束的个体变项称为自由个体变项</li></ul></li><li><p>一阶谓词逻辑</p><ul><li><p>谓词是表达对象的性质和关系的。对象的性质和关系统称为属性。</p><ul><li>不仅个体对象有属性，而且，属性也有属性。<ul><li>如：“同乡”具有传递性；黑色是庄重的。</li></ul></li></ul></li><li><p>一阶谓词就是只刻画事物或个体的属性，而不刻画属性的属性的谓词。在一阶谓词的主目中，只出现个体变项而不出现谓词变项。</p></li><li><p>如果对属性进行量化，即当我们说存在某属性，它具有某性质（或者，所有属性具有某性质）时，我们就进入了高阶逻辑。</p></li><li><p>一阶谓词逻辑：就是其中的谓词都是一阶谓词，其中的量词只刻画个体变项的量化。</p></li></ul></li></ul></li><li><p>谓词逻辑层次上自然语言的符号化</p><ul><li><p>传统直言命题的符号化</p><ul><li><p>$SAP,\ \forall x(T(x)\implies D(x))$</p></li><li><p>$SIP,\ \ \exists x(T(x)\land D(x))$</p></li><li><p>$SEP,\ \ \forall x(T(x)\implies \lnot D(x))$</p></li><li><p>$SOP,\ \ \exists x(T(x)\land \lnot D(x))$</p></li></ul></li><li><p>原子命题的符号化</p><ul><li>重叠量化式：包括量词的表达式称为量化式；在一个原子命题的量化式中，如果有两个或两个以上的量词出现，称为重叠量化式。</li></ul></li><li><p>复合命题的符号化</p></li><li><p>推理的符号化</p></li></ul></li><li><p>谓词逻辑的命题形式及其判定</p><ul><li><p>命题形式：包含变项的符号表达式。有时简称公式。</p></li><li><p>变项：命题变项、谓词变项、自由个体变项等。其中约束个体变项不是变项。</p></li><li><p>常项：命题常项、谓词常项、个体常项、逻辑常项（联结词）。</p></li><li><p>真值形式</p></li><li><p>量项的理解，命题形式解释的构造</p></li><li><p>命题形式的解释</p><ul><li><p>解释</p><ul><li>从一个命题形式得到命题的一个基本方法。命题形式的一个解释就是用一组常项分别取代命题形式中所有相应变项</li></ul></li><li><p>真值解释</p><ul><li>对真值形式中的命题变项不用具体命题（命题常项）代替，而是赋以真值，因此，又叫“真值赋值”</li></ul></li><li><p>命题形式的类型</p><ul><li><p>普遍有效式</p><ul><li>在所有解释下得到的命题都是真命题。</li></ul></li><li><p>可满足式</p><ul><li>至少在一种解释下能得到真命题。</li></ul></li><li><p>不可满足式</p><ul><li>如果在任何一种解释下都不能得到真命题。</li></ul></li><li><p>有限个体域中，普遍有效式的判定可以归约为命题逻辑中重言式的判定问题。即将谓词逻辑中的命题形式等值地转换为命题逻辑中的真值形式。</p><ul><li><p>一个全称量化命题形式转换为一个相当于K个命题的合取式。</p></li><li><p>一个存在量化命题形式转换为一个相当于K个命题的析取式。</p></li><li><p>一个F（x）式的命题形式可转换为K个F（a）式。</p></li></ul></li></ul></li></ul></li></ul></li><li><p>谓词逻辑的自然推理</p><ul><li><p>命题逻辑自然推理的扩充</p></li><li><p>增加了和量词相关的规则#命题推理</p><ul><li><p>全称量词消去规则 $\forall _-$</p><p>全称指定（US）</p><ul><li><p>规则</p><ul><li><p>$\cfrac{\forall xF(x)} {F(y)}(US)$</p></li><li><p>$\cfrac{\forall xF(x)} {F(c)}(US)$</p></li></ul></li><li><p>例子</p><ul><li><p>$\forall x \forall yP(x,y)\models \forall yP(x,y)$</p><ul><li>不能替换为公式中的约束出现</li></ul></li><li><p>$\forall xP(x)\implies Q\;\cancel{\models}\;P(x)\implies Q$</p><ul><li>量词的辖域是整个公式</li></ul></li></ul></li><li><p>注意</p><ul><li><p>不能替换为公式中的约束出现</p></li><li><p>量词的辖域是整个公式</p></li></ul></li></ul></li><li><p>全称量词引入规则 $\forall _+$</p><p>全称推广（UG）</p><ul><li><p>规则</p><ul><li>$\cfrac{F(x)} {\forall xF(x)}(UG)$</li></ul></li><li><p>例子</p><ul><li><p>$P(x,a)\models \forall xP(x,a)$</p></li><li><p>$P(x)\implies\exists yQ(y)\;\cancel\models \;\forall xP(x)\implies\exists yQ(y)$</p><ul><li>量词的辖域是整个公式</li></ul></li><li><p>$P(x,a)\;\cancel\models \;\forall yP(x,y)$</p><ul><li>不能替换常量（约束变量）</li></ul></li></ul></li><li><p>注意</p><ul><li><p>不能替换为公式中的约束出现</p></li><li><p>量词的辖域是整个公式</p></li><li><p>不能替换常量（约束变量）</p></li></ul></li></ul></li><li><p>存在量词消去规则 $\exists_-$</p><p>特称指定（ES）</p><ul><li><p>规则</p><ul><li>$\cfrac{\exists xF(x)} {F(c)}(ES)$</li></ul></li><li><p>例子</p><ul><li><p>$\exists x \exists yP(x,y)\models \exists yP(a,y)$</p></li><li><p>$\exists xP(x,a)\;\cancel\models \;P(a,a)$</p><ul><li>要替换为新引入的常量</li></ul></li><li><p>$\exists xP(x)\implies\exists yQ(y)\;\cancel\models \;P(a)\implies\exists yQ(y)$</p><ul><li>量词的辖域是整个公式</li></ul></li></ul></li><li><p>注意</p><ul><li><p>要替换为新引入的常量</p></li><li><p>量词的辖域是整个公式</p></li></ul></li></ul></li><li><p>存在量词引入规则 $\exists_+$</p><p>特称推广（EG）</p><ul><li><p>规则</p><ul><li><p>$\cfrac{F(c)} {\exists yF(y)}(EG)$</p></li><li><p>$\cfrac{F(x)} {\exists yF(y)}(EG)$</p></li></ul></li><li><p>例子</p><ul><li><p>$\exists x P(x,a)\models \exists y\exists xP(x,y)$</p></li><li><p>$\exists xP(x,a)\;\cancel\models \;\exists x\exists xP(x,x)$</p><ul><li>不能替换为公式中的约束出现</li></ul></li><li><p>$P(a)\implies\exists yQ(y)\;\cancel\models \;\exists xP(x)\implies\exists yQ(y)$</p><ul><li>量词的辖域是整个公式</li></ul></li><li><p>一个特殊的例子</p><ul><li><p>$\forall x\exists yF(x,y)\qquad\qquad\qquad(P)$</p></li><li><p>$\exists yF(x,y)\qquad\qquad\qquad\quad\,(US)$</p></li><li><p>$F(x,c_x)\qquad\qquad\qquad\quad\;\;\;(ES)$</p></li><li><p>$\forall xF(x,c_x)\qquad\qquad\qquad\;\;\,(UG)$</p></li><li><p>$\exists y\forall xF(x,y)\qquad\qquad\qquad(EG)$</p></li></ul></li><li><p>$\exists y\forall xF(x,y) ^{\implies}_{\;\cancel{\Longleftarrow}\;} \forall x\exists yF(x,y)$</p><ul><li><p>US+ES后ES引入的常量与US引入的变量相关</p></li><li><p>故US+ES后不能再对US引入的变量使用UG</p></li></ul></li></ul></li><li><p>注意</p><ul><li><p>不能替换为公式中的约束出现</p></li><li><p>要是新引入的变量符号</p><ul><li>在US和ES均需要使用的时候，US不需要是新引入的变量，而ES必须是新引入的变量。所以应先ES，后US</li></ul></li><li><p>量词的辖域是整个公式</p></li></ul></li></ul></li><li><p>重要的谓词演算永真式</p><ul><li><p>第一组</p><ul><li><p>$\forall x(A(x)\land B(x))\equiv\forall xA(x)\land\forall xB(x)$</p></li><li><p>$\forall xA(x)\lor\forall xB(x) \models \forall x(A(x)\lor B(x))$</p></li><li><p>$\exists x(A(x)\land B(x))\models\exists  xA(x)\land\exists xB(x) $</p></li><li><p>$\exists x(A(x)\lor B(x))\equiv\exists xA(x)\lor\exists xB(x) $</p></li></ul></li><li><p>第二组</p><ul><li><p>$\forall x\forall yA(x,y)\equiv\forall y\forall xA(x,y)$</p></li><li><p>$\forall x\forall yA(x,y)\models\exists y\forall xA(x,y)$</p></li><li><p>$\exists y\forall xA(x,y)\models\forall x\exists yA(x,y)$</p></li><li><p>$\forall x\exists yA(x,y)\models\exists y\exists xA(x,y)$</p></li><li><p>$\exists x\exists yA(x,y)\equiv\exists y\exists xA(x,y)$</p></li></ul></li><li><p>第三组</p><ul><li><p>$\forall x(C\implies A(x))\equiv C\implies\forall xA(x)$</p></li><li><p>$\exists x(C\implies A(x))\equiv C\implies\exists  xA(x)$</p></li><li><p>$\forall x(A(x)\implies C)\equiv\exists xA(x)\implies C$</p></li><li><p>$\exists x(A(x)\implies C)\equiv\forall xA(x)\implies C$</p></li><li><p>$\forall x(A(x)\implies B(x))\models \forall xA(x)\implies\forall xB(x)$</p></li><li><p>$\forall x(A(x)\iff B(x))\models \forall xA(x)\iff \forall xB(x)$</p></li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ul><li><p>归纳法的特征</p><ul><li><p>归纳推理</p><ul><li><p>定义</p><ul><li>一般说是由个别的事物或现象推出该类事物或现象普遍性规律的推理。</li></ul></li><li><p>特征</p><ul><li>前提与结论之间有或然性的联系是归纳推理的一个十分重要的特征。</li></ul></li></ul></li></ul></li><li><p>观察、实验与一些整理感性材料的方法</p><ul><li><p>观察与实验</p><ul><li><p>在事物或现象的自然状态下，通过感官去认识事物或现象。这就是观察。</p></li><li><p>在控制事物或现象的条件的情形下，通过感官去认识事物或现象。这就是实验。</p></li><li><p>实验相对于观察的优点</p><ul><li><p>实验比观察更容易认识现象之间的因果联系。</p></li><li><p>在实验中，我们可以人为地创造一些在自然状态下不容易或得不到的环境或条件。</p></li><li><p>在实验中，我们可以使一些现象在任意时间任意多次地重复出现，从而便于深入观察。</p></li></ul></li><li><p>在观察与实验中，应该力求避免主观性(“误观察”)与片面性（“未观察”）。</p></li></ul></li><li><p>比较、分类、分析与综合</p><ul><li><p>比较</p><ul><li><p>比较是把一个对象和别的对象加以对照，确定它们的差异点和共同点的逻辑方法。</p></li><li><p>进行比较时应遵守的一些基本要求</p><ul><li><p>不要去比较根本没有多少共同属性的对象。</p></li><li><p>必须明确比较标准，按照对象间的某一个共同属性来比较它们。在同一次比较中只能采用一个标准。</p></li><li><p>作为比较标准的那一属性应当是重要的、本质的。</p></li></ul></li></ul></li><li><p>分类</p><ul><li>根据事物的共同性与差异性，就可以把事物分类。具有相同属性的事物归入一类，具有不同属性的事物归入不同的类。</li></ul></li><li><p>分析与综合</p><ul><li><p>分析是在思想中把对象分解为各个部分或因素，分别加以考察的逻辑方法。</p><ul><li><p>有一种分析是把整体分解为它的各个部分。</p></li><li><p>另一种分析是分解出某一事物的各种属性，也就是它自身的性质或它与其他事物的关系。</p></li><li><p>把一个完整的过程划分为若干阶段也是一种分析。</p></li></ul></li><li><p>综合是在思想中把对象的各个部分或因素结合成为一个统一体加以考察的逻辑方法。</p></li><li><p>解决问题的过程：分析与综合</p><ul><li><p>一般来说，思考问题的过程可以分为三个阶段</p><ul><li><p>在粗略的分析基础上进行综合，发现和提出问题</p></li><li><p>进行系统的周密的分析，弄清问题的种种方面</p></li><li><p>综合起来，给以解决的办法</p></li></ul></li></ul></li></ul></li></ul></li><li><p>简单枚举、完全归纳和科学归纳</p><ul><li><p>归纳概括</p><ul><li>从特定经验事实中得到普遍命题的过程</li></ul></li><li><p>简单枚举法</p><ul><li><p>我们观察到某类中许多事物都有某属性，而又没有观察到相反事例，我们就作出结论：某类事物都有某属性。这就是简单枚举法。</p></li><li><p>简单枚举法可以为推断一个因果关系提供有说服力的基础</p></li><li><p>用$S$表示一类事物，用$S_1,S_2,…,S_n$表示$S$类中的个别事物，用P表示一个属性。完全归纳法可表示如下</p><ul><li><p>$S_1是P$</p></li><li><p>$S_2是P$</p></li><li><p>…………</p></li><li><p>$S_n是P$</p></li><li><p>—————————————————</p></li><li><p>$所有S都是P$</p></li></ul></li><li><p>为了提高运用简单枚举法所得结论的可靠性，需要注意以下几点：</p><ul><li><p>被考察的对象数量要尽可能多。</p></li><li><p>被考察的对象范围要尽可能地广泛。</p></li><li><p>要注意搜集反面事例。</p></li></ul></li></ul></li><li><p>完全归纳法</p><ul><li><p>是简单枚举法的极限形式</p></li><li><p>完全归纳法是由某类中每一个事物都具有某属性，推出该类全部事物都具有该属性。</p></li><li><p>用$S$表示一类事物，用$S_1,S_2,…,S_n$表示$S$类中的个别事物，用P表示一个属性。完全归纳法可表示如下</p><ul><li><p>$S_1是P$</p></li><li><p>$S_2是P$</p></li><li><p>…………</p></li><li><p>$S_n是P$</p></li><li><p>$(S类中只有S_1,S_2,…,S_n)$</p></li><li><p>—————————————————</p></li><li><p>$所有S都是P$</p></li></ul></li></ul></li><li><p>科学归纳法</p><ul><li><p>简单枚举法的变化形式</p></li><li><p>科学归纳法又叫科学归纳推理，它是根据观察到的某类事物部分对象$S$与某种属性P之间具有因果联系后，根据当时的科学原理和知识状况，去弄清楚$S$和P之间是必然联系还是偶然联系。如果得出$S$和P之间是必然的联系，则可以推出该类事物$S$都具有某种属性P的归纳推理。</p></li><li><p>用$S$表示一类事物，用$S_1,S_2,…，S_n$表示$S$类中的个别事物，用P表示一个属性。完全归纳法可表示如下</p><ul><li>$S_1是P$</li><li>$S_2是P$</li><li>…………</li><li><p>$S_n是P$</p></li><li><p>$(S_1,S_2,…,S_n是S类的部分对象。科学研究表明，他们和P之间具有因果联系)$</p></li><li><p>—————————————————</p></li><li><p>$所有S都是P$</p></li></ul></li><li><p>提高运用科学归纳法所得结论的可靠性，应注意如下两点</p><ul><li><p>前提中被考察的对象在同类事物中应当具有典型性。</p></li><li><p>必须给推理的结论寻找深层理由，即把握现象之间的因果联系。</p></li></ul></li><li><p>科学归纳法的弊端</p><ul><li>科学归纳法只能根据已经把握的一部分事物的某些属性进行归纳，无法穷尽同类事物的全部属性，因而作出的结论不是完全可靠的，带有很大的或然性，也可能有同客观事实相矛盾的情况。这种情况一旦出现，原来的结论就会被推翻。</li></ul></li><li><p>类比法</p><ul><li><p>我们观察到两个或两类事物在许多属性上都相同，便推出它们在其他属性上也相同。这就是类比法。</p></li><li><p>它是从特殊推向特殊的推理</p></li><li><p>用A和B分别代表两个或两类不同的事物，用$a1,a2,…,an,b$分别代表几个不同的属性。类比法可用如下表示：</p><ul><li><p>$A与B有属性a_1，a_2，…，a_n$</p></li><li><p>$A有属性b$</p></li><li><p>—————————————————</p></li><li><p>$B也有属性b$</p></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>原因和结果</p><ul><li><p>如果我们知道，一件事情是另一件事情的原因或者结果，我们就能够从原因推理到结果，或者从结果推理到原因。如果原因和结果之间的假定关系是被正确地建立起来的，那么基于那些关系的推理就是十分强有力的。</p></li><li><p>原因的含义：充分条件、必要条件、充分必要条件</p></li><li><p>因果关系</p><ul><li><p>因果关系不是存粹逻辑的或者演绎的，因果律只能经验地或者后验地发现。</p></li><li><p>我们能观察到一个事态（C）的一些实例，并且观察到的每个实例都伴随特定现象（P）的一个实例。</p></li><li><p>如何建立一个普遍的因果关系，得到C在所有情况下都伴随有P?</p></li></ul></li><li><p>求因果联系的五种方法</p><ul><li><p>契合法（求同法）</p><ul><li><p>契合法规则：如果在所研究的现象出现的两个或两个以上的场合中，只有一个情况是共同的，那么，这个共同的情况就与所研究的现象之间有因果联系。</p></li><li><p>用A、B、C、D与E分别代表不同的情况，用a、b、c、d与e分别代表不同的现象。其中a是我们所研究的现象。契合法可以表示为</p><ul><li><p>场合（1） A，B，C——a，b，c</p></li><li><p>场合（2） A，B，D——a，b，d</p></li><li><p>场合（3） A，C，E——a，c，e</p></li><li><p>……</p></li></ul><hr><ul><li>A与a之间有因果联系</li></ul></li><li><p>契合法不是一个很有效的判明因果联系的方法</p></li><li><p>为了提高运用契合法所得结论的可靠性，应注意以下几点：</p><ul><li><p>各种场合还有没有其他的共同情况</p></li><li><p>比较的场合要尽可能地多</p></li></ul></li></ul></li><li><p>差异法</p><ul><li><p>差异法的规则：如果所研究的现象出现的场合与它不出现的场合之间，只有一点不同，即在一个场合中有某个情况出现，而在另一个场合中这个情况不出现，那么，这个情况与所研究的现象之间就有因果联系。</p></li><li><p>差异法可以表示如下：</p><ul><li><p>场合（1）A，B，C——a，b，c （正面场合）</p></li><li><p>场合（2）        B，C——       b，c （反面场合）</p></li><li><p>————————————————</p></li><li><p>A与a之间有因果联系</p></li></ul></li><li><p>差异法比契合法有较大的可靠性。</p></li><li><p>在运用差异法探求现象间因果联系时，以下两个方面是需要注意的：</p><ul><li><p>两个比较的场合中有无其他的差异情况。</p></li><li><p>两个场合中唯一不同的情况是被研究现象的整个原因还是部分原因。</p></li></ul></li></ul></li><li><p>契合差异并用法</p><ul><li><p>契合差异并用法规则：如果在出现所研究的现象的几个场合中，都存在着一个共同情况，而在所研究的现象不出现的几个场合中，都没有这个情况，那么，这个情况与所研究的现象之间就有因果联系。</p></li><li><p>这一方法可以表示为：</p><ul><li><p>正面场合</p></li><li><p>A，B，C——a、b、c</p></li><li><p>A，D，E——a、d、e</p></li><li><p>A，F，G——a、f、g</p></li><li><p>反面场合</p></li><li><p>B，M，N——b、m、n</p></li><li><p>D，O，P——d、o、p</p></li><li><p>F，Q，R——f、q、r</p></li><li><p>————————————————————</p></li><li><p>A与a之间有因果联系</p></li></ul></li><li><p>契合差异并用法的步骤：</p><ul><li><p>把所研究的现象出现的那些场合加以比较。</p></li><li><p>把所研究的现象不出现的那些情况加以比较。</p></li><li><p>把前两步比较所得的结果再加以比较。</p></li></ul></li><li><p>为了提高运用契合差异并用法所得结论的可靠性，以下两点需要注意：</p><ul><li><p>构成正负事例组的场合越多，结论的可靠性往往就越高。</p></li><li><p>正、负事例组的各个对应场合，其相似的程度越高，获得结论的可靠性就越大。</p></li></ul></li></ul></li><li><p>共变法</p><ul><li><p>共变法规则：当其它情况不变时，如果每当某一现象发生一定程度的变化时，另一现象也随之发生一定程度的变化，那么，这两个现象之间有因果联系。</p></li><li><p>设A1，A2，A3，…是现象A的不同状态;a1，a2，a3，…是另一现象a的不同状态。共变法可用如下表示：</p><ul><li><p>场合（1）A1，B，C——a1、b、c</p></li><li><p>场合（2）A2，B，C——a2、b、c</p></li><li><p>场合（3）A3，B，C——a3、b、c</p></li><li><p>————————————————</p></li><li><p>A与a有因果联系</p></li></ul></li><li><p>共变法的优点：</p><ul><li><p>共变法是从现象变化的数量或程度来判明因果联系的。应用共变法得到的结论有较大的可靠性。</p></li><li><p>有些现象是无法消除的或不易消除的。</p></li></ul></li><li><p>同向共变和异向共变</p><ul><li><p>同向共变：指结果的量随原因的量成正比例关系变化。</p></li><li><p>异向共变：指结果的量随原因的量成反比例变化。</p></li></ul></li><li><p>为了提高运用共变法所得结论的可靠性，应注意：</p><ul><li><p>与被研究对象发生共变的情况是否是唯一的。</p></li><li><p>有些现象之间虽然也存在共变关系，但却不具有因果联系。</p></li><li><p>两个现象之间的共变关系往往是在一定限度之内，超过一定限度，共变现象就会消失或者发生另一种相反的共变。</p></li></ul></li></ul></li><li><p>剩余法</p><ul><li><p>剩余法规则：如果已知某一复合现象是另一复合现象的原因，同时又知道前一现象中的某一部分是后一现象中的某一部分的原因，那么，前一现象的其余部分与后一现象的其余部分有因果联系。</p></li><li><p>剩余法表示如下：</p><ul><li><p>A、B、C、D是a、b、c、d的原因，</p></li><li><p>A是a的原因</p></li><li><p>B是b的原因</p></li><li><p>C是c的原因</p></li><li><p>——————————————————</p></li><li><p>D与d之间有因果联系</p></li></ul></li><li><p>为了提高有关结论的可靠性，运用剩余法时应注意：</p><ul><li>必须首先确定复合现象中的a、b、c是由复合情况中的A、B、C引起的，并且复合现象中的剩余部分d不可能是由情况A、B、C中的一个或几个共同作用引起的；否则，就不能断定现象d由情况D引起。</li></ul></li></ul></li></ul></li></ul></li><li><p>假说演绎法</p><ul><li><p>假说的性质</p><ul><li><p>假说就是人们根据已有的知识对于所研究的事实或现象作出的初步解释。</p></li><li><p>假说有时是关于一个个别事物或现象的，有时又是关于一类事物或现象的。</p></li></ul></li><li><p>假说的特征</p><ul><li><p>假说是以客观事实和科学知识为依据的。</p></li><li><p>假说具有推测性。</p></li><li><p>假说是人的认识接近客观真理的方式。</p></li></ul></li><li><p>假说的发展</p><ul><li><p>假说的提出</p><ul><li><p>在一定事实材料的基础上，以科学原理为指导，通过思维的加工（主要是应用推理）而做出初步的假定。这就是假说形成的初始阶段。</p></li><li><p>从已经确立的初步假定出发，经过事实材料和科学原理的广泛论证，使初步假定充实成为一个结构稳定的系统。这就是假说形成过程中的完成阶段</p></li><li><p>大致说来，在假说形成的初始阶段里，对若干个设想进行选择，采取下列思维过程：</p><ul><li><p>或者p1或者p2或者p3；</p></li><li><p>如果p2，那么q2；但是非q2；</p></li><li><p>因此，p2不成立。</p></li><li><p>如果P3，那么q3；但是非q3；</p></li><li><p>因此，p3不成立。</p></li><li><p>——————————————</p></li><li><p>p1成立</p></li></ul></li></ul></li><li><p>由假说推出结论</p><ul><li>从假说的基本理论观点出发，结合一定的背景知识，推导出一些关于事实的论断。这些论断有的是对已知事实的解释，有的是对未来事实的预言。其中，前者在验证假说方面不及后者有说服力。</li></ul></li><li><p>进行验证</p><ul><li><p>通过各种实践检验从假说基本观点结合背景知识所推出的结论是否真实。如果所推出的结论和和事实相符合，那么，人们一般就认为假说得到了证实。如果推出的结论与事实不相符合，那么，人们一般就认为假说被证伪了。</p><ul><li><p>假说的证实推理形式：</p><ul><li><p>如果（p并且r），那么q</p></li><li><p>q</p></li><li><p>————————————</p></li><li><p>p并且r</p></li></ul></li><li><p>假说的证伪推理形式：</p><ul><li><p>如果（p并且r），那么q</p></li><li><p>并非q</p></li><li><p>————————————</p></li><li><p>并非（p并且r）</p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">逻辑学导论公选课的知识梳理。</summary>
    
    
    
    <category term="课程学习" scheme="http://zerolacqua.top/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="逻辑学" scheme="http://zerolacqua.top/tags/%E9%80%BB%E8%BE%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>遥感图像解译复习</title>
    <link href="http://zerolacqua.top/posts/b0c605b4.html"/>
    <id>http://zerolacqua.top/posts/b0c605b4.html</id>
    <published>2022-02-24T15:11:38.000Z</published>
    <updated>2022-03-20T12:44:53.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课件内容"><a href="#课件内容" class="headerlink" title="课件内容"></a>课件内容</h2><h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><h4 id="遥感技术应用"><a href="#遥感技术应用" class="headerlink" title="遥感技术应用"></a>遥感技术应用</h4><ul><li><p>研究对象：地表到社会经济</p></li><li><p>研究数据：遥感数据</p></li><li><p>具体应用</p><ul><li><p>根据不同期影像去监测地面变化，驳斥错误报道</p></li><li><p>关注特殊时期的变化</p></li><li><p>灾害监测</p><ul><li><p>水灾监测</p></li><li><p>干旱监测</p></li><li><p>火灾监测</p></li><li><p>台风预报</p></li><li><p>雾监测</p></li><li><p>沙尘暴监测</p></li><li><p>海冰监测</p></li></ul></li><li><p>植被农业监测</p></li><li><p>雾霾</p></li><li><p>社会问题——人口分布与贫困</p></li><li><p>全球产品</p><ul><li><p>30m地表覆盖分布总示意图</p></li><li><p>全球30米分辨率火烧迹地产品</p></li></ul></li><li><p>空气质量变化监测</p></li><li><p>土地利用类型调查</p><ul><li>全国地理国情普查</li></ul></li><li><p>目标识别</p></li><li><p>执法——大棚遥感监测</p></li><li><p>其他应用</p><ul><li><p>非遥感图像</p></li><li><p>非地理空间信息的判读</p></li><li><p>各种识别</p></li></ul></li></ul></li><li><p>应用分类</p><p>| 类型     | 主要方法                | 应用领域                                                     | 数据源                    | 传感器空间分辨率 | 传感器光谱分辨率 | 传感器时间分辨率 |<br>| ———— | ———————————- | —————————————————————————————— | ————————————- | ———————— | ———————— | ———————— |<br>| 图像分类 | 监督<br />非 监督       | 农林、国土资源调查与规划                                     | TM，ETM， SPOT，ZY等      | 中               | 中               | 中               |<br>| 定量遥感 | 反演模型                | 生态环境及动态监测                                           | MODIS、AVHRR、 高光谱数据 | 低               | 高               | 高               |<br>| 目标识别 | 图像分割<br /> 模式识别 | 城市信息更新、军事目标探测、农林地块精细识别、大型工程设施监控、<strong>新闻热点、社会问题</strong> | 高空间分辨率图像          | 高               | 低               | 高中低           |</p></li></ul><h4 id="遥感图像解译的目的"><a href="#遥感图像解译的目的" class="headerlink" title="遥感图像解译的目的"></a>遥感图像解译的目的</h4><ul><li><p>解译目的</p><ul><li><p>所有这些应用都可以利用遥感技术直接或间接得到</p></li><li><p>从图像数据提取需要的信息才是目的<br>数据转化为信息</p></li></ul></li><li><p>解译对象</p><ul><li><p>不同现象，不同目标解译</p></li><li><p>使用数据源不同</p></li><li><p>对数据、对方法的要求不同</p></li></ul></li><li><p>解译用的遥感图像</p><ul><li><p>数据的多样性：不同平台、不同传感器</p><ul><li><p>空间分辨率</p></li><li><p>光谱分辨率</p></li><li><p>辐射分辨率</p></li><li><p>时间分辨率</p></li><li><p>不同成像方式</p></li></ul></li></ul></li><li><p>获取信息的方法</p><ul><li><p>计算机处理——为了利用计算机自动获取</p><ul><li><p>空间信息</p></li><li><p>属性信息</p></li><li><p>变化信息</p></li></ul></li><li><p>目视判读</p><ul><li>人眼视觉能力和计算机能力的不同</li></ul></li></ul></li><li><p>解译的流程</p><ul><li><p>获取这些信息涉及相关的内容包括</p><ul><li><p>目标</p></li><li><p>数据</p></li><li><p>图像特征</p></li><li><p>解译的原理、方法</p></li><li><p>应用</p></li><li><p>评价</p></li></ul></li><li><p>目标</p><ul><li><p>研究对象：自然地表</p></li><li><p>地表包含的内容</p><ul><li><p>类别</p></li><li><p>类别参数</p></li><li><p>地理单元</p></li><li><p>反映某种状态的区域</p><ul><li>如天气污染、热岛</li></ul></li></ul></li><li><p>关键是了解目标的特征</p></li></ul></li><li><p>对数据的要求</p><ul><li><p>根据应用目的</p></li><li><p>对数据的要求</p><ul><li>实际情况是同一地区图像的分辨率不同</li></ul></li><li><p>参考数据的要求</p></li><li><p>尺度不同</p></li></ul></li><li><p>了解目标在图像的特征</p><ul><li><p>波谱响应特征</p></li><li><p>空间特征</p></li><li><p>时间特征</p></li></ul></li><li><p>处理方法</p><ul><li><p>对图像的认识、解译需要掌握的东西</p></li><li><p>考虑自然目标和人工目标识别的区别</p></li><li><p>人工与机器识别的异同</p></li></ul></li><li><p>遥感技术的应用能力</p><ul><li><p>主要是能够提供什么样的信息</p></li><li><p>遥感的能力</p></li><li><p>人的能力</p></li><li><p>计算机的能力</p></li></ul></li><li><p>作用</p><ul><li><p>测绘事业是经济建设、国防建设、社会发展的基础性事业</p><ul><li><p>国家的重要经济领域提供信息服务。</p></li><li><p>为制定国民经济发展计划提供资源与环境动态基础数据。</p></li><li><p>为国家重大的资源、环境突发性事件提供及时准确的监测评估数据，保证国家对这些重大问题作出正确、快速的反应。（测绘应急保障）</p></li><li><p>生物量估测。包括农作物产量、产草量、水面初级生产力预估和评价。</p></li><li><p>……</p></li></ul></li></ul></li></ul></li></ul><h4 id="图像到信息传递过程"><a href="#图像到信息传递过程" class="headerlink" title="图像到信息传递过程"></a>图像到信息传递过程</h4><ul><li><p>信息传递的途径：有何区别？</p><ul><li><p>信息源-&gt;信道-&gt;接受信息</p></li><li><p>从信息传输的角度遥感过程可概括为</p><ul><li><p>物体辐射-&gt;各种影响因素-&gt;数据获取-&gt;数据处理和信息获取-&gt;判读和应用</p></li><li><p>对象-处理-信息-应用</p></li></ul></li><li><p>地物信息的传递过程</p></li><li><p><strong>遥感基础出发点，为何可以用传感器获取空间信息？</strong></p><ul><li><p>遥感图像接近地面实况，遥感信息在传输中消耗能量，并有噪声介入，遥感图像无论是模拟还是数字的，都是<u>信息而不是实物或现象本身</u></p></li><li><p>光谱信息是遥感的基础。地物波谱特征是复杂的，它受到多种因素的控制，而且地物波谱特征本身也往往因时因地在变化着，实物、现象与遥感图像信息之间的关系存在<u>不确定性</u></p></li></ul></li><li><p>图像信息与地物（实物或现象）的关系</p><ul><li><p>获取地物的影像</p><ul><li><p>几何信息</p><ul><li><p>模型重建、几何量测</p></li><li><p>得到地物几何位置</p></li></ul></li><li><p>辐射信息</p><ul><li><p>影像识别、定量分析</p></li><li><p>得到地物属性、地物数量指标</p></li></ul></li></ul></li></ul></li></ul></li><li><p>地物信息的传递过程涉及的环节</p><ul><li><p>有选择地观测地学环境</p><ul><li><p>地物信息的传递是从数据获取开始的。数据获取实质上是由传感器代替人直接观测地学环境，<u>通常情况下是围绕某项任务，有计划、有目的开展。</u></p></li><li><p>关键是运用相关的专业知识和技能确定<u>实物、现象与图像信息之间的关系</u></p></li></ul></li><li><p>由数据产生的局部概念模型</p><ul><li>图像处理人员的知识、经验、能力和思维方式对地学环境观测数据的实际信息量有重要作用</li></ul></li><li><p>将地物图像数据转变成图像信息</p></li><li><p>图像信息的组织和管理</p></li><li><p>将图像信息还原为地物信息</p></li><li><p>由地学信息产生的局部概念模型</p></li><li><p>按照地学应用要求进行加工</p><ul><li>地物信息的使用和加工必须适应具体地学应用的要求。</li></ul></li><li><p>遥感技术过程</p><ul><li><p>对象-图像-图</p><ul><li><p>选择对象</p></li><li><p>数据的局部概念模型</p></li><li><p>提取信息</p></li><li><p>还原地物信息</p></li><li><p>信息的局部概念模型</p></li><li><p>加工、表达</p></li><li><p>应用、评价</p></li></ul></li></ul></li><li><p>遥感信息的特点</p><ul><li><u>遥感图像信息所反映的地学环境的综合性与复杂性，以及遥感信息本身的综合特点，决定了遥感信息单纯数学、物理处理结果具有不确定性或多解性</u></li></ul></li></ul></li><li><p>针对不确定性涉及的知识</p><ul><li><p>为了提高解译结果的正确性与可靠性，需要地学知识。实际上，地物遥感信息处理涉及面十分广泛，它与地学、生物、数学、物理、信息技术都有不同程度的关联</p></li><li><p>地物信息与具体应用的结合会涉及到各种相关知识的运用</p></li><li><p>用到的相关知识</p><ul><li><p>地学方法的应用</p><ul><li>研究对象是地学</li></ul></li><li><p>物候学的应用，有何作用</p></li><li><p>生物学知识的应用</p></li><li><p>物理方法的应用</p></li><li><p>数学方法的应用</p></li><li><p>各种可视化方法的应用</p></li></ul></li><li><p>遥感涉及的知识</p><ul><li><p>对象本身特征：遥感物理基础、地学、物候学、生物学</p></li><li><p>反映对象的数据获取：传感器成像原理</p></li><li><p>数据处理：数学物理</p></li><li><p>图像处理、变换</p></li><li><p>信息获取：目视判读，计算机分类方法</p></li><li><p>信息的表达方式：各种可视化方法</p></li><li><p>信息的应用：各专业背景</p></li></ul></li></ul></li></ul><h4 id="遥感图像解译的任务与方式"><a href="#遥感图像解译的任务与方式" class="headerlink" title="遥感图像解译的任务与方式"></a>遥感图像解译的任务与方式</h4><ul><li><p>目的</p><ul><li><p>信息提取</p><ul><li><p>地表覆盖</p></li><li><p>定量指标</p></li><li><p>目标识别</p></li></ul></li><li><p>方法：从遥感图像上提取地物信息所需要的基础理论和实践方法</p></li></ul></li><li><p>图像解译的任务</p><ul><li><p>按应用领域</p><ul><li><p>普通地学解译</p><ul><li><p>主要为了取得一定地球圈层范围内的综合性的信息</p><ul><li><p>地理基础信息解译</p><ul><li>地理基础信息一般由地形信息、居民地、道路、水系、独立地物、植被、地貌和土质等构成。</li></ul></li><li><p>景观解译</p><ul><li>景观主要指多个地学要素有规律的地域结合。</li></ul></li></ul></li></ul></li><li><p>专业解译</p><ul><li><p>主要是为了解决各部门的任务，用于提取特定要素或概念的信息</p><ul><li><p>地质</p></li><li><p>林业</p></li><li><p>农业</p></li><li><p>军事</p></li></ul></li></ul></li></ul></li><li><p>按应用范围划分</p><ul><li><p>巨型地物与现象，全球范围</p></li><li><p>大型地物与现象，区域范围</p></li><li><p>中型地物与现象，和生产生活关系已经比较密切，特别是与各种资源调查关系密切</p></li><li><p>小型地物与现象</p></li></ul></li></ul></li><li><p>图像解译的实施</p><p>| 类型     | 主要方法                | 应用领域                                                     | 数据源                    | 传感器空间分辨率 | 传感器光谱分辨率 | 传感器时间分辨率 |<br>| ———— | ———————————- | —————————————————————————————— | ————————————- | ———————— | ———————— | ———————— |<br>| 图像分类 | 监督<br />非 监督       | 农林、国土资源调查与规划                                     | TM，ETM， SPOT，ZY等      | 中               | 中               | 中               |<br>| 定量遥感 | 反演模型                | 生态环境及动态监测                                           | MODIS、AVHRR、 高光谱数据 | 低               | 高               | 高               |<br>| 目标识别 | 图像分割<br /> 模式识别 | 城市信息更新、军事目标探测、农林地块精细识别、大型工程设施监控、<strong>新闻热点、社会问题</strong> | 高空间分辨率图像          | 高               | 低               | 高中低           |</p></li></ul><ul><li><p>遥感图像解译的组织和实施</p><ul><li><p>目视解译</p><ul><li><p>直接法</p></li><li><p>对比法</p></li><li><p>复合法</p></li><li><p>地理相关分析法</p></li></ul></li><li><p>计算机分类</p><ul><li><p>基于像元分类</p><ul><li><p>非监督分类</p><ul><li><p>K均值分类</p></li><li><p>ISODATA</p></li><li><p>……</p></li></ul></li><li><p>监督分类</p><ul><li><p>最大似然法</p></li><li><p>最小距离法</p></li><li><p>人工智能</p></li><li><p>专家分类</p></li><li><p>神经网络</p></li></ul></li></ul></li><li><p>基于目标分类</p><ul><li><p>邻近法</p></li><li><p>规则库</p></li></ul></li></ul></li><li><p>人机交互</p></li></ul></li></ul><h4 id="遥感信息的利用方式及技术支撑"><a href="#遥感信息的利用方式及技术支撑" class="headerlink" title="遥感信息的利用方式及技术支撑"></a>遥感信息的利用方式及技术支撑</h4><ul><li><p>利用方式具体的过程</p><ul><li><p>瞬时信息的定性分析</p></li><li><p>空间信息的定位分析</p></li><li><p>瞬时信息的定量分析</p></li><li><p>时间信息的趋势分析</p></li><li><p>多源信息的综合分析</p></li></ul></li><li><p>解译产品和各种支撑技术的发展</p><ul><li><p>观察与测量仪器的改变</p></li><li><p>产品形式的改变</p></li><li><p>生产工艺的改变</p></li><li><p>新一代传感器的研制</p></li><li><p>地理信息系统的支持</p></li><li><p>遥感应用模型的深化</p></li><li><p>遥感图像解译方法发展趋势：智能解译</p><ul><li><p>人工智能领域</p></li><li><p>深度学习算法</p></li></ul></li></ul></li></ul><h4 id="遥感图像解译中的尺度问题"><a href="#遥感图像解译中的尺度问题" class="headerlink" title="遥感图像解译中的尺度问题"></a>遥感图像解译中的尺度问题</h4><ul><li><p>科学研究中的尺度问题</p><ul><li><p><u>在涉及空间信息的研究和应用过程中，必须需要考虑的是一个空间尺度概念。</u></p></li><li><p>什么范围和尺度</p></li><li><p>不同的尺度有没有可比性，能否扩展</p></li><li><p>四个尺度</p><ul><li><p>制图尺度或地图尺度</p><ul><li>地面比例尺</li></ul></li><li><p>测量尺度或分辨率</p><ul><li>获取的图像像元对应于地面的大小</li></ul></li><li><p>地理或观测尺度</p><ul><li>研究区域的空间范围或区域大小 </li></ul></li><li><p>运行尺度</p><ul><li>特定地学现象或过程发生的空间范围，由所研究的地学现象或过程本身决定</li></ul></li></ul></li><li><p>尺度之间的转换</p></li></ul></li><li><p>空间异质性（尺度是空间异质性的量度单位）</p><ul><li><p>指某个变量在空间上分布的均匀性及复杂程度，是自然现象固有的属性</p></li><li><p>空间异质性的程度不仅取决于自然现象的本身，也依赖于测量尺度大小</p></li><li><p>在一个尺度上是同质在另一个尺度可能是异质的。测量尺度的变化有可能会导致空间异质性的出现和消失</p></li><li><p><u>不同时尺度上所包含信息不同，所以说空间异质性是理解尺度问题的关键</u></p></li><li><p>尺度依赖</p><ul><li>地理现象的内存属性。如果某一地理格局根据所观测的尺度而变</li></ul></li><li><p>尺度无关</p><ul><li>如果地理现象不随尺度变化。现实中地理现象尺度无关的很少</li></ul></li></ul></li><li><p>尺度效应</p><ul><li><p>指空间数据由于其测量尺度的变化而导致分析结果也随之变化的现象</p></li><li><p>遥感中尺度效应指的是由于遥感数据空间分辨率的变化而导致分析结果变化的现象</p></li><li><p>尺度转换</p><ul><li><p>尺度扩展</p></li><li><p>尺度收缩</p></li></ul></li></ul></li><li><p>最优尺度</p><ul><li><p>使遥感处理达到最优效果的尺度</p></li><li><p>包含所需信息而且数据量最小的空间分辨率</p></li><li><p>不应该理解为信息提取时获取最高精度的空间分辨率</p></li></ul></li><li><p>遥感图像的尺度</p><ul><li><p>空间分辨率</p></li><li><p>光谱分辨率</p></li><li><p>辐射分辨率</p></li><li><p>时间分辨率</p></li></ul></li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ul><li><p>遥感的作用</p></li><li><p>图像和信息的区别与联系</p></li><li><p>分析遥感图像解译的基本概念、目的</p></li><li><p>地物信息的传递过程中各个环节作用是什么</p></li><li><p>分析相关学科在遥感图像解译中的作用</p></li><li><p>举例说明数学物理方法在图像解译中的作用</p></li><li><p>尺度概念以及在遥感图像解译中的作用</p></li><li><p>本课程内容组织方式以及前后联系</p></li></ul><hr><h3 id="第二章-遥感研究对象的特性"><a href="#第二章-遥感研究对象的特性" class="headerlink" title="第二章 遥感研究对象的特性"></a>第二章 遥感研究对象的特性</h3><ul><li><p>遥感研究对象</p><ul><li>遥感技术关注的特性与目标固有的特性。遥感利用的只是目标的部分特征。这部分特征是可以被探测的。探测到的信息只是目标的一部分！</li></ul></li><li><p>遥感信息的属性</p><ul><li>遥感信息是多源的。它是由平台的高低、视场角的大小、波段的多少、时间频率的长短等多种因素决定。这些因素的变化造成遥感信息本身具有不同的物理属性。相应于遥感信息本身的这些属性，遥感研究对象也存在着几个方面的属性：<u>空间分布、波谱反射和辐射特征、时相变化。</u></li></ul></li></ul><h4 id="地理单元与空间分布"><a href="#地理单元与空间分布" class="headerlink" title="地理单元与空间分布"></a>地理单元与空间分布</h4><ul><li><p>地理单元（地理实体）性质</p><ul><li><p><u>地理综合体是一个相对封闭的自然地段</u>，它通过发生在内部的诸自然过程和地理组成成分的相互依存性而构成一个整体。其成分有同质与异质之分</p><ul><li><p>所有高级地理综合体，它们的<u>异质程度随等级升高和单元规模扩大而增大。</u></p></li><li><p><u>地理综合体从低级到高级单元，其内部相似性逐渐减少，而相互间差异性逐渐增大</u></p></li></ul></li><li><p>地理单元包括多种属性，它们的类别边界不可能完全一致，应该根据地理综合体理论对它们（各种属性边界）作必要的综合。</p><ul><li><p>取重要属性，舍次要属性</p></li><li><p>取确定边界，舍模糊边界</p></li><li><p>取两侧属性差异大的边界，舍两侧差异小的边界</p></li></ul></li></ul></li><li><p>空间分布</p><ul><li><p>任何地学研究对象，均有一定的空间分布特征。根据空间分布的平面形态，把地面对象分为：<u>面状、线状、点状</u>。</p></li><li><p>可以从以下几个方面来确定其空间分布特征</p><ul><li><p>空间位置</p></li><li><p>大小（对于面状目标而言）</p></li><li><p>形状（对于面状或线状目标而言）</p></li><li><p>相互关系。</p></li></ul></li><li><p>前面三个特征是就单个目标而言，可以通过一些数据来表示</p></li><li><p>面状对象</p><ul><li><p>面状对象其空间位置由表示界限的一组x，y坐标确定，并可以相应地求得其大小和形状参数。</p><ul><li><p>连续而布满整个研究区域，如高度、地物类型、地貌、地质、气温等；</p></li><li><p>间断而成片分布于大片区域上，如森林、湖泊、沙地、各类矿物分布区等</p></li><li><p>在研究区域较大面积上分散分布，如果园、石林、残丘等</p></li></ul></li><li><p>某个地理单元或某个区域所具有的特征</p></li><li><p>面状分布特点，变化频繁</p><ul><li><p>天气预报</p></li><li><p>气候变迁</p></li><li><p>环境监测</p></li></ul></li><li><p>遥感研究的对象以面状对象为主</p></li></ul></li><li><p>线状对象</p><ul><li>空间位置：由表示线形轨迹的一组x，y坐标确定，在空间上呈线状或带状分布，如道路、河流、海岸等。</li></ul></li><li><p>点状对象</p><ul><li>空间位置：由其实际位置或中心位置的x，y坐标确定，实地上分布面积较小或呈点状分布的有独立树、单个建筑等。</li></ul></li><li><p>相互关系（空间结构）</p><ul><li><p>某个区域内地物目标的空间分布特征。</p></li><li><p>地面目标受某种空间分异规律的影响，其分布呈现一定的空间组合形式，仅通过单一目标难以反映。</p></li></ul></li></ul></li></ul><h4 id="波谱反射和辐射特征"><a href="#波谱反射和辐射特征" class="headerlink" title="波谱反射和辐射特征"></a>波谱反射和辐射特征</h4><ul><li><p>物体的基本特征</p><ul><li><u>任何物体本身都具有发射、吸收和反射电磁波的能力。</u></li></ul></li><li><p>相同的物体具有相同的电磁波谱特征，不同的物体由于物质组成和结构不同具有相异的电磁波谱特征。</p></li><li><p>遥感的基本出发点</p><ul><li>可以根据遥感仪器所接收到的电磁波谱特征的差异来识别不同的物体。</li></ul></li><li><p>水体电磁辐射特性</p></li><li><p>植被电磁辐射特性</p><ul><li><p>不同种类</p></li><li><p>不同含水量</p></li><li><p>不同健康状况</p></li></ul></li><li><p>岩石和矿物的电磁辐射特性</p><ul><li><p>反射波谱特性</p><ul><li>不同的岩矿类型，由于其化学组成、结构、产状以及测量时的外部环境因素，使得光谱反射的形态发生许多变化，<u>导致岩石的反射波谱曲线没有统一的特征</u></li></ul></li><li><p>发射波谱特性</p><ul><li>岩矿物的发射率与其表面特性一一粗糙度、色调有关。一般说来，<u>粗糙表面比平滑表面发射强，暗色地物比浅色地物有较高发射率</u>，所以在同样温度条件下发射率高的物体热辐射强。</li></ul></li></ul></li><li><p>土壤电磁辐射特性</p></li><li><p>人工地物目标的电磁辐射特性</p><ul><li><p>反射波谱特性人工地物目标主要包括各种道路、广场、建筑物以及人工林与人工河等。<u>人工林与人工河的光谱反射特征与自然状态下的植被与水体大体相同</u>。各种道路的波谱曲线形状大体相似，但由于建筑材料的不同，存在一定的差异，如<u>水泥路的反射率最高，次之为土路、沥青路</u>等 </p></li><li><p>蚀变异常信息提取的波谱依据</p></li><li><p>复杂情况</p><ul><li><p>同谱异物：在某一个谱段区，两个不同地物可能呈现相同的谱线特征</p></li><li><p>同物异谱：可能同一个地物，处于不同状态，如对太阳光相对角度不同，密度不同，含水量不同等等，呈现不同的谱线特征</p></li><li><p>高光谱的目的</p></li><li><p>对不同的研究对象要掌握其波谱特性，这是遥感的基础。</p></li></ul></li></ul></li><li><p>研究对象的特性参数</p><ul><li><p>每个地面目标有其自身的各种参数</p><ul><li><p>土壤、水质、植被、庄稼等以及各种现象</p></li><li><p>研究对象的特性参数与其波谱特性之间关系</p></li></ul></li></ul></li></ul><h4 id="时间特征"><a href="#时间特征" class="headerlink" title="时间特征"></a>时间特征</h4><ul><li><p>两方面含义</p><ul><li><p>自然变化过程，即其发生、发展和演化</p></li><li><p>节律，既事物的发展在时间序列上表现出某种周期性重复的规律。</p><ul><li>如太阳黑子活动11年一个周期，植物生长有它的季相节律。节律有长有短，并不是所有的地面对象都具有这一特征。</li></ul></li><li><p>任何一个遥感对象都处于一定的时态之中，有它的时相变化过程。遥感信息是瞬间记录，在分析遥感资料时必须考虑研究对象本身所处的时态，不能超越一个瞬时信息能反映的范围。</p></li><li><p>变化类型：快和慢</p></li></ul></li></ul><h4 id="解译对象的划分"><a href="#解译对象的划分" class="headerlink" title="解译对象的划分"></a>解译对象的划分</h4><ul><li><p>解译对象的划分涉及到被揭示地物的组成，也涉及到被研究的地物的性质，特别是观察的角度有很大区别。</p><ul><li><p>遥感的物理特性（电磁波谱特性）</p></li><li><p>地物的变化过程</p></li><li><p>多种不同的解译对象划分方法</p><table>    <tr>        <td></td>        <td>解译对象划分原则</td>        <td>地物组成</td>        <td>地物举例</td>    </tr>     <tr>        <td rowspan="5">1</td>        <td rowspan="5">按照解译对象的专题特性</td>        <td>地理基础信息</td>        <td>居民点、水系、高程、道路等</td>    </tr>    <tr>        <td>景观</td>        <td>沙漠、草原</td>    </tr>    <tr>        <td>地质地貌</td>        <td>地层、断层、滑坡等</td>    </tr>    <tr>        <td>土地利用</td>        <td>工业、商业、农田等</td>    </tr>    <tr>        <td>其他</td>        <td>工程设施等</td>    </tr>    <tr>        <td rowspan="2">2</td>        <td rowspan="2">按照解译对象的形成状态</td>        <td>自然形成地物</td>            <td>森林、沼泽、湖泊等</td>    </tr>    <tr>        <td>人工构成地物</td>        <td>居民点、道路、桥梁等</td>    </tr>            <tr>        <td rowspan="3">3</td>        <td rowspan="3">按照解译对象线性尺寸的绝对值和相对值</td>        <td>密集（点状）的地物</td>            <td>房屋、独立树、飞机等</td>    </tr>    <tr>        <td>线状（延伸）的地物</td>        <td>道路、河流、飞机跑道等</td>    </tr>    <tr>        <td>面状地物</td>        <td>湖泊、林地、飞机场等</td>    </tr>    <tr>        <td rowspan="2">4</td>        <td rowspan="2">按照地物要素的组成和用途</td>        <td>简单地物</td>            <td>房屋、独立树、飞机、跑道等</td>    </tr>    <tr>        <td>复杂地物</td>        <td>城市、林地、飞机场等</td>    </tr>            <tr>        <td rowspan="4">5</td>        <td rowspan="4">按照电磁波谱特性</td>        <td>可见光地物反射</td>            <td>不同反差的地物</td>    </tr>    <tr>        <td>近红外地物反射</td>        <td>植被等</td>    </tr>        <tr>        <td>地物热辐射</td>        <td>热岛等</td>    </tr>        <tr>        <td>地物微波特性</td>        <td>土壤含水量等</td>    </tr>        <tr>        <td rowspan="2">6</td>        <td rowspan="2">按照地物位置的稳定性</td>        <td>活动地物</td>            <td>海洋中冰、天上的云</td>    </tr>    <tr>        <td>固定地物</td>        <td>水系、道路网等</td>    </tr></table></li></ul></li></ul><p>​     </p><ul><li><p>活动的痕迹</p><ul><li><p><u>也是间接标志</u>！对确定工业企业、道路、军事目标等人工物体的性质最有意义。</p></li><li><p>常涉及到某些天然物体，如根据水和岸的相互关系可以确定河流方向和土的性质。</p></li><li><p>按照地物存在的持续期和它们的特点可把它们分成运动的和固定的地物。</p><ul><li><p><u>运动地物</u>：那些变化着自己性质的地物；或是在比较短的时间内，如几小时，几昼夜，几星期之内就消失的地物。</p></li><li><p><u>固定地物</u>：相对而言，变化着自己的特性，但这种变化要在一个季节、几年或更长时间才发生。这种分类对获取海冰在海洋中的位置、获取云量以及部队位置等方面的信息尤为重要。</p></li></ul></li></ul></li></ul><h4 id="地表覆盖类型"><a href="#地表覆盖类型" class="headerlink" title="地表覆盖类型"></a>地表覆盖类型</h4><ul><li><p>地理国情普查地表覆盖类型</p><ul><li><p>水田</p><ul><li>指用于种植水稻、莲藕等水生农作物的耕地。包括实行水生、旱生农作物轮种的耕地。</li></ul></li><li><p>旱地</p><ul><li>指无灌溉设施，主要靠天然降水种植旱生家作物的耕地，包括没有灌溉设施，仅靠引洪淤灌的耕地。</li></ul></li><li><p>园地</p><ul><li><p>指种植以采集果、叶、根、茎、枝、汁等为主的集约经营的多年生木本和草本作物，覆盖度大于50%或每亩株数大于合理株数70%的土地。包括用于育苗的土地。</p></li><li><p>果园</p></li><li><p>茶园</p></li><li><p>橡胶园</p></li><li><p>乔木</p></li></ul></li><li><p>草地</p><ul><li>指生长草本植物为主的土地</li></ul></li></ul></li><li><p>具体的地表类别非常丰富</p></li><li><p>需要对每个类别<u>去分析其空间分布、波谱特性、时间特性。</u></p></li><li><p>建立每类地物的样本库</p><ul><li><u>遥感影像解译包括场景识别、目标检测、地物分类、变化检测、三维重建等不同层次的任务</u>，每种任务都可基于多种影像资源(多类型传感器、多时相、多尺度)来实现，面向智能解译的样本库必须充分体现这种多源特性，才能保证解译精度。</li></ul></li><li><p>样本模型</p><ul><li><p>面向任务的样本模型</p><ul><li><p>针对场景分类、目标检测、地物分类、变化检测、三维重建等解译任务，需要有相应的样本类型</p><ul><li><p>场景分类样本</p><ul><li><p>场景识别对应于计算机视觉中的图像分类任务，其目的是自动给航空或航天遥感影像贴上特定语义类别标签，支持场景与目标(如机场、码头、立交桥等)的快速检索。</p></li><li><p>场景数据主要包括局部或区域性场景影像，以及对应的分类文本标签。</p></li></ul></li><li><p>目标检测样本</p><ul><li><p><u>目标检测是在影像中定位一个或多个感兴趣的特定地物(如建筑物、车辆、飞机等)，并识别预测地物相应的类别</u>。</p></li><li><p>主要包括目标影像、目标定位框坐标数据、目标分类信息。由于遥感地物内容繁杂，有时解译模型难以区分或判定部分样本中细分的地物类别。因此，需要综合考虑地物目标的地域、时相、地形地貌、地块分布模式或其在影像中的图斑大小等因素，甚至需要提供示例图片进行说明。</p></li></ul></li><li><p>地物分类样本</p><ul><li>利用遥感影像进行语义分割的目的是将遥感影像中的每个像素与预先定义的地表覆盖类别关联起来。包含影像数据以及对应逐像素分类的栅格分类信息数据。</li></ul></li><li><p>变化检测样本</p><ul><li><u>用于定位及识别同一地理位置处多时态间的变化信息。需要前后两个时相的影像，并且基于统一分类体系对标签影像的图斑属性进行标注</u>。需要针对每种变化类型制定合理的判定准则和规范要求，必要时提供示例说明。</li></ul></li><li><p>立体多视样本</p><ul><li><p><u>样本集由密集匹配数据集构成，用于通过多视角遥感影像构建三维地表模型。</u></p></li><li><p>原始数据包括多视影像，以及对应的相机内外方位元素参数、影像覆盖范围的地面真值参考数据(主要为激光点云或产品级三维地表模型)。通过自动配准方法，将影像与高程数据进行匹配，形成样本数据。</p></li></ul></li></ul></li></ul></li></ul></li><li><p>地学对象及现象</p><ul><li><p>空间特征</p></li><li><p>光谱特征</p></li><li><p>时间特征</p></li></ul></li></ul><h4 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h4><ul><li><p>影响地物波谱特性的因素有哪些？</p></li><li><p>掌握遥感研究对象的特性，在遥感图像解译中有什么意义、作用？</p></li><li><p>如何获取、描述这些特性？如何建立特征库？</p></li><li><p>描述你了解的地物或者区域具体空间分布特点。也可以选择一位你熟悉的人。要求：详细准确。</p></li><li><p>请详细分析遥感研究对象特性之间的相关性？</p></li></ul><hr><h3 id="第三章-遥感数据的物理属性和成像性能"><a href="#第三章-遥感数据的物理属性和成像性能" class="headerlink" title="第三章 遥感数据的物理属性和成像性能"></a>第三章 遥感数据的物理属性和成像性能</h3><ul><li><p>应用的前提是需要获取对象的数据</p></li><li><p>遥感数据的属性由什么决定？</p></li><li><p>不同分辨率对应的目标</p></li><li><p>主动式传感器</p><ul><li><p>微波散射计</p></li><li><p>Lidar</p></li><li><p>SAR</p></li></ul></li><li><p>决定遥感数字图像量测性能及其上地物细部的再现能力的主要是<u>图像的成图比例尺</u></p></li></ul><h4 id="遥感数据的多源性"><a href="#遥感数据的多源性" class="headerlink" title="遥感数据的多源性"></a>遥感数据的多源性</h4><ul><li><p>遥感平台和载体的多层次</p><ul><li><p>地球同步轨道卫星（36,000 km）</p></li><li><p>太阳同步轨道卫星（500-10,00 km）</p></li><li><p>航天飞机（240-350 km）</p></li><li><p>高高度航空飞机（10,000-12,000 m）</p></li><li><p>中低高度航空飞机（500-8000 m）</p></li><li><p>直升飞机（100-2,000 m）</p></li><li><p>低空载体（800 m 以下）无人机</p></li><li><p>地面车辆（0-30 m）</p></li></ul></li><li><p>遥感卫星的种类</p><ul><li><p>测绘卫星</p></li><li><p>气象卫星</p></li><li><p>资源卫星</p></li><li><p>海洋卫星</p></li><li><p>环境卫星</p></li><li><p>制图卫星</p></li><li><p>夜光卫星</p></li></ul></li><li><p>传感器多样性</p><ul><li><p>遥感数据的多样性是由传感器决定的</p></li><li><p>传感器的成像方式</p></li></ul></li></ul><h4 id="遥感图像的量测性能与几何分辨率"><a href="#遥感图像的量测性能与几何分辨率" class="headerlink" title="遥感图像的量测性能与几何分辨率"></a>遥感图像的量测性能与几何分辨率</h4><ul><li><p>遥感图像的量测性能</p><ul><li><p>对地物细部和在其上的各个物体之间几何关系的再现能力</p></li><li><p>有很多因素对确定地物几何尺寸的精度有影响</p><ul><li><p>图像的不清晰度</p></li><li><p>图像的比例尺或分辨率。</p></li></ul></li><li><p>影响因素</p><ul><li><p>摄影图像上决定长度测量质量的原因</p><ul><li><p>物体摄影图像构像规律方面的误差</p><ul><li><p>图像的不清晰度</p></li><li><p>对直线透视规律的破坏</p></li></ul></li><li><p>量测物体图像方面的缺陷</p><ul><li><p>图像辨认</p></li><li><p>仪器影响</p></li></ul></li></ul></li></ul></li><li><p>图像比例尺的重要性</p><ul><li><p><u>真正对遥感图像量测性能及其上地物细部的再现能力有决定性作用的是图像的成图比例尺。</u></p></li><li><p>不同比例尺的图像对成图完整性有重要影响</p></li></ul></li><li><p>图像量测性能决定因素</p><ul><li><p>影响地物识别的图像比例尺要考虑许多因素才能加以确定</p><ul><li><p>测图比例尺，解译和测量工艺，对地图内容完整性的要求，已有的处理和量测设备，以及经济方面的考虑等。</p></li><li><p>对于遥感数字图像，决定其<u>图像量测性能及其上地物细部的再现能力的主要是几何分辨率</u></p></li></ul></li></ul></li><li><p>几何分辨率</p><ul><li><p>几何分辨率概念</p></li><li><p>与空间分辨率的区别</p></li><li><p>特殊地物对几何分辨率的要求</p></li><li><p>摄影图像比例尺与图像几何分辨力之间近似关系</p><ul><li>$R_g\approx \cfrac{1(mm)}{7(线 对)}\times\cfrac{1(m)}{1000(mm)}\times M$</li></ul></li></ul></li><li><p>空间分辨率与成图比例尺</p><ul><li><p>$e\times M\times 10^{-3}=C\times R$</p></li><li><p>R：遥感图像空间分辨率 (m)</p></li><li><p>M：可制作的合理成图比例尺(比例尺分母)</p></li><li><p>C：为图像几何校正系数，经几何校正以后的像元位置均方根差RMS，以像元为单位</p></li><li><p>e：为人眼的分辨率，通常采用0.2mm（0.1mm）</p></li><li><p>左边是一般图件允许的实地误差；右边是遥感图像校正后存在的实地误差。</p></li></ul></li><li><p>成图比例尺、航摄比例尺及图像地面分辨率参考</p><p>| 成图比例尺 | 航摄比例尺（规范规定） | 图像地面分辨（m） |<br>| ————— | ——————————— | ————————- |<br>| 1:5000     | 1:10000-1:20000        | 0.4-0.8           |<br>| 1:10000    | 1:20000-1:40000        | 0.8-1.6           |<br>| 1:25000    | 1:25000-1:60000        | 1.0-2.4           |<br>| 1:50000    | 1:35000-1:80000        | 1.4-3.2           |</p></li><li><p>成图比例尺与遥感图像空间分辨率</p><p>| 成图比例尺 | 尺空间分辨率（m）                                   |<br>| ————— | —————————————————————————- |<br>| 1：250000  | LANDSAT-7(15)                                       |<br>| 1：100000  | LANDSAT-7(15)<br />SPOT-4（10）                     |<br>| 1：50000   | SPOT-4（10）<br />SPOT-5(2.5)                       |<br>| 1：25000   | SPOT-5(2.5)<br />IKONOS-2(1)<br />QUICKBIRD-2(0.61) |<br>| 1：10000   | IKONOS-2(1)<br />QUICKBIRD-2(0.61)                  |<br>| 1：5000    | IKONOS-2(1)<br />QUICKBIRD-2(0.61)                  |</p></li></ul></li><li><p>各种遥感目的对空间分辨率的要求</p><ul><li><p>巨型地物与现象</p></li><li><p>大型地物与现象</p></li><li><p>中型地物与现象</p></li><li><p>小型地物与现象</p></li><li><p>不同地物和地学现象要求</p><ul><li><p>利用不同分辨率图像提取信息时，<u>可以利用的特征不同，处理方法不同。</u></p></li><li><p><u>涉及尺度</u></p></li></ul></li></ul></li></ul><h4 id="多光谱图像及光谱分辨率"><a href="#多光谱图像及光谱分辨率" class="headerlink" title="多光谱图像及光谱分辨率"></a>多光谱图像及光谱分辨率</h4><ul><li><p>光谱特性曲线与波段</p><ul><li>不同波段的图像及组合</li></ul></li><li><p>光谱分辨力概念</p></li><li><p>扫描成像类型图像</p><ul><li><p>扫描成像类型的多波段图像既可以分别解译，也可以多波段组合解译。</p><ul><li><p>单波段图像（波长在0.35~14μm范围内的某个波长区间）。<u>传感器光谱分辨率的选择是与它的探测目的相对应的，波段中心位置的选择要与地物特征光谱位置相对应</u>。</p><ul><li><p>以植物遥感光谱分辨率的选择为例，从0.4~2.5μm划分了植物的8个有效（可选）波段</p><ul><li><p>0.45~0.50μm，色素吸收波段。即在叶红素及叶绿素吸收区之内。其特性与红波段相似。</p></li><li><p>0.52~0.59μm，绿色反射波段。对区分不同林型及树种可能提供较多信息。</p></li><li><p>0.63~0.69μm，对区分有无植被、覆盖度及植物健康状况极为敏感。</p></li><li><p>0.70~0.74μm，过渡波段。一般仅能增加噪声，但也有特殊功能，如受金属毒害的植物在此波段范围内，其反射率表现最明显。</p></li><li><p>0.74~0.90μm，绿色植物（活的）的各种变量与反射率关系最敏感的波段，为植物通用波段。</p></li><li><p>1.10~1.30μm，在高反射区与水吸收区之间，能区分植物类别，对岩石可能也有用。</p></li><li><p>1.55~1.75μm，2.1~2.3μm，均是位于几个水吸收带之间的反射峰。对土壤及绿色植物有很强的对比。</p></li></ul></li></ul></li><li><p>多波段图像（波长在0.35~14μm范围内的若干个波长区间）。由于存在多个不同波长范围的地物辐射信息，可采用不同波段比较、假彩色合成等方式进行分析和解译。</p></li></ul></li></ul></li><li><p>TM图像的不同组合情况</p><ul><li><p>4、3、2类似于彩色红外图像，是一种标准假彩色图像，用于植被分类、水体识别。</p></li><li><p>3、2、1类似于仿制真彩色图像，用于各种地类识别。图像平淡、色调灰暗、彩色不饱和、信息量相对减少。</p></li><li><p>7、4、3类似于仿真彩色图像，用于居民地、水体识别。</p></li><li><p>7、5、4是一种非标准假彩色图像，图像偏蓝色，用于特殊的地质构造调查。</p></li><li><p>5、4、1是一种非标准假彩色图像，植物类型较丰富，用于研究植物分类。</p></li><li><p>4、5、3特点</p><ul><li><p>凡是与水有关的地物在图像中都会比较清楚</p></li><li><p>强调显示水体，特别是水体边界很清晰，益于区分河渠与道路</p></li><li><p>由于采用的都是红波段或红外波段，对其它地物的清晰显示不够，但对海岸及其滩涂的调查比较适合</p></li><li><p>具备标准假彩色图像的某些点，但色彩不会很饱和，图像看上去不够明亮</p></li><li><p>水浇地与旱地的区分容易。居民地的外围边界虽不十分清晰，但内部的街区结构特征清楚</p></li><li><p>植物会有较好的显示，但是植物类型的细分会有困难。</p></li></ul></li><li><p>3、4、5，它是一种非标准的接近于真色的合成方案。对水系、居民点及其市容街道和公园水体、林地的图像判读是比较有利的。</p></li><li><p>其中最常用方案</p><ul><li><p>使用4 、3、 2 （近红外、红、绿）配红、绿、蓝，形成标准假彩色图像，是一种在大量总结实际经验基础上的最常用方案。它的地物图像丰富，鲜明、层次好。植被以红色显示，主要用于资源环境和土地利用调查或更新等。</p></li><li><p>3、 4、 5（或7）配蓝、绿、红的合成方案。它是一种非标准的接近于真色的合成方案。（仿真彩色合成方案）它利用了TM图像较丰富的多光谱（红、近红外、短波近红外）对水系、居民点及其市容街道和公园水体、林地的图像判读是比较有利的。</p></li></ul></li><li><p>landsat8常用波段组合方式</p><ul><li><p>4、3、2：真彩色合成。</p></li><li><p>5、4、3：标准假彩色合成，植被显示为红色，植被越健康红色越亮，还可以区分出植被的种类，可用于监测植被、农作物和湿地。</p></li><li><p>7、6、4：假彩色合成，用到了短波红外波段，效果比较明亮，可用于城市监测。</p></li><li><p>6、5、2：假彩色合成，主要用于农作物监测。</p></li><li><p>7、6、5：假彩色合成，对大气层穿透能力较强。</p></li></ul></li><li><p>热红外图像</p><ul><li><p>色调与辐射功率有关，主要反映了温度的差别，如可以产生“热影”或“冷影”。某些小而热的目标，由于热物体的“耀斑”效应，可以在热图像上显示出来（按照同样的比例尺在其他图像上难以显示）。</p></li><li><p>热红外图像上的地物信息及相互关系随昼夜等时间因素会发生变化，如房屋与草地在白天和晚上的热红外图像上差别很大。</p></li></ul></li><li><p>微波成像类型图像</p><ul><li><p>波长范围在1m~1m。分为：毫米波（1mm~10mm），厘米波（1cm~10cm），分米波（10cm~100cm）几个波段。</p></li><li><p>微波遥感：被动和主动微波遥感两类。</p></li></ul></li></ul></li><li><p>光谱分辨率研究的重要作用</p><ul><li><p>开拓了遥感应用领域从利用综合波段记录电磁波信息，到分波段分别记录电磁波的强度，可以把地物波谱的微弱差异区分并记录下来，使遥感应用范围逐步扩大</p></li><li><p>专题研究中波谱段的选择针对性越来越强</p></li><li><p>信息提取可以提高分析解译效果。对于复杂的目标进行分离提取或解译时，往往不仅要利用其特征波段内的差异，还要利用各波段间的差异。</p></li><li><p><u>相比于光学成像卫星只能看到物质的形状、尺寸等信息，高光谱卫星具备的光谱成像技术，可使光谱与图像结合为一体，探测各类物质的具体成分。</u></p></li></ul></li><li><p>具体应用：比较分析</p></li><li><p>光谱响应与参比数据</p><ul><li><p>光谱响应标志</p><ul><li><p>作用：能分辨出目标的类型和条件。</p></li><li><p>依据：反射光谱曲线和发射光谱曲线。地物的光谱特性标志——对不同波长下的特定地面物体取得的自然辐射测定值。</p></li><li><p>存在的问题：光谱响应标志是可变的！</p></li></ul></li><li><p><u><strong>导致光谱响应标志可变性的因素</strong></u></p><ul><li><p>影响因素：</p><ul><li><p>时间效应、空间效应、大气和不同传感器等的影响。</p></li><li><p>时间效应：</p></li><li><p>空间效应：</p></li><li><p>大气的影响，也在某种程度上发生改变。</p></li><li><p>结果：这传感器测得的光谱响应标志是相对的和不确定的。</p></li></ul></li><li><p>光谱标志的可变性</p><ul><li>物体本身的某些特性会影响着它们的光谱响应标志。</li><li>大气的影响，使电磁波发生变化</li><li>空间：角度(BRDF)，位置</li><li>时间（晚上白天、季节）</li><li>传感器本身</li><li>地物本身（含水量 状态）</li></ul></li><li><p><u><strong>光谱标志可变性对应用的影响</strong></u></p><ul><li><p>分类时，要缩小光谱标志的可变性</p></li><li><p>变化检测时，可能要增强这种可变性</p></li></ul></li></ul></li><li><p>为何要引入参比数据</p><ul><li><p>原因：由于光谱响应标志的可变性，需要参比数据。</p></li><li><p>获取参比数据收集遥感待测目标、区域或现象的某些量测值或观测值。</p></li><li><p>这些数据可以从一个来源或数个来源取得</p></li><li><p><u><strong>参比数据用途</strong></u></p><ul><li><p>帮助遥感数据的分析和解译</p></li><li><p>校准传感器</p></li><li><p>验证遥感数据所提取的信息。</p></li></ul></li><li><p>参比数据的收集通常必须符合统计采样设计的原则。</p></li><li><p>地面实况与参比数据</p><ul><li><p>“地面”实况有关数据可以从空中取得，在分析小比例尺的高空或卫星图像时，就可利用较详细的航空图像作为参比数据。</p></li><li><p>如果是研究水文要素，那么“地面”实况实际上就是指“水域”的实况。</p></li></ul></li></ul></li></ul></li></ul><h4 id="辐射信息与辐射分辨力"><a href="#辐射信息与辐射分辨力" class="headerlink" title="辐射信息与辐射分辨力"></a>辐射信息与辐射分辨力</h4><ul><li><p>光谱亮度系数、比辐射率</p></li><li><p>辐射传输方程</p></li><li><p>辐射分辨率</p><ul><li>能区分两种辐射强度最小差别的能力</li></ul></li><li><p><u>地物的辐射特征的重要性</u></p><ul><li><p>对于某一个波段的图像，地物特征的识别主要依赖于它们的光谱响应及其变化。</p></li><li><p>如地物的形状与大小，仍然依赖于它的辐射特征与周围物体的不同（即色调的变化）来反映。</p></li><li><p>空间特征中的纹理结构，通过较小区域内光谱响应特征（色调）的变化频率来反映。</p></li><li><p>辐射特征与成像方式有关</p></li></ul></li><li><p>地物反射辐射</p></li><li><p>地物的热辐射</p><ul><li><p>地物的辐射功率与温度和发射率成正比</p></li><li><p>在热红外像片上其灰度与辐射功率成函数关系</p></li><li><p>温度（自然状态下）和发射率都与地物的热特性有关。</p></li><li><p>物体的热特性包括物体的热容量、热传导率和热惯量等。</p></li><li><p><u>不同时间</u>下地物的热辐射程度不同</p></li></ul></li><li><p>侧视雷达图像</p><ul><li>地形起伏与反射强度的关系</li><li>各种表面的反射</li><li>阴影处完全无信息，注意镜面反射的影响</li></ul></li></ul><h4 id="时间因素与时间分辨率"><a href="#时间因素与时间分辨率" class="headerlink" title="时间因素与时间分辨率"></a>时间因素与时间分辨率</h4><ul><li><p>研究对象的时间特性</p><ul><li>地表地物、气候、物候具有周期性和阶段性</li></ul></li><li><p>时间分辨率</p><ul><li><p>不同传感器的时间分辨率与目标的时间关系作用</p></li><li><p>时间分辨率的类型</p><ul><li><p>超短、短周期时间分辨率</p></li><li><p>中周期时间变化率</p></li><li><p>长周期时间变化率</p></li></ul></li><li><p>不同地物的时间要求</p><ul><li><p>地质地貌专题地图（秋末冬初或冬末春初）</p></li><li><p>“三北”防护林的遥感调查与制图（五月末）</p></li><li><p>解译海滨地区的芦苇地（五六月间）</p></li><li><p>编制黄淮海地区盐碱土分布图（三四月间）</p></li></ul></li><li><p><u>时间分辨率的作用</u></p><ul><li><p>选择最佳成像时刻的决定因素</p></li><li><p>遥感动态应用方面的重要作用</p></li><li><p>利用时间差以提高遥感的解译能力</p></li><li><p>数据库更新的重要参考因素</p></li><li><p>利用遥感图像解译、监测地面的动态变化。</p></li></ul></li></ul></li></ul><h4 id="遥感图像的成像性能"><a href="#遥感图像的成像性能" class="headerlink" title="遥感图像的成像性能"></a>遥感图像的成像性能</h4><ul><li><p>遥感图像的成像性能</p><ul><li><p>传递地物辐射（反射或发射）信息分辨率和最小尺寸地物的能力。</p></li><li><p>遥感图像反差可用辐射能量的函数计算</p></li><li><p>遥感图像揭示地物细部的能力</p><ul><li><p>四个指标</p><ul><li><p>图像分解力</p><ul><li><p>在一mm长的图像上能够将绝对反差的线条分开成像的数量。</p></li><li><p>摄影图像的反差换算成分解力的公式为</p><ul><li>$R_K=R(1-10^{-\Delta D})$</li></ul></li></ul></li><li><p>图像清晰度</p><ul><li><p>表示传递地物形状的能力，决定目视观测中有效的放大极限</p></li><li><p><del>刀刃曲线</del></p></li></ul></li><li><p>图像反差频率特性</p><ul><li>在一定空间频率范围（可以用像素长度为依据），将图像反差与地物光学反差进行比较</li></ul></li><li><p>图像解像力</p><ul><li><p>图像上最小的、但还能分辨的地物尺寸</p></li><li><p>相当于人眼的几何分辨率</p></li></ul></li></ul></li><li><p>图像的光谱响应</p></li></ul></li></ul></li><li><p>图像分解力的确定</p><ul><li><p>理想方法：由飞机上对布设在地面的专门标板进行成像。对标板摄影的条件应该相应于航空摄影的条件。</p></li><li><p>确定航空图像分解力</p><ul><li><p>严格方法往往难以实现，可以采用近似方法</p></li><li><p>测图像上最小的能分辨的长形要素的图像宽度，对量测结果做统计处理后，计算公式</p></li></ul></li><li><p>图像真实空间分辨率测定</p><ul><li><p>方法一</p><ul><li><p>求遥感图像上每一对检测点的间距并求和$𝐷_𝑠$</p></li><li><p>求出地形图上每一对同名点的间距并求和$𝐷_𝑝$</p></li><li><p>对它们的和取商得到图像的真实空间分辨率$𝑅_{𝑟𝑒s}$</p></li></ul></li><li><p>方法二</p><ul><li><p>分别计算n个检测点和n个同名点组成的封闭多边形的重心坐标$X_o,Y_o ,𝑋_{𝑜𝑡},𝑌_{𝑜𝑡}$</p></li><li><p>计算检测点到其多边形重心的距离之和$𝐷_𝑆^\prime$</p></li><li><p>计算同名点到其多边形重心的距离之和$𝐷_p^\prime$</p></li><li><p>求两个距离之和的商，即得到图像的真实空间分辨率$𝑅_{𝑟𝑒s}$</p></li></ul></li><li><p>传感器的光谱响应函数是波长的函数，是每个波长处接收的辐亮度与入射的辐亮度的比值</p></li></ul></li></ul></li><li><p><u>遥感图像的选择</u></p><ul><li><p>各类遥感图像</p></li><li><p>遥感图像的选择</p><ul><li><p>合适的传感器</p></li><li><p><u>最佳波段</u></p></li></ul></li><li><p><u>为何要做最佳波段选择？</u></p><ul><li><p>与多光谱或高光谱发展是否矛盾？</p></li><li><p>选择的依据与方法。</p></li><li><p>选择最佳波段需要考虑哪些因素？</p></li></ul></li><li><p><u>最佳图像含义</u></p><ul><li><p>为了使目标能被检测和识别，应要求信息具有足够大的强度，还应是地理现像呈节律性变化中最具有本质特性的信息</p></li><li><p>被探测目标与环境的信息差异最大、最明显</p></li><li><p>传感器空间分辨率和成像的时间</p></li><li><p>数据量</p></li></ul></li><li><p><u>合适的空间分辨率</u></p><ul><li><p>涉及成图比例尺的要求</p></li><li><p>各种类型的传感器获取的图像与成图比例尺的关系</p></li></ul></li><li><p><u>时间方面来考虑——“最佳时相”图像</u></p><ul><li><p>地物或现象本身的光谱特性</p></li><li><p>太阳高度角的变化</p></li><li><p>气象条件的影响</p></li><li><p>对于人文现象的遥感时相的选择，需要考虑政治和经济的变革时期。</p></li></ul></li><li><p><u>波段方面来考虑</u></p><ul><li><p>不论应用何种遥感方法，其基本目的是要将特定的目标从背景中探测出来。在电磁波谱的反射（或发射）谱段中，能否将目标从背景中探测出来，主要取决于目标与背景的光谱反射（或发射）率有否显著的差异。</p></li><li><p><u>目标与背景反射（或发射）率差异最显著的波长区间，即为最佳的遥感波段。</u></p></li></ul></li><li><p>具体方法</p><ul><li><p>目标反射率均方差目标与背景反射（或发射）率差异最显著的波长区间</p></li><li><p>最佳指数法</p></li><li><p>自适应波段选择</p></li><li><p>其他方法</p><ul><li><p>特征选择</p></li><li><p>定性分析</p></li><li><p>测度距离：采用标准化距离</p></li><li><p>散布矩阵</p></li></ul></li></ul></li></ul></li></ul><h4 id="思考题-2"><a href="#思考题-2" class="headerlink" title="思考题"></a>思考题</h4><ul><li><p>传感器的发展趋势</p></li><li><p>有何优点与问题</p></li><li><p>具体应用图像的时候要注意什么</p></li><li><p>为何要做最佳波段选择？与多光谱或高光谱发展是否矛盾？选择的依据与方法。选择最佳波段需要考虑哪些因素？</p></li><li><p>针对不同传感器获取的图像，对不同地物提取最佳波段做出选择。</p></li><li><p>说明选择的重要性、依据、方法、验证的依据以及存在的问题。</p></li></ul><hr><h3 id="第四章-遥感数据的信息性能"><a href="#第四章-遥感数据的信息性能" class="headerlink" title="第四章 遥感数据的信息性能"></a>第四章 遥感数据的信息性能</h3><h4 id="图像解译的可能性"><a href="#图像解译的可能性" class="headerlink" title="图像解译的可能性"></a>图像解译的可能性</h4><ul><li><p>遥感图像解译，关注可能性概念</p><ul><li><p>作为信息源的遥感图像</p></li><li><p>获取信息解译过程本身</p></li><li><p>方法可能性</p></li><li><p><u>数据可能性：空间、光谱、辐射、时间分辨率</u></p></li></ul></li><li><p>图像解译的可能性</p><ul><li><p>图像上的地物被识别和未被识别的事实是偶然事件</p><ul><li><p>对识别概率的评价</p><ul><li><p>事先评价（预测）：评论遥感图像的可解译性，对影响解译结果的主要因素予以考虑。可以选择图像获取和处理的最佳方法和技术手段，力求以给定的完整性、详细性和置信度完成解译工作。</p></li><li><p>事后评价：对结果的可靠性、完整性等评价</p></li></ul></li></ul></li><li><p>从简单地物的概念出发，计算识别复杂地物的概率简单地物到复杂地物关系，可以从两方面考虑</p><ul><li><p>由例证出发（样本）</p></li><li><p>从特征出发（样本的内在特征）</p><ul><li><p>普遍意义：一般情况如果某一概念仅与少数特征有关系，说明此概念可以在众多景物出现。</p></li><li><p>特殊：<u>如果某一概念与较多的特征有关系，说明具有这些特征的景物较少</u>。</p><ul><li><p>地物一：色彩、大小、位置和空间关系</p></li><li><p>地物二：色彩、大小、位置</p></li><li><p>地物三：色彩、大小</p></li><li><p>地物四：色彩</p></li></ul></li></ul></li><li><p>所谓“鬼城”指大片无人居住的小区组成的区域，利用遥感技术找到鬼城，可以选择以下特征</p><ul><li><p>利用高空间分辨率卫星影像，发现整个小区几乎没有车辆</p></li><li><p>利用热红外卫星影像，晚上识别不到小区的灯光</p></li><li><p>利用高分辨率卫星影像，发现整个小区几乎没有人</p></li></ul></li></ul></li><li><p>复杂地物识别概率</p><ul><li><p>在根据简单地物的概率计算出识别复杂地物的概率时，一般应该先知道作为复杂地物元素的简单地物的某些先验的知识或评价。</p></li><li><p>识别概率需要从传感器的几个分辨率去考虑</p></li></ul></li></ul></li></ul><h4 id="影响图像解译的因素"><a href="#影响图像解译的因素" class="headerlink" title="影响图像解译的因素"></a>影响图像解译的因素</h4><ul><li><p>简单几何体1与人工地物2的识别概率试验曲线。</p><ul><li><p>A代表解像力</p></li><li><p>L代表地物的最大线性尺寸</p></li></ul></li><li><p>不同形状地物对识别概率曲线的影响</p><ul><li>B越小，在相同L下分辨出的概率越大</li></ul></li><li><p>组成复杂地物要素数量与复杂性系数的关系</p><ul><li><p>K代表地物要素数量</p></li><li><p>C代表复杂性系数</p></li></ul></li><li><p>识别自然地物的典型概率曲线分类</p></li><li><p>几种主要地物探测识别需要的基本分辨率</p></li></ul><h4 id="地物识别的可能性"><a href="#地物识别的可能性" class="headerlink" title="地物识别的可能性"></a>地物识别的可能性</h4><ul><li><p>简单人工地物识别</p><ul><li><p><u>尺寸小，与周围背景比较，反差不大。</u></p></li><li><p>一般来讲，<u>它们有特殊的（典型的）形状</u>，这是解译人员必须关注的可能得到可靠结果的手段</p></li><li><p>简单人工地物识别概率的数学表示形式</p><ul><li><p>$P=Ce^{-(B \cfrac{A}{L})^2}$</p><ul><li><p>L——地物尺寸</p></li><li><p>A——遥感图像的解像力</p></li><li><p>B——形状的识别系数</p></li><li><p>C——影响复杂地物元素解译质量的相互位置系数。</p></li></ul></li></ul></li><li><p>简单人工地物可识别性分析</p><ul><li><p>B对理论识别曲线变化的影响</p></li><li><p>组成复杂地物的要素数量与复杂性系数的关系</p></li><li><p>在遥感图像上还能分辨出地物的最大元素（以最大尺寸表示的元素），地物有可能被识别。</p></li><li><p>在需要分辨尺寸和形状上都很相近，而在细部上有差别的地物时，L用细部的最大尺寸。</p></li></ul></li></ul></li><li><p>复杂地物的识别概率</p><ul><li><p>识别对象的特征</p><ul><li><p>简单对象，它们的属性来自对景物的直接观察和测度。</p></li><li><p>结构对象，结构对象由简单对象（或其它结构对象）以及它们之间的关系组成。</p></li></ul></li></ul></li><li><p>以上识别从空间分辨率的角度考虑</p><ul><li><p>除了空间分辨率 ，还有</p><ul><li><p>光谱分辨率的作用</p></li><li><p>辐射分辨率的作用</p></li><li><p>时间分辨率的作用；</p></li></ul></li></ul></li></ul><h4 id="提高地物解译概率的途径"><a href="#提高地物解译概率的途径" class="headerlink" title="提高地物解译概率的途径"></a>提高地物解译概率的途径</h4><ul><li><p><u>在给定图像比例尺的情况下，根据图像识别地物的概率，通过三个途径加以提高</u></p><ul><li><p>$P=e^{-(B\cfrac{m}{2RL\sqrt{\Delta D}})^2}$</p></li><li><p>提高图像的分解力（$R$）</p></li><li><p>提高图像反差（$\Delta D$）</p></li><li><p>建立良好的感受图像的条件（$B$即减少地物形状识别系数值）</p></li></ul></li></ul><h4 id="图像的信息性能"><a href="#图像的信息性能" class="headerlink" title="图像的信息性能"></a>图像的信息性能</h4><ul><li><p>信息传递通道的“通过能力”</p></li><li><p>图像的信息性能与混淆矩阵</p></li><li><p>图像的信息性能</p><ul><li><p>图像的一种能力，<u>在可理解的形式中反映地物和现象的详尽程度</u>，这个详尽程度是识别自然现象、识别地球物理成因、识别静止和运动状态中的自然和人工地物所必须的。</p></li><li><p>反映所传递的这些地面信息的质量和数量，将遥感图像的成像能力、量测能力和信息容量等三个特性统一在一起。</p><ul><li><p>遥感图像的成像能力</p></li><li><p>遥感图像的量测能力</p></li><li><p>遥感图像的信息容量</p></li></ul></li><li><p>不同比例尺图像的成像能力</p><ul><li><p>$C_{pa}$是成像能力的平均值</p></li><li><p>$m_c$是图像比例尺</p></li></ul></li><li><p>不同比例尺的图像量测能力</p><ul><li><p>$C_{ba}$是量测能力的平均值</p></li><li><p>$m_c$是图像比例尺</p></li></ul></li></ul></li><li><p>遥感图像的信息容量</p><ul><li>$Q=Q_{paS}+Q_{mbS}$</li></ul></li></ul><h4 id="识别过程的模式"><a href="#识别过程的模式" class="headerlink" title="识别过程的模式"></a><del>识别过程的模式</del></h4><h4 id="思考题-3"><a href="#思考题-3" class="headerlink" title="思考题"></a>思考题</h4><ul><li><p>通过影像分割得到的目标具有的特征包括</p><ul><li><p>大小</p></li><li><p>形状</p></li><li><p>阴影</p></li><li><p>纹理</p></li></ul></li><li><p>下列特征属于目标平面特征的是</p><ul><li><p>大小</p></li><li><p>形状</p></li><li><p>纹理</p></li></ul></li><li><p>与像元比较，目标比像元具有更多的特征，这些特别包括</p><ul><li><p>面积</p></li><li><p>形状</p></li><li><p>目标之间关系</p></li><li><p>纹理</p></li></ul></li><li><p>事先评价对图像解译有什么指导意义？</p></li><li><p>分析不同大小的地物解译对空间分辨率的要求。</p></li><li><p>分析提高地物解译的可能性的途径。</p></li><li><p>根据本章内容，分析遥感数据的信息性能对图像解译有什么作用？</p></li><li><p>对一幅具体图像的不同地物解译可能性做一个基本评价，与目视判读进行比较。</p></li></ul><hr><h3 id="第五章-遥感图像特征和解译标志"><a href="#第五章-遥感图像特征和解译标志" class="headerlink" title="第五章 遥感图像特征和解译标志"></a>第五章 遥感图像特征和解译标志</h3><ul><li><p>解译过程涉及：<u>数据，样本、特征，算法，精度评价</u></p></li><li><p>遥感图像特征</p><ul><li><p>特征的内涵</p></li><li><p>特征的种类</p></li><li><p>特征在解译中的作用</p></li><li><p>描述一个目标的方法与内容</p><ul><li><p>定性</p></li><li><p>定量</p></li><li><p>确定与模糊</p></li></ul></li></ul></li><li><p>图像的“色”和“形”</p><ul><li><p>图像解译建立在研究地物性质、电磁波性质及图像特征三者的关系之上。主要从图像特征来判断电磁波的性质，以确定地物的属性，即从图像特征来识别地物</p></li><li><p>地物电磁波特征的差异在图像上的反映就是各种各样的色、形信息。</p></li><li><p>整个遥感图像的图像要素或特征</p><ul><li><p>色：色调、颜色、阴影、反差</p></li><li><p>形：形状、大小、空间分布、纹理等。</p></li></ul></li><li><p>“形”只有依靠“色”来解译才有意义。</p></li></ul></li><li><p>空间域特征与频率域特征</p><ul><li><p>遥感图像上目标多包含周期性、非周期性成分、噪声、背景。在空间域分离有一定难度。通过变换在频率域处理</p></li><li><p>频谱与波谱一样，区别地物属性的主要依据。</p></li><li><p>图像的频谱表征了地物目标的空间频率特性，与地物的空间特征存在密切联系</p></li></ul></li><li><p><u>地物在遥感图像上的解译标志包括</u></p><ul><li><p><u>波谱响应</u></p></li><li><p><u>阴影</u></p></li><li><p><u>结构（纹理）</u></p></li><li><p><u>大小尺寸</u></p></li><li><p><u>形状</u></p></li></ul></li></ul><h4 id="解译标志的定义和分类"><a href="#解译标志的定义和分类" class="headerlink" title="解译标志的定义和分类"></a>解译标志的定义和分类</h4><ul><li><p>概念</p><ul><li><p>遥感图像光谱、辐射、空间和时间特征决定图像的视觉效果(时-空-谱) 、表现形式和计算特点，并导致物体在图像上的差别</p></li><li><p>作用</p><ul><li><u>区分遥感图像上物体或现象的可能性</u></li></ul></li><li><p>类别</p><ul><li>色调与色彩、形状、尺寸、阴影、细部（图案）、以及结构（纹理）等。</li></ul></li><li><p>色调与色彩</p><ul><li><p>色调与色彩对不同类型的遥感图像其意义不一样的</p><ul><li><p>可见光黑白图像， 地物的亮度和颜色都由色调来表达， 即黑白深浅的程度。（全色波段）</p></li><li><p>可见光彩色图像， 表现为亮度 （I）， 色调 （H）和饱和度 （S）值。</p></li><li><p>非可见光遥感图像</p><ul><li><p><u>热红外图像</u></p><ul><li><u>色调差别是物体辐射温度的差别</u></li></ul></li><li><p><u>侧视雷达图像</u></p><ul><li><u>色调差别是表示物体反射电磁波能量的大小</u></li><li>影响因素<ul><li>入射角</li><li>地面粗糙程度</li><li>电特性</li><li>极化</li></ul></li></ul></li><li><p><u>多光谱图像</u></p><ul><li><u>对彩色物体的色调判读，要按反射率的强弱与波长之间的关系来定。</u></li></ul></li></ul></li></ul></li></ul></li><li><p>形状 （轮廓）</p><ul><li><p>形状一般指物体或图形由外部的面或线条组合而呈现的外表。同一地物由于图像获取方式的不同，其形状可能不完全相同。例如，<u>空中俯视地物图像与侧视和斜视的地物图像不同。（形状是具有不确定性的）</u></p></li><li><p>通过比较中心投影图像、 侧视雷达图像、热红外图像和小比例尺图像，可以发现形状上的差异。</p></li><li><p>有很多种形状指数计算方法</p></li><li><p>目标的形状</p></li><li><p>像元的形状</p></li></ul></li><li><p>大小（尺寸）</p><ul><li><p>图像上地物的大小，与图像的空间分辨率有关，地物本身的尺寸有关。</p></li><li><p>地物图像的大小不仅影响面积的计算，其与构像比例尺的关系，常常形成所谓的混合像元。</p></li><li><p>有关图像覆盖面积与地面几何分辨率（从图像上所能辨认地面物体的最小尺寸）的关系。</p></li></ul></li><li><p>阴影</p><ul><li><p><u>可见光范围内的阴影</u></p><ul><li><u>本影和落影</u></li></ul></li><li><p><u>热红外图像上的阴影</u></p><ul><li><u>冷影和热影</u></li></ul></li><li><p><u>雷达影像</u></p><ul><li><u>盲区产生阴影</u></li></ul></li></ul></li><li><p>图案（细部）</p></li><li><p>纹理（结构）</p></li><li><p>目标之间的空间关系</p></li><li><p>位置与位置算子</p><ul><li><p>位置是指地物所处环境在图像上的反映， 即图像特定位置上目标(地物)与背景(环境)的关系。它对图像解译有间接的指引作用。</p></li><li><p>为了在图像上的特定位置识别某些地物， 可针对这些特别的位置设定一些特别的处理方法，称为位置算子</p></li></ul></li><li><p>遥感图像解译要素一览</p><ul><li><p>遥感构像规律</p><ul><li><p>地物波谱特性</p><ul><li><p>基本要素</p><ul><li>色调、色彩</li></ul></li><li><p>空间特性</p><ul><li><p>大小、形状、纹理</p></li><li><p>图形、高度、阴影</p></li></ul></li><li><p>生物地学规律</p><ul><li>位置、关系、变化</li></ul></li></ul></li><li><p>与生物地学规律的关系</p><ul><li><p>复杂程度</p><ul><li><p>单一</p><ul><li>色调、色彩</li></ul></li><li><p>简单</p><ul><li>大小、形状、纹理</li></ul></li><li><p>中等</p><ul><li>图形、高度、阴影</li></ul></li><li><p>复杂</p><ul><li>位置、关系、变化</li></ul></li></ul></li></ul></li></ul></li><li><p>四个层次的信息</p><ul><li><p>光谱特征</p></li><li><p>空间特征（平面的）</p></li><li><p>空间特征（高度的）</p></li><li><p>地物之间的空间关系</p></li><li><p>注意高空间分辨率图像与中低空间分辨率图像上特征的区别</p></li></ul></li></ul></li></ul></li><li><p>解译标志的类别</p><ul><li><p>解译标志——揭示标志</p><ul><li><p>解译标志：研究、比较和区分地物图像的条件。这项工作的结果用于地物图像的识别。</p></li><li><p>揭示标志：在目视观察时借以将物体彼此分开的被感知对象的典型特征。</p></li><li><p>但是在多数情况下，基于遥感图像识别地物并作出决定时，似乎并不是利用解译标志，而是利用揭示标志。</p></li><li><p>由识别的观点来看，解译标志就是以遥感图像的形式传递的揭示标志。</p></li></ul></li><li><p>直接标志——间接标志</p><ul><li><p>揭示标志和解译标志都可分为直接标志和间接标志。</p></li><li><p>直接标志</p><ul><li><p>是地物本身和它们的遥感图像所固有的。“摆在面上”，可用较为简单的观测和量测方法在图像上加以确定。</p><ul><li>包括色调（颜色）、形状、尺寸、阴影、细部（图案）和结构（纹理）。</li></ul></li><li><p>直接标志在不引用其它资料的情况下，在这样或那样的置信程度上，可以保证对地物的直接识别。通常情况下能够获取的直接标志越多，解译的结果就越可靠</p></li></ul></li><li><p>间接标志</p><ul><li><p>间接标志并不直接与物体有关。它们自己不能确保对物体的识别，但却能指示出用直接标志不能确定的，或在图像上没有成像的那些物体的存在，它们有助于排除由分析直接标志所作结论的多义性，还能取得物体的补充特性。</p></li><li><p>间接标志中有物体的位置（配置），物体间的相互关系和人类活动的结果，其中包括技术和机器作业的痕迹等。</p></li></ul></li><li><p>直接标志与间接标志具有相对性</p><ul><li>房屋提取中的阴影假设</li></ul></li><li><p>在图像上寻找物体的间接标志要比找直接标志复杂。在工作过程中，图像使用者需要有较全面的知识并对图像进行仔细分析。一般来说，经验较丰富的解译人员能够更广泛地利用间接标志。</p></li><li><p>直接标志和间接标志在复杂的地理信息空间中都存在较大的不确定性</p></li><li><p>地质遥感解译间接解译标志</p><ul><li><p>水系：由于水系能很好的反映地面的岩性、构造等地质现象，水系的发育与地貌地质相互联系，某些水系的格局能反映地质构造的特点。</p></li><li><p>地貌：地貌的形态决定于一定的岩性构造等地质基础，同时也决定于一定的气候水文等地质条件，不同的地貌形态是不同岩性、构造在不同内外动力作用下的结果。</p></li><li><p>水文：水文主要是指陆地水文特征，包括水体、土壤的含水性、地下水的溢出带等，特别是在干旱区为主要的解译标志。</p></li><li><p>植被的分布：尤其在识别矿产的露头时，对蚀变带的识别，可将植被异常作为重点研究对象。</p></li><li><p>环境地质及人工标志：古代与现代的采场、采坑、矿冶遗址、渣堆是地质找矿的标志，耕地的排布反应地形地貌的特征，是历史上活动与地质体有关的痕迹。</p></li></ul></li></ul></li><li><p>永久性和临时性的</p><ul><li><p>揭示标志和解译标志分为永久性和临时性的。</p></li><li><p>永久性标志是形状、尺寸、结构（图案）、位置和物体之间的联系</p></li><li><p>临时性的标志是细部、色调（颜色）、阴影和物体作用的痕迹。</p></li><li><p>所谓的永久性标志通常涉及图像的不变特征。临时性的标志与图像特征的可变性和局限性有关。有多种因素可以导致同一地物或现象的图像特征发生变化，主要包括空间环境变化、时间变化、地物本身的特性以及传感器的性能。</p></li><li><p><u>色调、阴影是临时性的指标</u></p></li></ul></li></ul></li><li><p>典型样区解译标志</p><ul><li><p>多光谱图像</p><ul><li><p>水体 </p><ul><li>深蓝色，条带或者面状，平滑细腻</li></ul></li><li><p>水田</p><ul><li><p>粉红色，条带状，平滑细腻</p></li><li><p>灰白色，条带状，平滑细腻</p></li></ul></li><li><p>林地</p><ul><li><p>鲜红色，不规则片状，有立体粗糙感</p></li><li><p>深红色，不规则片状，有立体粗糙感</p></li></ul></li><li><p>草灌</p><ul><li><p>深青色，夹杂一点红色，不规则片状，平滑有粗糙感</p></li><li><p>青黄色，夹杂一点青色和红色，不规则片状，平滑有粗糙感</p></li></ul></li><li><p>居民地</p><ul><li><p>青色，不规则面状，较粗糙，网格状有立体感</p></li><li><p>青白色，不规则面状，较粗糙，网格状有立体感</p></li></ul></li><li><p>阴影</p><ul><li>深黑色，条状，平滑</li></ul></li><li><p>滩涂</p><ul><li>亮白色，平滑细腻，线絮状</li></ul></li><li><p>铁路公路</p><ul><li>亮白色，规则线状，平滑为右图中亮白色部分</li></ul></li><li><p>工矿地</p><ul><li>亮白色，片状，光滑为右图中白色区域</li></ul></li><li><p>典型地物图像特征表</p></li></ul></li><li><p>SAR图像与光学图像对比分析</p></li><li><p>解译标志组成结构图</p></li></ul></li><li><p>视觉心理与解译标志的关系</p><ul><li><p><u>解译标志是启发式标志，或称为“人为的”标志，由有经验的解译人员在研究地物和地物的图像时提出并加以归纳的结果</u>。</p></li><li><p>对世界的感知，部分依赖于对客观事物的感觉，另一部分，可能是更重要的的一部分，来自于人的思维。</p></li><li><p>格式塔心理学</p><ul><li>“格式塔”定义为“一个各部分之间相互影响的有机整体，而整体大于各部分之和。”</li></ul></li><li><p>知觉定律</p><ul><li><p>接近性</p></li><li><p>相似性</p></li><li><p>良好的连续性</p></li><li><p>封闭性</p></li></ul></li><li><p>格式塔心理学在图像解译中的作用</p><ul><li><p>遥感图像解译的目的就是要获取地物的边界。</p></li><li><p>实际情况，由于地物本身的复杂性以及传感器性能的限制，地物在图像上往往不是连续的或者完全一致或者闭合的。</p></li><li><p>需要考虑地物在空间上分布接近、色调一致、连续性、完整性</p></li></ul></li><li><p>三维信息的获取</p><ul><li><p>阴影</p></li><li><p>梯度变化倾斜成像</p></li><li><p>立体像对</p></li></ul></li></ul></li><li><p>针对具体的目标描述特征和解译标志</p><ul><li><p>前面提到的解译标志是针对所有目标的：共性</p></li><li><p>不同的目标所用的解译标志是不一样的：个性</p><ul><li>水体解译 土壤解译 地质解译</li></ul></li><li><p>可以根据不同传感器考虑</p></li></ul></li></ul><h4 id="遥感图像特征与解译标志的关系"><a href="#遥感图像特征与解译标志的关系" class="headerlink" title="遥感图像特征与解译标志的关系"></a>遥感图像特征与解译标志的关系</h4><ul><li><p>遥感图像解译要素</p><ul><li><p>遥感构像规律</p><ul><li><p>地物波谱特性</p><ul><li><p>基本要素</p><ul><li>色调、色彩</li></ul></li><li><p>空间特性</p><ul><li><p>大小、形状、纹理</p></li><li><p>图形、高度、阴影</p></li></ul></li><li><p>生物地学规律</p><ul><li>位置、关系、变化</li></ul></li></ul></li><li><p>与生物地学规律的关系</p><ul><li><p>复杂程度</p><ul><li><p>单一</p><ul><li>色调、色彩</li></ul></li><li><p>简单</p><ul><li>大小、形状、纹理</li></ul></li><li><p>中等</p><ul><li>图形、高度、阴影</li></ul></li><li><p>复杂</p><ul><li>位置、关系、变化</li></ul></li></ul></li></ul></li></ul></li><li><p>四个层次的信息</p><ul><li><p>光谱特征</p></li><li><p>空间特征（平面的）</p></li><li><p>空间特征（高度的）</p></li><li><p>地物之间的空间关系</p></li><li><p>注意高空间分辨率图像与中低空间分辨率图像上特征的区别</p></li></ul></li><li><p>特征</p><ul><li><p>原始图像特征</p></li><li><p>变换后的特征</p></li><li><p>其他特征</p></li></ul></li><li><p>IKONOS传感器波段特征</p></li><li><p>IKONOS图像各波段统计特征值</p></li><li><p>光谱之间相关</p></li></ul></li><li><p>像元形状指数</p><ul><li><p>高空间分辨率图像的特点</p></li><li><p>像元形状指数计算</p></li><li><p>主要特点</p><ul><li><p>一种描述局域形状特征的空间指数</p></li><li><p>计算具备光谱相似性的邻接像元组的维数</p></li><li><p>能探测20个以上的方向</p></li><li><p>较小的计算代价。</p></li></ul></li></ul></li><li><p>由同质图像获取<u>对象的解译标志</u>（判读的实质）</p><ul><li><p>农业用地，相邻农业用地之间清晰的边界将有助于分类，因为农业景观的边界是相对稳定的，而作物类型常常是变化的。</p></li><li><p>OBIA的核心思想是把对象(Object)作为图像特征提取和分析的最小处理单元。相对于传统的基于像素(pixel-based)的处理方式而言，OBIA方法是随着商业化高分辨率图像的出现，而逐渐受到研究者的重视。</p></li><li><p><u>分割的特点在某个尺度下分割是最优的。(无最优尺度)</u></p></li><li><p><u>区域的均匀性和像素的连通性</u></p><ul><li><p>均匀性是指该区域中的所有像素满足基于某些特征的相似性准则</p></li><li><p>连通性是指该区域内任意两个像素存在可以连接的路径。</p></li></ul></li><li><p>目视判读是一种定性定量的分析方法，通过比较分割得到的目标和人工判读的目标接近的程度，来评价分割的效果</p></li><li><p>目标具有的信息</p><ul><li><p>目标自身的信息：</p><ul><li><p><u>每个波段的光谱信息</u></p></li><li><p><u>形状信息</u></p></li><li><p><u>纹理特征</u></p></li><li><p><u>类间信息</u></p></li><li><p><u>原始的灰度图像比较</u></p></li></ul></li></ul></li><li><p><u>面向对象分析方法的优势</u></p><ul><li><p>模拟人类感知和观察目标的方式</p></li><li><p>减小图像局部的光谱变化，增强同质性，减少椒盐效应</p></li><li><p>减小类内方差，增加特征空间的可区分度</p></li><li><p>能进一步提取图像的结构、形状等几何属性</p></li><li><p>矢量化的输出能更有效的与GIS系统结合。</p></li></ul></li></ul></li><li><p>灰度共生矩阵</p></li></ul><h4 id="遥感图像的时空特性"><a href="#遥感图像的时空特性" class="headerlink" title="遥感图像的时空特性"></a>遥感图像的时空特性</h4><ul><li><p>空间和时间准则</p><ul><li><p>对于同一区域的多幅图像（包括立体图像），可以考虑地物的空间特性、时间特性、运动特性等。</p></li><li><p>空间准则</p><ul><li><p>对于同一区域的多幅图像（包括立体图像），可以考虑地物的空间特性、时间特性、运动特性等。</p></li><li><p>多角度遥感数据</p><ul><li><p>获取信息更为丰富。但是也有一定的难度。</p></li><li><p>几何纠正问题</p><ul><li><p>分辨率不一致</p></li><li><p>局部形变不一样</p></li><li><p>相同地物在不同的角度具有不同的灰度值。</p></li></ul></li></ul></li></ul></li><li><p>时间准则</p><ul><li><p>时间特性：地物发生、发展和演化过程</p></li><li><p>节律：地物或现象在时间序列上的周期性重复出现。</p></li><li><p>反映在图像上例如，由于地物热辐射的差别，白天和晚上的热图像是不一样的。</p></li></ul></li><li><p><u>空间特性和时间特性的转化</u></p><ul><li><p>地物随着时间的变化：表现为图像上位置的不同，即物体的活动特性</p></li><li><p>地物在某个固定位置上的性质改变，可以揭示物体的时间特性。</p></li></ul></li></ul></li><li><p>光谱信息与时空特性的结合</p><ul><li><p>实际环境中只有二维的显示设备，需要利用人眼的特性，将三维的图形图像信息通过视图变换的方法显示到二维设备上，以达到三维的视觉效果</p></li><li><p>时间序列的应用</p></li></ul></li></ul><h4 id="地物统计特征的构造"><a href="#地物统计特征的构造" class="headerlink" title="地物统计特征的构造"></a>地物统计特征的构造</h4><ul><li><p><u>玫瑰图</u></p><ul><li><p>利用玫瑰图进行分类</p><ul><li><p>聚类因子</p></li><li><p>聚类准则</p></li></ul></li></ul></li></ul><h4 id="遥感图像中的独立变量"><a href="#遥感图像中的独立变量" class="headerlink" title="遥感图像中的独立变量"></a>遥感图像中的独立变量</h4><ul><li><p>亮度</p></li><li><p>温度</p></li><li><p>色彩和色扇</p><ul><li><p>通过色彩变换构造新的独立变量：亮度、色调、饱和度</p></li><li><p>为了便于对照， 可以按照亮度的变化， 将色彩空间分成不同的扇形， 其中半径大小反映了饱和度的变化， 扇形弧度反应色调标志</p></li><li><p>色扇分析：通过将作为标准的地物按光谱属性的差异分别将它们标在扇形相应的位置上，可以得到地物解译的色彩标准， 可进行解译工作。</p></li></ul></li><li><p>绿度(植被指数)</p><ul><li>$NVI=(IR-R)/(IR+R)$)</li></ul></li><li><p>反照度</p><ul><li>反照度指太阳入射地面后，地面照度发射到卫星上去的物理总量</li></ul></li><li><p>湿度</p><ul><li>与土壤含水量有关，与表观热惯量有关，而表观热惯量是反照度的函数，可以利用遥感信息获取。</li></ul></li><li><p>植被状态指数</p><ul><li>通过植被状态指数与土壤湿度之间的关系来反演，而植被状态指数与植被指数有关。</li></ul></li></ul><h4 id="思考题-4"><a href="#思考题-4" class="headerlink" title="思考题"></a>思考题</h4><ul><li>为什么直接标志和间接标示具有相对性？</li><li>雷达图像是斜距投影，其图像的变形与其它图像不同。它影响空间特征解译表现在哪两个方面</li><li>生成玫瑰图的关键是什么？如何提取线状地物？</li><li>判断地物的类别有很多的特征和指标。有些是可见的，有些是不可见的，需要去发现和构造。请详细列出能够区别地物类别属性的特征。除了教材提到的特征外，还有什么特征可以来补充描述或者识别地物类别？可以举具体的目标加以说明。</li><li>分析遥感图像解译标志之间存在的相关性。</li><li>利用某个区域某个传感器图像做特征分析。</li><li>说明掌握目标特征及解译标志的意义。</li><li>图像对象的含义，如何获取？</li><li>遥感图像解译使用的特征和以及对应的解译标志分别有哪些？可以分为几个层次？每个层次之间相关性如何？</li><li>根据自己的理解给出像元形状指数（PSI）的含义</li></ul><hr><h3 id="第六章-遥感图像解译方法"><a href="#第六章-遥感图像解译方法" class="headerlink" title="第六章 遥感图像解译方法"></a>第六章 遥感图像解译方法</h3><ul><li><p>$d_i(X)=f(X,M_i,\Sigma_i,…\ ,\omega_i)$</p></li><li><p>$y=f(DN_\lambda)=aDN_\lambda+b$</p></li><li><p>提取的信息类别及应用</p><p>| 提取信息类别   | 应用                                           |<br>| ——————— | ——————————————————————— |<br>| 空间位置       | 平面位置，高程                                 |<br>| 类别信息       | 土地覆盖、目标识别（建筑物、植被和农作物等）   |<br>| 物理量和指标   | 温度、大气成分、土壤含水量、植被指数、浑浊指数 |<br>| 特定地物和姿态 | 火灾，水灾，线性构造，遗迹探察                 |<br>| 环境信息       | 环境监测                                       |<br>| 变化监测       | 上述对象随时间变化的情况                       |</p><p>| 类型     | 主要方法                | 应用领域                                                     | 数据源                    | 传感器空间分辨率 | 传感器光谱分辨率 | 传感器时间分辨率 |<br>| ———— | ———————————- | —————————————————————————————— | ————————————- | ———————— | ———————— | ———————— |<br>| 图像分类 | 监督<br />非 监督       | 农林、国土资源调查与规划                                     | TM，ETM， SPOT，ZY等      | 中               | 中               | 中               |<br>| 定量遥感 | 反演模型                | 生态环境及动态监测                                           | MODIS、AVHRR、 高光谱数据 | 低               | 高               | 高               |<br>| 目标识别 | 图像分割<br /> 模式识别 | 城市信息更新、军事目标探测、农林地块精细识别、大型工程设施监控、<strong>新闻热点、社会问题</strong> | 高空间分辨率图像          | 高               | 低               | 高中低           |</p></li><li><p>解译过程</p><ul><li><p>目的：数据到信息的转化</p></li><li><p>采用什么数据：遥感图像？地面数据？选择依据？</p><ul><li><p><u><strong>样本数据的作用</strong></u></p><ul><li><p>训练</p></li><li><p>检查验证参数</p></li><li><p>精度评定</p></li></ul></li></ul></li><li><p>选择什么特征或影响因子：</p><ul><li><p>分类：特征、解译标志</p></li><li><p>反演：独立变量？中间变量？人文因子？</p></li></ul></li><li><p>采用什么方法或模型：</p><ul><li><p>定性或定量；统计、机理的。</p></li><li><p>对于计算机：如何确定模型，实测数据如何得到？</p></li></ul></li><li><p>结果验证。</p></li></ul></li></ul><h4 id="目视判读和计算机辅助分类"><a href="#目视判读和计算机辅助分类" class="headerlink" title="目视判读和计算机辅助分类"></a>目视判读和计算机辅助分类</h4><ul><li><p>目视判读</p><ul><li><p>判读依据</p><ul><li><p>光谱响应曲线与光谱特性曲线</p></li><li><p>响应曲线和特性曲线的区别</p></li></ul></li><li><p>判读特征和解译标志</p><ul><li><p>地物波谱特性</p><ul><li><p>基本要素</p><ul><li>色调、色彩</li></ul></li><li><p>空间特性</p><ul><li><p>大小、形状、纹理</p></li><li><p>图形、高度、阴影</p></li></ul></li><li><p>生物地学规律</p><ul><li>位置、关系、变化</li></ul></li></ul></li><li><p>与生物地学规律的关系</p><ul><li><p>复杂程度</p><ul><li><p>单一</p><ul><li>色调、色彩</li></ul></li><li><p>简单</p><ul><li>大小、形状、纹理</li></ul></li><li><p>中等</p><ul><li>图形、高度、阴影</li></ul></li><li><p>复杂</p><ul><li>位置、关系、变化</li></ul></li></ul></li></ul></li></ul></li><li><p><u>判读原则</u></p><ul><li><p>从“已知”到“未知”</p></li><li><p>从“整体”到 “局部”</p></li><li><p>先易后难</p></li><li><p>对象语义与范围的确定可以交互进行</p></li><li><p>逐步近似判读</p></li></ul></li><li><p>判读方法</p><ul><li><p>图像判读方</p><ul><li><p>直判法</p></li><li><p>对比法</p></li><li><p>邻比法</p></li><li><p>历史比较（动态对比）法</p></li><li><p>综合辨认法</p></li></ul></li><li><p>不同类别图像的判读</p><ul><li><p>单波段图像</p></li><li><p>多光谱图像</p></li><li><p>热红外图像</p></li><li><p>雷达图像</p></li><li><p>多时相图像</p></li></ul></li></ul></li><li><p>判读精度</p><ul><li><p>影响判读精度的因素</p></li><li><p>提高判读质量的方法</p></li></ul></li><li><p><u>目视判读应该注意的问题</u></p><ul><li><p>数据选择</p></li><li><p>图像处理</p></li><li><p>图像增强</p></li><li><p><del>图像变换（不需要）</del></p></li><li><p>特征选择</p></li><li><p>方法应用</p></li></ul></li><li><p>立体图像判读</p></li><li><p><u>目视判读的优缺点</u></p><ul><li><p>精确</p></li><li><p>主观</p></li><li><p>劳动强度高</p></li></ul></li></ul></li><li><p>计算机辅助分类</p><ul><li><p>基本情况</p><ul><li><p>分类依据</p></li><li><p>使用特征</p></li><li><p>分类方法</p></li><li><p>精度评价</p></li><li><p>优缺点</p></li><li><p>注意问题</p><ul><li><p>数据选择</p></li><li><p>图像处理</p></li><li><p><del>图像增强（不需要）</del></p></li><li><p>图像变换</p></li><li><p>特征选择</p></li><li><p>方法应用</p></li></ul></li></ul></li><li><p>基于统计的分类方法</p><ul><li><p>最大似然分类</p></li><li><p>ISODATA算法聚类分析</p></li></ul></li><li><p>基于目标的分类方法</p><ul><li><p>减小椒盐噪声</p></li><li><p>尺度</p></li><li><p>异质性值</p><ul><li><p>光谱信息权</p></li><li><p>形状信息权</p></li><li><p>光谱异质性值</p></li><li><p>形状异质性值。</p></li><li><p>光谱信息权不可能小于形状信息权，要以光谱为主</p></li></ul></li><li><p>基于目标的信息提取</p><ul><li><p>类层次结构以及提取信息的内容</p></li><li><p>基于模糊理论的信息提取</p><ul><li><p>优点</p><ul><li><p>利用隶属度函数将分割获取的图像对象特征转化为模糊值</p></li><li><p>不同特征之间可以组合，这样的特征不需要是相同的特征</p></li><li><p>提供了明确的和可调整的特征描述</p></li><li><p>通过模糊运算和层次类型描述，能够进行复杂的特征描述</p></li></ul></li></ul></li><li><p>一个模糊分类系统的基本结构</p></li><li><p>特征值模糊化</p></li><li><p>模糊规则库</p></li><li><p>去模糊化</p></li><li><p>分类器</p><ul><li><p>最邻近法</p></li><li><p>基于知识的分类</p></li></ul></li><li><p>E-cognition多尺度分割分类的相关参数</p></li><li><p><u>分类的关键</u></p><ul><li><p>特征的可选择性以及可分离性</p></li><li><p><u>多尺度分割提供大量的特征，选择最佳的有利于信息提取的特征是基于目标的分类的关键所在</u></p></li></ul></li></ul></li></ul></li><li><p>支持向量机</p><ul><li><p>特点：在解决小样本、非线性及高维模式识别中表现出许多特有的优势，能够推广应用到函数拟合等其他机器学习问题中</p></li><li><p>线性可分</p><ul><li>间隔最大</li></ul></li><li><p>线性不可分</p><ul><li>松弛变量ξ 和惩罚因子𝐶</li></ul></li><li><p>对于高维非线性</p><ul><li><p>将训练样本从原始空间映射到一个更高维的空间，使得样本在这个空间中线性可分，如果原始空间维数是有限的，即属性是有限的，那么一定存在一个高维特征空间是样本可分</p></li><li><p>核函数是二元函数，输入是变换之前的两个向量，其输出与两个向量变换之后的内积相等</p></li><li><p>用线性分类方法求解非线性问题分为两步：使用一个变换将原空间的数据映射到新空间；在新空间用线性分类学习方法从训练数据中学习分类模型</p></li><li><p>此时，核函数就隆重登场了，核函数的价值在于它虽然也是将特征从低维到高维的转换，但核函数可以事先在低维上进行计算，而将实质上的分类效果表现在了高维上</p></li></ul></li><li><p>分类方法</p><ul><li><p>一类对余类SVM</p></li><li><p>一类对一类SVM</p></li><li><p>有向无环图SVM</p></li><li><p>二叉树 SVM</p></li></ul></li></ul></li><li><p>人工神经网络</p><ul><li><p>神经网络的组成单元——神经元</p></li><li><p>人工神经网络</p></li><li><p>反向传播算法</p></li><li><p>梯度下降法具体计算步骤</p></li><li><p>卷积神经网络</p><ul><li><p>全连接的不足</p><ul><li><p>参数数量太多</p></li><li><p>没有利用像素之间的位置信息</p></li><li><p>网络层数限制</p></li></ul></li><li><p><u>卷积神经网络优点</u></p><ul><li><p>局部连接</p></li><li><p>权值共享</p></li><li><p>下采样</p></li></ul></li><li><p>.卷积神经网络的示意</p><ul><li><p>卷积：使原信号特征增强，降低噪音</p></li><li><p>池化：减少数据处理量、保留有用信息</p></li><li><p>最常用的激活函数</p></li><li><p>全连接层与分类器</p></li></ul></li><li><p>网络架构</p></li><li><p>计算过程</p><ul><li><p>向前传播阶段</p></li><li><p>向后传播阶段</p></li></ul></li><li><p>卷积神经网络的训练</p></li><li><p>卷积神经网络的特性</p><ul><li><p>局域感受野：每一网络层的神经元与上一层的神经单元连接为局部连接，局部连接的结构不仅可以简化网络计算量，还可以有效提取方向线段、拐点、端点等初级视觉特征</p></li><li><p>权值分享：在同一特征平面内的所有神经元共享同一权值，有效的减少网络中的参数数量，和局部感受野一起，使得卷积神经网络具有位移不变性的特性</p></li><li><p>二次抽样又称为子采样：在第一次抽样结果的基础上再次进行的空间域或时间域的采样过程，处理有效降低网络复杂度，降低特征图的分辨率，减少对位移、旋转和缩放的敏感性</p></li></ul></li><li><p>卷积神经网络的优缺点</p><ul><li><p>优点</p><ul><li><p>输入图像和训练网络的拓扑结构能很好的吻合，对几何变换、形变、光照具有一定程度的不变性</p></li><li><p>特征提取和模式分类同时进行</p></li><li><p>权值共享特性可以减少网络的训练参数数量，简化复杂的神经网络结构，使其具有更强的适应性</p></li><li><p>局部子采样结构导致卷积神经网络只需用少量的计算即可扫描整幅待分类图像，适用于目标检测的应用</p></li></ul></li><li><p>缺点</p><ul><li><p>网络实现比较复杂</p></li><li><p>样本数据量十分庞大，为了提高卷积神经网络训练的泛化能力，需要大量的已知类别的训练样本，样本选取的复杂性及工作量影响了卷积神经网络在实践中的应用</p></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>遥感图像解译的质量要求</p><ul><li><p>评价分类的质量</p><ul><li><p><u>解译的可靠性</u></p><ul><li><p>可靠性指标来自混淆矩阵评价指标</p><ul><li><p>总体精度</p></li><li><p>Kappa 系数，反映分类的可靠性</p></li><li><p>混淆矩阵（可能性）</p></li><li><p>生产者（制图者）精度</p></li><li><p>用户精度。</p></li><li><p>大部分遥感图像处理系统能用一幅地表真实图像或地表真实感兴趣区计算一个混淆矩阵</p></li></ul></li></ul></li><li><p><u>解译的完整性</u></p><ul><li>对解译完整性的评价一般以质量指标来表示，即所获得的信息是否满足给定的任务。在个别情况下，也进行数量的评价，即所获信息占完整信息的多大百分比</li></ul></li><li><p>解译的及时性</p></li><li><p>解译的明显性</p></li></ul></li></ul></li></ul><h4 id="遥感地学分析"><a href="#遥感地学分析" class="headerlink" title="遥感地学分析"></a>遥感地学分析</h4><ul><li><p><u>地理相关分析</u></p><ul><li><p>背景</p><ul><li><p>地理要素特点</p><ul><li><p>在一定的区域范围内，地理环境中的各种自然景观、地理要素之间存在着相互依存、相互制约的关系。</p></li><li><p>遥感信息综合反映了地球系统各要素的相互作用、相互关联，各要素或地物的遥感信息特征之间也必然具有一定的相关性。</p></li><li><p>利用遥感数据认知地理信息，需要考虑这种相关性</p></li></ul></li><li><p>概念</p><ul><li><p>地理相关分析法：研究某个区域地理环境内各要素之间的相互关系、相互组合特征。</p></li><li><p>应用于遥感地学分析，通过对这些因子特点及相互关系的研究，从各个不同的角度来分析、推导出某个专题目标的特征。</p></li><li><p><u>在遥感图像上寻找与目标相关性密切的间接解译标志</u></p></li></ul></li><li><p>目的</p><ul><li>充分认识地物之间以及地物与遥感信息之间的相关性，并借助这种相关性，在遥感图像上寻找目标识别的相关因子，通过图像处理，提取出这些相关因子，从而推断和识别目标本身。对某一要素分类或识别，<u>该要素本身在图像上没有表现，与其相关的其他要素可能在图像上表现得比目标更明显。</u></li></ul></li><li><p>应用</p><ul><li>环境污染遥感监测，水土流失，热岛效应，耕地生产力遥感监测，耕地环境和健康质量遥感监测</li></ul></li><li><p>方法</p><ul><li><p>主导因素：为了取得较好的遥感分析效果，在相关分析中，首先要考虑与专题目标有关的主导因素</p></li><li><p>非主导因素：当主导因素在遥感图像上反映不明显的情况下，可以进一步寻找与目标有关，且在图像上反映较明显的非主导因素。</p></li><li><p>研究它们与目标的相互组合特征，从而确定专题目标的空间和属性分布特征及其差异</p></li></ul></li></ul></li><li><p><u>主导因素分析方法</u></p><ul><li><p>基本思想</p><ul><li><p>一个地区自然环境的特点是由自然和人为综合因素决定的。在多种因素中，又会有一、二个起主导和决定作用的因素。分析一个地区的遥感图像，提取某个专题特征信息时，应当先找出它的主导因素。</p></li><li><p>对于不同的目的，其主导因素是不同的</p></li><li><p>同一目的中，不同等级的分类系统主导因素也可能不一</p></li></ul></li><li><p>地形因子相关分析-土壤自动分类</p></li><li><p>具体过程</p><ul><li><p>确定分类系统</p></li><li><p>相关变量</p></li><li><p>DEM 的获取</p></li><li><p>建立数学模型，确定不同土壤类型的定量地形因子和判别指标</p></li><li><p>分类及结果评价：分类精度与因子有效性</p></li></ul></li></ul></li><li><p><u>相关分析法（非主导因素相关分析方法）</u></p><ul><li><p>确定某一专题目标的相关因子取决于对这一区域自然与人文环境特征的深刻认识。</p></li><li><p>在某些区域条件下，专题目标与其它的环境因子之间的关系可能更为复杂，往往难于直接找出明显相关的因子。</p></li><li><p>在这种情况下，进行各因子的数量化统计分析，确定有明显效果的相关变量</p></li></ul></li></ul></li><li><p><u>环境本底法</u></p><ul><li><p>基本思想</p><ul><li><p>环境本底：了解一个地区的区域概况以及分析该地区地理环境的总体规律，在分析环境背景中，搞清区域内正常的组合关系、空间分布规律、正常背景值。</p></li><li><p>在这个基础上，寻找异常，并追根求源，找出异常原因，通过成因机制分析在更大范围内，寻找与异常有关的环境特征。</p></li></ul></li><li><p>异常地物表现</p><ul><li><p>近地表的矿床和矿化地层，经风化后形成元素富集的分散流和分散晕（矿化晕），从而造成元素的地球化学异常。由于过量的金属元素对植物的毒害和抑制作用，引起植物体内化学成分的相应变化，在植物形态和色泽上有所反映，从而出现明显的植物异常</p></li><li><p>植被异常晕信息的提取</p><ul><li><p>植被在不同波段反射光谱反射率的变化。</p></li><li><p>观察植物反射光谱的近红外吸收边缘的红边蓝移，根据经验，植被发育不正常，其叶绿素浓度下降。叶绿素光谱吸收带与近红外波段反射峰之间的反射光谱陡坡段（即红边）向短波方向偏移几个nm，倾斜也增大。烃类物质对植物光谱蓝移也有一定的影响。</p></li><li><p>微小的偏移需要高光谱的支持</p></li></ul></li><li><p>遥感图像的作用</p><ul><li>遥感传感器可以获得这种异常发生的时间、范围、强度等的有用信息，通过遥感数据，利用植物光谱特征的变化，可作出植物异常图，再结合地面调查、采样分析、钻探证实，追根求源，不仅可以寻找到矿源及新矿化带，还可以研究植物分布与地下矿化带之间关系等。</li></ul></li></ul></li><li><p>应用领域</p><ul><li><p>矿化晕、地球化学元素迁移规律</p></li><li><p>过量的金属元素对植物的毒害和抑制作用：锌，铜，瓦斯</p></li><li><p>环境污染（如酸雨）和病虫害对森林植被的损害</p></li><li><p>热源体、热异常</p></li><li><p>放射性矿物所辐射出的射线</p></li><li><p>其他</p></li></ul></li></ul></li><li><p><u>分层分类法（多阶分类法）</u></p><ul><li><p>按层次一步步地分类，在层次间不断加入遥感与非遥感的决策函数，从而组成一个最佳逻辑决策树。用传统的地学方法和概念，按现在的信息传输和信息相关体系建立信息树。</p></li><li><p>由于信息并非都能从遥感图像上得以反映，在建立信息树的过程中，必须不断地补充其它资料（如一些边界条件、分类参数等），以逐步满足某种分类的需要，最后完善这个最佳逻辑决策树，得出满意的分类结果。</p></li></ul></li></ul><h4 id="遥感数据反演"><a href="#遥感数据反演" class="headerlink" title="遥感数据反演"></a>遥感数据反演</h4><ul><li><p>关于定量遥感</p><ul><li><p>问题的提出</p></li><li><p>目的：定量的获取关注的某些目标的定量指标</p></li><li><p>数据</p></li><li><p>方法</p></li><li><p>产品</p></li><li><p>应用</p></li></ul></li><li><p>反演涉及的正逆问题</p><ul><li><p>辐射传输方程正问题的研究：从物理模型到散射辐射观测的计算机数值模拟。</p></li><li><p>逆问题的研究：从散射辐射理论模拟以及实验观测数据到各类环境特征参数反演以及结构重建。</p></li><li><p>反演中存在的不确定解问题</p></li><li><p>对于未知的反演参数来说，遥感观测数据是非常有限的。根据有限个遥感观测数据来反演众多的地表参数，往往是抓住了决定遥感信号的关键参数，<u>但是反演模型精度与参数数目之间却很难达到完美</u></p></li><li><p>热红外遥感，影响遥感观测信号的因素有</p><ul><li><p>地表的物理状况、地表发射率、地形、地表温度、大气廓线</p></li><li><p>在平坦的地面上，地表发射率和地表温度是最敏感的影响因素</p></li><li><p>在平坦的地面上，地表发射率和地表温度是最敏感的影响因素</p></li></ul></li><li><p>遥感反演模型的解的唯一性和稳定性常常不能得到充分保证。</p></li><li><p><u>解的唯一和稳定性解的唯一性</u></p><ul><li><p>指反演模型的解能否唯一确定，它的实现主要是依靠增加问题的约束条件，如增加观测数据，利用多波段数据、多角度数据，利用先验知识等。</p></li><li><p>解的稳定性：反应了模型的鲁棒性，即对观测数据中的误差的宽容性。</p></li></ul></li></ul></li><li><p>反演基本方法</p><ul><li><p>不考虑中间具体的物理过程，基于统计理论的地面参数的反演。利用回归算法建立生物量与遥感信息的回归模型</p><ul><li><p>简单、好理解，但精度低</p></li><li><p>拟合函数是关键</p></li></ul></li><li><p>面向过程，基于物理机理的目标参数的反演。</p><ul><li>精度高，但参数不易获得</li></ul></li><li><p>两者的结合</p></li></ul></li><li><p>水质监测反演</p><ul><li><p>水质监测反演模型的算法</p></li><li><p>监测的水质指标</p></li></ul></li><li><p>遥感监测反演的可能性</p><ul><li><p>一旦水体被污染，水体的光谱特性就会发生变化。水体中可溶性物质的浓度直接影响光在水中的吸收与后向散射。</p></li><li><p>光与水体的相互作用所产生的不同特征使得水质监测成为可能，只要从遥感数据中提取出水体反射信号，就能够反演其水质。</p></li><li><p>基于统计学理论的水质遥感反演</p></li><li><p>遥感数据反演—-机理方法</p></li><li><p>地下水埋深遥感监测的方法</p><ul><li><p>水文地质遥感信息分析法：基于假设的理论知识和大量的实地考察进行估计，缺点是评价精度不确定</p></li><li><p>地学要素遥感分析法：提取遥感图像上与地下水相关的环境因子信息，根据这些因子与地下水间的关系，来监测和反演区域地下水状况，但在湿润地区，环境因子易受人工灌溉和大气降水影响反演精度较低</p></li><li><p>热红外遥感地表热异常监测法：利用热红外波段来测定地表温度，分析热红外遥感图像上表现出温度异常，从而判断地下水的存在，此方法适于浅层空隙水的监测和地下水溢出带的判断，但无法实现地下水及其动态变化的定量化</p></li><li><p>遥感信息定量反演模型：通过选取实验指标，构建数学或物理模型，将从遥感图像获取的信息与实际观测数据联系起来，通过模型来定量反演地下水。</p></li></ul></li><li><p>地下水埋深反演</p></li><li><p>遥感温度反演</p><ul><li><p>分裂窗算法</p><ul><li><p>LANDSAT8数据反演</p></li><li><p>各参数的获取</p></li></ul></li><li><p>其他反演算法</p><ul><li><p>基于图像的反演 </p></li><li><p>单窗算法</p></li><li><p>单通道算法</p></li></ul></li></ul></li><li><p>土壤湿度反演</p></li><li><p>温度植被干旱指数</p></li></ul></li></ul><h4 id="混合像元分解"><a href="#混合像元分解" class="headerlink" title="混合像元分解"></a>混合像元分解</h4><ul><li><p>混合像元与纯净像元</p><ul><li><p>典型像元：一个像元内仅包含一种地物。对应的该类地物称为典型地物。</p></li><li><p>混合像元：一个像元内包含几种地物。</p></li><li><p>混合像元的分类</p></li><li><p>存在的问题</p></li><li><p>如果每一混合像元能够被分解而且它的覆盖类型组分(端元组分)占像元的百分含量(丰度)能够求得，分类将更精确，因混合像元的归属而产生的错分、误分问题也就迎刃而解，即混合像元分解。</p></li></ul></li><li><p>混合像元现象</p><ul><li><p><u><strong>引起混合像元的原因</strong></u></p><ul><li><p>图像空间分辨率的限制及地面物质具有异质性</p></li><li><p>其他地物、大气、传感器本身的性能影响。</p></li><li><p>遥感图像重取样(Resampling)</p><ul><li>若取样后像元的灰度值经由相邻图像灰度值内插所得，则结果也造成额外的空间混合(Additional Spatial Mixing)现象。</li></ul></li></ul></li><li><p><u>混合像元分解的意义</u></p><ul><li><p>提高分类精度</p></li><li><p>提高图像处理的自动化、智能化水平</p></li><li><p>可提高对小目标的识别能力</p></li></ul></li><li><p><u>传统方法的不足</u></p><ul><li><p>最大似然分类法处理这种问题，经常得到较差的分类精度</p></li><li><p>对高光谱图像进行分类时，随着光谱波段数或特征数(维度)的增加，反而需要较大量的训练样本作为参数的估计，分类效率变低，分类精度不理想。</p></li></ul></li></ul></li><li><p>混合像元：端元组分选取</p><ul><li><p>分解模型一旦选定，直接影响分类精度的因素就是混合像元端元组分的选取。各种分解模型实现的关键环节是首先要正确获取主要地物指标的参照光谱值，从中选取可作为纯净像元(端元)的地物目标光谱值。</p></li><li><p><u>端元组分选择的正确与否在很大程度上决定着像元分解的精度。</u></p></li><li><p>方法</p><ul><li><p>从光谱库提取端元</p></li><li><p>在缺乏野外光谱测量数据或者光谱库的情况下，从图像本身获得</p><ul><li>从图像自身选出的组成成分易于获得、简化和具有与数据相同的度量尺度。</li></ul></li><li><p>在缺乏野外光谱测量数据或者光谱库的情况下，当纯净像元在图像上很难找到或者根本没有的时候，端元的识别存在相当的问题</p><ul><li><p>当端元不能由样本表示的时候，其他的方法可以用来解决这个问题：通常是通过一元或者多元回归技术从外部数据源来获得估计的端元 。</p></li><li><p>分辨率比较低的图像</p></li></ul></li></ul></li></ul></li><li><p>线性光谱混合求解</p><ul><li><p>提高混合像元分解精度的可能性</p><ul><li><p>最佳端元光谱的选择，选择最能代表图像的全部端元，达到增加了不同端元光谱差距的目的，提高分解精度。</p></li><li><p>减小端元内部的变化。</p></li><li><p>扩展传统混合光谱分解模型。</p></li><li><p>选择性进行端元光谱的分解。</p></li></ul></li></ul></li><li><p>像元二分模型</p><ul><li><p>假设</p><ul><li><p>像元只有两部分构成</p></li><li><p>线性合成</p></li></ul></li><li><p>植被覆盖像元二分模型</p></li><li><p>像元三分模型</p></li></ul></li></ul><h4 id="多阶抽样估计"><a href="#多阶抽样估计" class="headerlink" title="多阶抽样估计"></a>多阶抽样估计</h4><ul><li><p>问题的提出</p><ul><li><p>转换方法</p><ul><li><p>基于像元的尺度转换：</p><ul><li><p>用高分辩率图像上的变量或参数的平均值来推出低分辨率图像的变量或参数平均值；</p></li><li><p>基于遥感图像多阶抽样估算地物面积 。</p></li></ul></li><li><p>基于对象的尺度转换</p></li></ul></li><li><p>对于大范围的地物调查</p><ul><li><p>低空间分辨率遥感图像：工作量较少，成本比较低，但精度通常不能满足要求</p></li><li><p>高空间分辨率遥感图像：精度能满足要求，但工作量大，成本也会比较高；</p></li></ul></li></ul></li><li><p>多种图像的结合（遥感图像多阶抽样估算地物面积）</p><ul><li><p>基本思想</p><ul><li><p>多阶可变概率抽样。</p><ul><li><p>根据图像分层，确定样本单元</p></li><li><p>使每一阶图像的分辨率逐级提高</p></li><li><p>使后一阶样本是前一阶样本的一部分，抽样的概率与通过逐级解译图像所得到的预估值成正比。</p></li></ul></li></ul></li><li><p>多阶可变概率抽样</p><ul><li><p>条件</p><ul><li><p>总体的每个单元必须有已知的概率，被抽中的概率不必相等</p></li><li><p>样本必须用随机抽样的方法抽取</p></li><li><p>当根据样本进行估值时，必须考虑抽取的概率</p></li></ul></li></ul></li><li><p>精度评价</p></li><li><p>满足多阶可变概率抽样的三个条件</p><ul><li><p>可以容易观察到大面积地区范围内的各种地物的差别。很容易勾绘出调查对象总体（如灌溉地）的界线。（有已知的概率且不一定相等）</p></li><li><p>用随机数字表中的灌溉地的累计数进行一阶样本单元抽取</p></li><li><p>求解估计值的过程是以可变概率为基础的</p></li></ul></li></ul></li></ul><h4 id="思考题-5"><a href="#思考题-5" class="headerlink" title="思考题"></a>思考题</h4><ul><li><p>ISODATA算法聚类分析中什么情况下分裂？什么情况下合并？什么情况结束迭代？如何确定类别？</p></li><li><p>影响遥感反演精度的因素？</p><ul><li>模型、样本数据、辐射几何校正</li></ul></li><li><p>如何提高反演精度？</p></li><li><p>分析解译方法在数据到信息转换过程中的重要性</p></li><li><p>叙述每种解译方法的基本思想、流程，分析其适用性、优点及不足</p></li><li><p>解译过程中用到的直接特征与间接特征各有哪些？</p></li></ul><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="附录1：卫星相关信息"><a href="#附录1：卫星相关信息" class="headerlink" title="附录1：卫星相关信息"></a>附录1：卫星相关信息</h3><h4 id="高分系列卫星"><a href="#高分系列卫星" class="headerlink" title="高分系列卫星"></a>高分系列卫星</h4><ul><li><p>高分一号 (GF-1)</p><ul><li><p>2013年4月26日在酒泉发射升空，设计寿命5-8年(低轨一般4年）。</p></li><li><p><u>配置了2台2米分辨率全色/8米分辨率多光谱相机，4台16米分辨率多光谱宽幅相机</u></p></li><li><p>主要用户为国土资源部、农业部和环境保护部“高分一号”在雅安地震、甘肃岷县地震、东北洪涝灾害、华北华东雾霾中获取了大量精准数据。矿产执法中发挥了重要作用，判断某矿区是否进行非法开采。</p></li></ul></li><li><p>高分二号（GF-2）</p><ul><li><p>2013年8月19日发射，寿命5-8年，卫星国产化率达98%。</p></li><li><p><u>全色分辨率为1米、多光谱分辨率为4米幅宽45公里（IKONIS是11公里） ，具有优势。同时还具有高辐射精度、高定位精度和快速姿态机动能力等特点</u></p></li><li><p>高分二号的功用也与一号不尽相同主要用户为国土资源部、住房和城乡建设部、交通运输部、林业局</p></li></ul></li><li><p>高分三号（GF-3）</p><ul><li><p><u><strong>我国首颗C频段多极化高分辨率微波遥感卫星</strong></u></p></li><li><p>2016.8.10日 在太原成功发射。分辨率可高达1米，12种工作模式，设计寿命长达8年，达到了世界同类卫星先进水平，填补了我国自主高分辨率多极化合成孔径雷达遥感数据空白</p></li></ul></li><li><p>高分四号（GF-4）</p><ul><li><p><strong>地球同步轨道卫星</strong></p></li><li><p>2015年12月29日发射，<u>我国首颗地球同步轨道高分辨率卫星（50米分辨率可见光、400米分辨率中波红外）</u>，设计使用寿命8年。</p></li></ul></li><li><p>高分五号（GF-5）</p><ul><li><p><strong>高光谱卫星</strong></p></li><li><p>于2018年5月9日在太原成功发射</p></li><li><p>填补中国国产卫星此前无法有效探测区域大气污染气体的空白，通过对大气污染气体、温室气体、气溶胶等物理要素的监测，动态反映中国大气污染状况。</p></li><li><p>同时，高分五号卫星可对内陆水体、陆表生态环境、蚀变矿物、岩矿类别探测，为中国环境监测、资源勘查、防灾减灾等行业，提供高质量、高可靠的高光谱数据。</p></li><li><p>轨道高度705km、倾角98.2度的太阳同步轨道, 发射质量约2800kg，整星功率1700W，设计寿命为8年。</p></li><li><p>配置有6台先进有效载荷，观测谱段覆盖紫外至长波红外</p><ul><li><p>大气环境红外甚高光谱分辨探测仪</p><ul><li>光谱范围为2.4~13.3μm</li></ul></li><li><p>大气痕量气体差分吸收光谱仪</p><ul><li><u>光谱分辨率0.3~0.5nm，空间分辨率48km (穿轨方向) 、13km (沿轨方向)</u></li></ul></li><li><p>全谱段光谱成像仪</p><ul><li><u>空间分辨率20m (0.45~2.35μm) 、40m (3.5~12.5μm)，地面覆盖宽度60km</u></li></ul></li><li><p>大气主要温室气体监测仪</p><ul><li>可探测二氧化碳和甲烷等温室气体</li></ul></li><li><p>大气气溶胶多角度偏振探测仪</p><ul><li><u>星下点空间分辨率优于3.5km</u></li></ul></li><li><p>可见短波红外高光谱相机</p><ul><li>330个光谱通道，光谱分辨率为5nm (VNIR) 、10nm (SWIR)，光谱范围0.4~2.5μm，<u>空间分辨率30m，地面覆盖宽度60km</u></li></ul></li></ul></li></ul></li><li><p>高分六号（GF-6）</p><ul><li><p><strong>高分六号主要是面向农业农村、林业和防灾减灾等应用的卫星</strong></p></li><li><p><strong>我国第一颗具备红边波段传感器的卫星</strong></p></li><li><p>它搭载了两个具备大幅宽的光学相机，并在宽幅相机新增了4个波段，特别是增加了能够有效反映作物特有光谱特性的红边波段。<u>配置2米全色/8米多光谱高分辨率相机（观测幅宽90公里）</u></p></li><li><p>3.16米多光谱中分辨率宽幅相机（观测幅宽800公里）</p></li><li><p><strong>高分六号是高分一号的“升级版”</strong></p></li><li><p>该星与高分一号卫星组网使遥感数据获取的时间分辨率从4天缩短到2天。极大提高了遥感数据的获取规模和时效，有效弥补国内外已有中高空间分辨率多光谱卫星资源的不足。</p></li></ul></li><li><p>高分七号（GF-7）</p><ul><li><p><strong><u>首颗亚米级(0.65m)高分辨率测绘卫星</u></strong></p></li><li><p>2019年11月3日，在太原成功发射<u><strong>我国首颗亚米级(0.65m)高分辨率光学传输型立体测绘卫星</strong></u>,实现我国民用1:10000比例尺卫星立体测图</p></li></ul></li><li><p>高分八号（GF-8）</p><ul><li>高分三四五六七号尚未发射，高分八号卫星发射成功。2015年6月26日14时22分，高分八号卫星在我国太原卫星发射中心成功发射升空，卫星顺利进入预定轨道</li></ul></li><li><p>高分九号（GF-9）</p><ul><li><p><strong>光学遥感卫星</strong></p></li><li><p>2015年9月14日在酒泉成功发射，是一颗<strong><u>光学遥感卫星，地面像元分辨率最高可达亚米级</u></strong>。2020.8.23高分九号05星成功发射</p></li></ul></li></ul><h4 id="高景系列卫星"><a href="#高景系列卫星" class="headerlink" title="高景系列卫星"></a>高景系列卫星</h4><ul><li><p>SuperView-1（高景-1号）</p><ul><li><p>2016年12月28日01/02星于太原升空。该卫星是中国航天科技集团公司商业遥感卫星系统的首发星，由2颗<u><strong>分辨率为0.5米</strong></u>的光学小卫星组成，也是当前<strong>我国分辨率最高的商业遥感卫星</strong>。</p></li><li><p>高景一号卫星可设定拍摄连续条带、多条带拼接、按目标拍摄多种采集模式，此外还可以进行立体采集，单次最大可拍摄60 km×70 km影像。</p></li><li><p>2018.1.9 高景-1号03/04星升空</p></li></ul></li></ul><h4 id="吉林一号（长春光机所）"><a href="#吉林一号（长春光机所）" class="headerlink" title="吉林一号（长春光机所）"></a>吉林一号（长春光机所）</h4><ul><li><p>2015.10.7日发射，我国第一颗自主研发的高分辨率商用遥感卫星组，开创了我国商业卫星应用的先河。</p></li><li><p>具备常规推扫、大角度侧摆、同轨立体、多条带拼接等多种成像模式。<u>该星分辨率为全色0.72米、多光谱2.88米。</u></p></li></ul><h4 id="资源系列卫星"><a href="#资源系列卫星" class="headerlink" title="资源系列卫星"></a>资源系列卫星</h4><ul><li><p>资源一号（ CBERS中巴卫星）</p><ul><li><p>CBERS-01（资源一号01星）已退役</p></li><li><p>CBERS-02 （资源一号02星）已退役</p><ul><li><p><u>2.36米分辨率、27公里幅宽高分辨率全色相机</u></p></li><li><p><u>19.5米分辨率、113公里幅宽的多光谱CCD相机</u></p></li><li><p><u>258米分辨率、890公里幅宽的宽视场成像仪。</u></p></li></ul></li><li><p>CBERS-02B （资源一号02B星）已退役</p></li><li><p>CBERS-02C （资源一号02C星）</p><ul><li><p><u>P全色5米</u></p></li><li><p><u>MS多光谱10米</u></p></li><li><p><u>HR相机2.3米</u></p></li></ul></li><li><p>CBERS-03 2013.12.9未进入预定轨道—失败</p></li><li><p>CBERS-04 （资源一号04星）2014年12月7升空</p></li></ul></li><li><p>资源三号（项目共规划了4颗卫星）</p><ul><li><p>ZY-3 01星（2012.1.9太原）</p><ul><li><p><u>一台2.5米分辨率的全色相机</u></p></li><li><p>两台4米分辨率全色相机按照正视、前视、后视方式排列，进行立体成像，可以测制1∶5万比例尺地形图</p></li><li><p>一台6米分辨率的多光谱相机，包括蓝、绿、红和近红外四个波段</p></li></ul></li><li><p>ZY-3 02星（2016.5.31太原)</p><ul><li><p>前后视相机分辨率从3.5米提高到优于2.7米，提高了立体测绘精度。</p></li><li><p>02星消除了正视相机与多光谱相机指向之间的6°的夹角，使两台相机的指向一致，更加方便多光谱影像与正视全色影像的融合应用。</p></li></ul></li><li><p>ZY-3 03星（2020.7.25太原)</p><ul><li>生产全国1:5万比例尺基础地理信息产品，开展1:2.5万以及更大比例尺地图的修测和更新，展开国土资源调查和监测</li></ul></li></ul></li></ul><h4 id="各种传感器"><a href="#各种传感器" class="headerlink" title="各种传感器"></a>各种传感器</h4><div class="table-container"><table><thead><tr><th>获取图像的传感器名称</th><th>空间分辨率<br />全色/多光谱</th><th>光谱波段数</th><th>量化等级</th><th>时间分辨率（天）</th><th>应用尺度</th></tr></thead><tbody><tr><td>LANDSAT7-ETM</td><td>15/30</td><td>7</td><td>8</td><td>16</td><td>大中尺度</td></tr><tr><td>LANDSAT8-OLI</td><td>15/30</td><td>9</td><td>12</td><td>16</td><td>大中尺度</td></tr><tr><td>SPOT5-CCD</td><td>2.5/10</td><td>4</td><td>8</td><td>3-26</td><td>中小尺度</td></tr><tr><td>IRS-CCD</td><td>5.8</td><td>4</td><td>8</td><td>5</td><td>中小尺度</td></tr><tr><td>CBERS-CCD</td><td>19.5</td><td>4</td><td>8</td><td>5,26</td><td>中小尺度</td></tr><tr><td>IKONOS-CCD</td><td>1/4</td><td>4</td><td>11</td><td>11</td><td>小尺度</td></tr><tr><td>QUICKBIRD-CCD</td><td>0.6/2.4</td><td>4</td><td>11</td><td>1-5</td><td>小尺度</td></tr><tr><td>WORLDVIEW4-CCD</td><td>0.31/1.24</td><td>4</td><td>11</td><td>1</td><td>小尺度</td></tr><tr><td>TERRA和AQUA-MODIS</td><td>250,500,1000</td><td>36</td><td>12</td><td>1/2</td><td>大尺度</td></tr></tbody></table></div><h5 id="LANDSAT"><a href="#LANDSAT" class="headerlink" title="LANDSAT"></a>LANDSAT</h5><ul><li><p>LANDSAT 1-3</p><ul><li><p>MSS多光谱扫描仪（Multi-spectral Scanner）</p><ul><li><p>存在全景变形</p></li><li><p>空间分辨率为79m</p></li><li><p>共5个波段</p><ul><li><p>MSS4（绿）</p></li><li><p>MSS5（红）</p></li><li><p>MSS6（红外）</p></li><li><p>MSS7（红外）</p></li><li><p>MSS8（热红外）</p></li></ul></li></ul></li></ul></li><li><p>LANDSAT 4-5</p><ul><li><p>MSS多光谱扫描仪（Multi-spectral Scanner）</p></li><li><p>TM专题制图仪（Thematic Mapper）</p><ul><li><p>存在全景变形</p></li><li><p>多光谱分辨率30m</p></li><li><p>共7个波段</p><ul><li><p>TM1波段（0.45-0.52微米）：用于区别土壤植被，区别各种农作物。</p></li><li><p>TM2波段（0.52-0.60微米）：正常农作物绿光反射区。</p></li><li><p>TM3波段（0.63-0.69微米）：是农作物覆盖度、作物叶绿素吸收光谱分析的最佳范围。</p></li><li><p>TM4红外波段（0.76-0.90微米）：可用于测定各种植物的生物量。</p></li><li><p>TM5红外波段（1.55-1.75微米）：可用于作物生长期内叶绿素浓度、水分含量 的推定和作物分类，监测作物需水状况和土壤墒情。</p></li><li><p>TM6热红外波段（10.4-12.5微米）：可用于作物热异常和地表热分布探测。</p></li><li><p>TM7红外波段（2.08-2.35微米）：可用于土壤类型、作物水分状况等研究</p></li></ul></li></ul></li></ul></li><li><p>LANDSAT 6</p><ul><li>ETM</li></ul></li><li><p>LANDSAT 7</p><ul><li><p>ETM+增强型专题制图仪</p><ul><li><p>增加全色波段，分辨率15M</p></li><li><p>多光谱分辨率30m</p></li><li><p>ETM+6波段分辨率提高到60M</p></li><li><p>辐射定标精度较Landsat 5提高1倍</p></li></ul></li></ul></li><li><p>LANDSAT 8</p><ul><li><p>OLI运营性陆地成像仪（Operational Land Imager）</p><ul><li><p>共9个波段</p></li><li><p>与TM相比</p><ul><li><p>线阵推扫成像</p></li><li><p>波段5的波段范围调整为0.845–0.885 μm，排除了0.825μm处水汽吸收的影响</p></li><li><p>全色波段范围较窄，从而可以更好区分植被和非植被区域</p></li><li><p>新增了海岸观察谱段（波段1）新增了卷云识别谱段（波段9）</p></li></ul></li></ul></li><li><p>TIRS热红外传感器（Thermal Infrared Sensor）</p></li></ul></li></ul><h5 id="SPOT"><a href="#SPOT" class="headerlink" title="SPOT"></a>SPOT</h5><ul><li><p>SPOT 1-3</p><ul><li>每个像元地面的大小为10m×10m</li></ul></li><li><p>SPOT 4</p><ul><li><p>全色波段0.51-0.73μm改为波段(0.61-0.68μm</p></li><li><p>增加了一个SWIR（Short Wave Infrared，短波红外）波段</p></li><li><p>POAM3极地臭氧和烟雾测量仪（Polan Ozone and Aerosol Measurement）</p></li></ul></li><li><p>SPOT 5</p><ul><li><p>地面分辩率在全色模式下从10m提高到5m和2.5m</p></li><li><p>在M模式下所有3个可见光波段（B1，B2，B3）的分辩率从20m提高到10m；</p></li><li><p>重用SPOT1和SPOT3的波段(0.51-0.73μm)</p></li><li><p>全色0.49-0.69</p></li><li><p>多光谱有4个波段</p><ul><li><p>波段1 0.5-0.59μm 绿</p></li><li><p>波段2 0.61-0.68μm 红</p></li><li><p>波段3 0.79-0.89μm 近红外</p></li><li><p>波段4 1.58-1.75μm 短波红外</p></li></ul></li></ul></li><li><p>SPOT 6-7</p><ul><li><p>全色1.5m</p></li><li><p>多光谱6m</p><ul><li><p>蓝色：0.45-0.52</p></li><li><p>绿色：0.53-0.59</p></li><li><p>红色：0.62-0.69</p></li><li><p>近红外：0.76-0.89</p></li><li><p>全色：0.45-0.75</p></li></ul></li></ul></li></ul><h5 id="IKONOS"><a href="#IKONOS" class="headerlink" title="IKONOS"></a>IKONOS</h5><ul><li><p>全色，空间分辨率1m</p></li><li><p>4个波段，空间分辨率4m</p><ul><li>蓝、绿、红和近红外</li></ul></li></ul><h5 id="GEOEYE-1"><a href="#GEOEYE-1" class="headerlink" title="GEOEYE-1"></a>GEOEYE-1</h5><ul><li><p>全色，0.41m</p></li><li><p>多光谱，1.65m</p></li></ul><h5 id="WorldView"><a href="#WorldView" class="headerlink" title="WorldView"></a>WorldView</h5><ul><li>WorldView-1 <ul><li>全色分辨率 0.46 米</li></ul></li><li>WorldView-2 <ul><li>全色分辨率 0.46 米</li></ul></li><li><p>WorldView-3 </p><ul><li><p>全色分辨率 0.31 米</p></li><li><p>多光谱分辨率1.24米</p></li><li><p>红外短波分辨率3.7米</p></li></ul></li><li>WorldView-4 分辨率 0.31 米</li></ul><h5 id="QUICKBIRD"><a href="#QUICKBIRD" class="headerlink" title="QUICKBIRD"></a>QUICKBIRD</h5><ul><li><p>星下点分辨率</p><ul><li><p>全色：0.61m</p></li><li><p>多光谱：2.44m</p></li></ul></li><li><p>有四个波段</p><ul><li><p>蓝    450-520nm</p></li><li><p>绿    520-600nm</p></li><li><p>红    630-690nm</p></li><li><p>近红外    760-900nm</p></li></ul></li></ul><h5 id="EOS"><a href="#EOS" class="headerlink" title="EOS"></a>EOS</h5><ul><li>MODIS中分辨率成像光谱仪</li><li>波段不连续（光谱范围0.4-14.5μm)波段36个</li><li><p>地面分辨率较低</p><ul><li><p>星下点离间分辨率为250m,500m,1000m）</p><ul><li><p>2个通道的空间分辨率为250米</p></li><li><p>5个可见光、远红外通道空间分辨率为500米</p></li><li><p>29个通道空间分辨率为1公里</p></li></ul></li></ul></li><li>每1—2天可覆盖全球一遍。宽度2300公里。用于观测地表温度、海洋水色、叶绿素、植被、火灾、雪盖、云等</li></ul><hr><h3 id="附录2：反射波谱特性曲线与反射波谱响应曲线"><a href="#附录2：反射波谱特性曲线与反射波谱响应曲线" class="headerlink" title="附录2：反射波谱特性曲线与反射波谱响应曲线"></a>附录2：反射波谱特性曲线与反射波谱响应曲线</h3><p><table><br>    <tr>        <td>            </td>        <td>                反射波谱特性曲线        </td>        <td>                反射波谱响应曲线        </td>    </tr><br>    <tr>        <td rowspan="6">            不同点        </td>        <td>            坐标横轴表示波长        </td>        <td>            坐标横轴表示波段        </td>    </tr><br>    <tr>        <td>            坐标纵轴表示反射率        </td>        <td>            坐标纵轴表示像素亮度        </td>    </tr><br>        <tr>        <td>            地面拍摄        </td>        <td>            高空拍摄        </td>    </tr><br>        <tr>        <td>            不受大气影响        </td>        <td>            受大气影响        </td>    </tr><br>        <tr>        <td>            微分值        </td>        <td>            积分值        </td>    </tr><br>        <tr>        <td>            连续        </td>        <td>            折线        </td>    </tr><br>    <tr>        <td>             相同点        </td>        <td align="middle" colspan="2">            走势相同        </td>    </tr></p><h2 id="lt-table-gt"><a href="#lt-table-gt" class="headerlink" title="&lt;/table&gt;"></a>&lt;/table&gt;</h2><h3 id="附录3：解译方法"><a href="#附录3：解译方法" class="headerlink" title="附录3：解译方法"></a>附录3：解译方法</h3><p>每种解译方法的基本思想、分析其适用性、优点及不足（TODO：目视判读、计算机辅助分类、混合像元分解、多阶抽样估计）</p><h4 id="目视判读"><a href="#目视判读" class="headerlink" title="目视判读"></a>目视判读</h4><h4 id="计算机辅助分类"><a href="#计算机辅助分类" class="headerlink" title="计算机辅助分类"></a>计算机辅助分类</h4><h4 id="遥感地学分析-1"><a href="#遥感地学分析-1" class="headerlink" title="遥感地学分析"></a>遥感地学分析</h4><ul><li><p>地理相关与差异分析</p><ul><li><p>基本思想：研究某个区域地理环境内各要素之间的相互关系、相互组合特征。本方法研究某个区域地理环境内各要素之间的相互关系、相互组合特征。应用于遥感地学分析，是通过对这些因子特点及相互关系的研究，从各个不同的角度来分析、推导出某个专题目标的特征，在遥感图像上寻找与目标相关性密切的间接解译标志。</p></li><li><p>适用性：比如耕地生产力遥感监测，耕地环境和健康质量遥感监测，环境污染遥感监测，水土流失。</p></li><li><p>优缺点：为了取得较好的遥感分析效果，在相关分析中，首先要考虑与专题目标有关的主导因素。当主导因素在遥感图像上反映不明显的情况下，可以进一步寻找与目标有关，且在图像上反映较明显的非主导因素。研究它们与目标的相互组合特征，从而确定专题目标的空间和属性分布特征及其差异。</p></li><li><p>主导因素分析方法</p><ul><li><p>基本思想：一个地区自然环境的特点是由自然和人为综合因素决定的。在多种因素中，又会有一、二个起主导和决定作用的因素。 分析一个地区的遥感图像，提取某个专题特征信息时，应当先找出它的主导因素。对于不同的目的，其主导因素是不同的；同一目的中，不同等级的分类系统主导因素也可能不一。</p></li><li><p>适用性：水土流失：引起水土流失的主要因素；环境污染：导致环境污染的主要来源；热岛效应：产生温度差的热源分布。</p></li><li><p>优缺点：主导因素的作用可能呈现几种不同情形：首先是规律性，如将海堤往外分为草滩—盐蒿滩—泥滩—粉沙滩四个带；其次是模糊性，因为以上四个带的划分存在一系列过渡区；再就是随机性，如天气变化、泥沙运动、地质灾害等都可能对海岸带的主导因素产生影响。主导因素分析法可以较好的找出影像某一地物的最主要特征进行分类，简单方便所用信息少但是当事物中难以找出明显的事物时这种方法就不适用。</p></li></ul></li><li><p>相关分析法</p><ul><li>基本思想：是一种非主导因素的分析方法。确定某一专题目标的相关因子取决于对这一区域自然与人文环境特征的深刻认识。但在某些区域条件下，专题目标与其它的环境因子之间的关系可能更为复杂，往往难于直接找出明显相关的因子。在这种情况下，进行各因子的数量化统计分析，确定有明显效果的相关变量是一种有效的途径。</li></ul></li></ul></li><li><p>环境本底法基本思想：了解一个地区的区域概况以及分析该地区地理环境的总体规律。在分析环境背景中，搞清区域内正常的组合关系、空间分布规律、正常背景值，即调查环境本底。在这个基础上，寻找异常，并追根求源，找出异常原因，通过成因机制分析在更大范围内，寻找与异常有关的环境特征。适用性：遥感生物化学找矿；寻找和确定环境污染和病虫对森林植被造成的损害范围与程度。优缺点：可以找到植物的异常现象</p></li><li><p>分层分类方法(略，这个明确不考)按层次一步步地分类，而且在层次间不断加入遥感与非遥感的决策函数，从而组成一个最佳逻辑决策树。用传统的地学方法和概念，按现在的信息传输和信息相关体系建立信息树。由于信息并非都能从遥感图像上得以反映，在建立信息树的过程中，必须不断地补充其它资料（如一些边界条件、分类参数等），以逐步满足某种分类的需要，最后完善这个最佳逻辑决策树，得出满意的分类结果。</p></li></ul><h4 id="遥感数据反演法"><a href="#遥感数据反演法" class="headerlink" title="遥感数据反演法"></a>遥感数据反演法</h4><ul><li>基本思想：1.不考虑中间具体的物理过程，基于统计理论的地面参数的反演，2.面向过程，基于物体机理的地面参数的反演。</li><li>统计模型的优缺点：需要积累大量的数据观测，工作量，模型不稳定，影响了检测的时效性。地面实测资料多为点状的，如何推广到面上与遥感资料相匹配也是影响模型精度的一大问题。力求建立稳定的，较少依赖于非遥感数据的模型</li></ul><h4 id="混合像元分解-1"><a href="#混合像元分解-1" class="headerlink" title="混合像元分解"></a>混合像元分解</h4><ul><li>基本思想：如果每一混合像元能够被分解而且它的覆盖类型组分(端元组分)占像元的百分含量(丰度)能够求得，分类将更精确，因混合像元的归属而产生的错分、误分问题也就迎刃而解，即混合像元分解。</li><li>优缺点：提高分类精度；提高图像处理的自动化、智能化水平；可提高对小目标的识别能力</li></ul><h4 id="多阶抽样估计-1"><a href="#多阶抽样估计-1" class="headerlink" title="多阶抽样估计"></a>多阶抽样估计</h4><ul><li>基本思想：根据图像分层，确定样本单元。使每一阶图像的分辨率逐级提高。使后一阶样本是前一阶样本的一部分，抽样的概率与通过逐级解译图像所得到的预估值成正比。</li><li>优缺点：</li></ul><hr><h3 id="附录4：往年考题和预测"><a href="#附录4：往年考题和预测" class="headerlink" title="附录4：往年考题和预测"></a>附录4：往年考题和预测</h3><ul><li><p><strong>比较计算机辅助解译与人工目视解译的相同点与不同点？</strong></p><ul><li><p>不同点</p><ul><li><p>目视解译通常是直接从图像空间到分类空间，而计算机分类是从图像空间经过光谱特征空间到分类空间。目前在计算机分类中，从图像空间到光谱特征空间人工干预较少，计算机能做的工作也主要集中在这一部分，而将光谱特征空间中的集群与分类系统中的类别对应，则需要更多的人工干预。进一步的工作是确定目标内部的变异规律，这对于目前的数字图像处理系统来说，是难以胜任的。</p></li><li><p>现有的图像处理系统还很难完全满足解译任务在精度和功能上的需要，计算机分类和识别还缺少灵活性，有必要使自动分类和识别结果与目视解译结果相结合，或者说利用计算机辅助目视解译。在遥感图像信息提取和解译过程中，一方面使图像解译人员能充分运用他们的解译经验，同时又能发挥计算机处理图像信息的优势。</p></li></ul></li><li><p>相同点</p><ul><li>都是利用遥感影像的图像特征，通过相应的手段获取遥感解译对象的信息</li><li>都需要人工的参与</li><li>都需要需要参考数据</li><li>都需要相应设备支持</li><li>人机交互</li></ul></li></ul></li></ul><div class="table-container"><table><thead><tr><th></th><th>目视解译</th><th>计算机解译</th></tr></thead><tbody><tr><td>解译层次</td><td>多个像元</td><td>单个像元</td></tr><tr><td>面积估算</td><td>有限</td><td>可能达到精确面积估算</td></tr><tr><td>影像波段数</td><td>有限，一般不超过三个</td><td>能进行多波段分析及特征变换</td></tr><tr><td>区别影像亮度水平</td><td>有限，一般不超过每个地物16个亮度水平</td><td>能充分利用所有的影像亮度水平</td></tr><tr><td>地物形状信息</td><td>可得到利用</td><td>需要较为复杂的软件及算法</td></tr><tr><td>空间信息</td><td>可得到利用</td><td>目前的技术有限</td></tr><tr><td>非遥感资料</td><td>可得到利用</td><td>目前技术有限</td></tr><tr><td>解译时间</td><td>慢</td><td>快</td></tr><tr><td>结果重现性</td><td>较差</td><td>好</td></tr><tr><td></td><td>直觉</td><td>需要专门的训练</td></tr><tr><td></td><td>简单便宜的设备</td><td>复杂昂贵的设备</td></tr><tr><td></td><td>利用图像的空间和色调标志</td><td>主要利用光谱和色调特征</td></tr><tr><td></td><td>利用单波段数据，一般不超过三个波段</td><td>可以用多通道数据</td></tr><tr><td></td><td>主观、具体、定性地判别</td><td>客观抽象定量地差别</td></tr></tbody></table></div><ul><li><p><strong><u>影响遥感图像解译精度的因素有哪些？如何提高解译的精度？</u></strong></p><ul><li><p>影响因素</p><ul><li><p>遥感解译方法</p><ul><li>使用高精度的方法可以提高解译的精度。</li></ul></li><li><p>图像质量</p><ul><li>包括图像的分辨率，图像的比例尺，图像的清晰度，它们共同决定了图像量测性能。不同的比例尺的图像对成图的完整性有重要的影响。</li></ul></li><li><p>解译人经验</p><ul><li>经验在遥感图像解译中很重要，一个有经验的作业人员对解译的精度很重要。</li></ul></li><li><p>解译使用的波段数目</p><ul><li>扫描成像类型的多波段图像既可以分别解译，也可以多波段组合解译，使用的波段不同，得到的信息不同</li></ul></li><li><p>分类标准</p><ul><li>分类的标准不同，得到的解译精度不同，分类的数目不同，精度也不同。</li></ul></li><li><p>遥感解译原则和程序</p><ul><li>作业流程，开始是制定的原则也在很大程度上影响了遥感图像解译的精度</li></ul></li><li><p>图像分解力</p><ul><li>在1 mm 长的图像上能够将绝对反差的线条分开成像的数量。</li></ul></li><li><p>图像清晰度</p><ul><li>表示传递地物形状的能力，决定目视观测中有效的放大极限。由物体亮度到背景亮度的过渡，在实际情况下一般呈突变形式。获得遥感图像的条件的影响在于：图像上从物体密度到背景密度的过渡（边缘曲线）平滑化。导致地物形状的变化（变形），特别是小尺寸的地物的变化。</li></ul></li><li><p>反差频率特性</p><ul><li>通常是在一定空间频率范围（可以用像素长度为依据），将图像反差与地物光学反差进行比较</li></ul></li><li><p>图像的解像力</p><ul><li>图像上最小的、但还能分辨的地物尺寸。</li></ul></li></ul></li><li><p>提高解译精度的方法</p><ul><li><p>提高图像的分辨率，采用高精度的图像</p></li><li><p>使用清晰的图像，避免模糊</p></li><li><p>介入辅助数据、地学知识，进行遥感与地学综合分析</p></li><li><p>训练解译人员的判读识别能力</p></li><li><p>选择高精度高性能的传感器，选择合理的波段来进行解译</p></li><li><p>利用数字地形模型与遥感图像进行处理分析，以减少或清除地形因子对地物波谱特性的影响。</p></li><li><p>遥感图像的综合特征提取。综合提取多谱段影像特征,以此综合特征互为补充，实现遥感图像目标地物的自动识别。</p></li><li><p>利用 GIS 专题数据库信息来辅助计算机自动识别。</p></li><li><p>建立区域遥感图像自动识别的专家系统，提高自动解译的灵活性</p></li></ul></li></ul></li><li><p><u><strong>请详细叙述遥感研究对象及其在遥感图像上的特征。</strong></u></p><ul><li><p>遥感的研究对象：自然地表</p></li><li><p>空间分布</p><ul><li><p>任何地学研究对象，均有一定的空间分布特征。根据空间分布的平面形态，把地面对象分为三类：面状、线状、点状</p><ul><li><p>面状对象其空间位置由表示界限的一组x，y坐标确定，并可以相应地求得其大小和形状参数。</p></li><li><p>线状对象其空间位置由表示线形轨迹的一组x，y坐标确定，在空间上呈线状或带状分布，如道路、河流、海岸等。</p></li><li><p>点状对象空间位置由其实际位置或中心位置的x，y坐标确定，实地上分布面积较小或呈点状分布的有独立树、单个建筑等。</p></li></ul></li></ul></li><li><p>波谱反射和辐射特征</p><ul><li><p>物体的基本特征：任何物体本身都具有发射、吸收和反射电磁波的能力。用物体的波谱特性曲线来描述。</p></li><li><p>相同的物体具有相同的电磁波谱特征，不同的物体由于物质组成和结构不同具有相异的电磁波谱特征。</p></li></ul></li><li><p>时间特征</p><ul><li><p>两方面含义：</p><ul><li><p>自然变化过程，即其发生、发展和演化</p></li><li><p>节律，既事物的发展在时间序列上表现出某种周期性重复的规律。用时间及随时间变化的特性的相应曲线描述</p></li></ul></li><li><p>任何一个遥感对象都处于一定的时态之中，有它的时相变化过程。遥感信息是瞬间记录，在分析遥感资料时必须考虑研究对象本身所处的时态，不能超越一个瞬时信息能反映的范围。</p></li></ul></li><li><p>统计特征</p><ul><li>统计特征从不同角度反映了研究区遥感图像所包含的信息特点，包括亮度均值、中值，标准差、信息量以及各波段质检的相关矩阵等。</li></ul></li></ul></li><li><p><u><strong>什么是遥感图像的解译标志？有哪些解译标志？</strong></u></p><ul><li>解译标志：遥感影像的时空谱特征 使得物体在图像上有所差别，这些差别就是解译标志。以图像形式传递的揭示标志。</li><li><p>色调与色彩：色调与色彩对不同类型的遥感图像其意义不一样的</p></li><li><p>形状 (轮廓) ：形状一般指物体或图形由外部的面或线条组合而呈现的外表。对于图像上的形状或轮廓标志可以有如下几个检测方法</p><ul><li><p>度量属性</p></li><li><p>拓扑属性</p></li><li><p>解析属性</p></li></ul></li><li><p>大小(尺寸)：与图像的空间分辨率有关，地物本身的尺寸有关。其与构像比例尺的关系，常常形成所谓的混合像元。</p></li><li><p>阴影</p><ul><li><p>可见光范围内的阴影 ：分为本影和落影。</p></li><li><p>热红外图像上的阴影一般由温度较低的地段所致。</p></li><li><p>对于雷达图像而言，其盲区可产生阴影。</p></li></ul></li><li><p>图案（细部） ：图案指地物的某种组合， 可以是同类地物的组合， 也可以是不同类地物的组合， 它与纹理的主要区别在于前者重复出现。</p></li><li><p>纹理（结构） ：纹理是由许多细小的地物的色调重复出现组合而成，是单一的细部特征的集合。依据它的图像特征，将纹理的的图像特征与它的地理意义相联系来进行纹理分析。</p></li><li><p>地物关系 ：这种方法的主要依据就是一种地物的存在常与其它一些地物的存在有关系，因而地物关系成为了一个间接的解译标志。</p></li><li><p>位置与位置算子 ：位置是指地物所处环境在图像上的反映</p></li></ul></li><li><p><u><strong>遥感图像解译的方法有哪些？说明遥感图像解译的实施步骤。</strong></u></p><ul><li><p>遥感图像解译的方法</p><ul><li><p>目视判读和计算机辅助分类</p></li><li><p>遥感地学分析</p><ul><li><p>地理相关与差异分析 </p><ul><li><p>主导因素分析方法</p></li><li><p>相关分析法</p></li><li><p>遥感信息单元的逻辑运算与相关分析</p></li></ul></li><li><p>环境本底法</p></li><li><p>分层分类方法(略，这个明确不考)</p></li></ul></li><li><p>遥感数据反演法</p></li><li><p>混合像元分解</p></li><li><p>多阶抽样估计</p></li></ul></li><li><p>遥感图像解译的实施步骤</p><ul><li><p>确定目的</p></li><li><p>选择图像（几何分辨率、时间分辨率、辐射分辨率等）</p></li><li><p>几何处理、辐射处理、特征变换</p></li><li><p>选样区</p></li><li><p>选模型</p></li><li><p>分类</p></li><li><p>验证，如果不理想则回到第4步</p></li></ul></li></ul></li><li><p><u>最佳波段的含义是什么？如何选择最佳波段？</u></p><ul><li><p>含义</p><ul><li>目标与背景反射（或发射）率差异最显著的波长区间，即为最佳的遥感波段。选择最佳波段的方式：最佳波段的选择一般用均方差方法选出那些要素（地物）之间光谱反射（或发射）率均方差较大的波段作为遥感通道。均方差较大的通道说明地物反射（或发射）率差异大，易于区分各类地物</li></ul></li><li><p>目标与背景反射（或发射）率差异最显著的波长</p><ul><li>$\sigma_\lambda=\sqrt{\cfrac{\sum^n_{i=1}(r_{i\lambda}-\bar{r_\lambda})^2}{n-1}}$</li></ul></li></ul></li><li><p><u>请设计一个模块，用于目视勾画地物图斑，列出需要的命令并说明相应的功能。</u></p><ul><li><p>首先要对遥感图像进行增强处理、提高可判读性，然后将透明纸蒙在遥感影像层上，用画笔人工勾画出各种地物图斑的轮廓，再用相应的颜色填充不同类型的图斑，从而完成对整幅图像的判读任务。</p></li><li><p>分类管理器，用于定义待定判读的地物类型的特征，指定一个当前判读的一种地物类型；画笔或折线，吸铁石笔，轮廓线跟踪，路径等工具用于勾绘出地物的轮廓。屏幕判读的结果以栅格方式直接存储在一个图层文件中。还能将栅格数据转换为矢量数据，与 GIS 数据集成</p></li></ul></li><li><p><u>比较可见光、热红外、微波图像上阴影的异同点，说明下图传感器的类型及方位，说明理由。</u></p><ul><li><p>可见光范围内的阴影</p><ul><li>分为本影和落影。本影指地物未被阳光直接照射部分的图像， 落影指目标投落在地面的影子的图像。</li></ul></li><li><p>热红外图像上的阴影</p><ul><li>一般由温度较低的地段所致。有人又把它区分为热影与冷影，如飞机的残留热量造成的热影；静止飞机的周围因吸收产生冷影等。这种热阴影与普通可见光像片上的阴影含义不同，它是由于温度差引起的。白天热红外像片虽然与可见光像片阴影相仿，但热影像上的阴影是由于未照射到太阳光，其温度相对太阳光照射处低而引起。</li></ul></li><li><p>对于雷达图像而言，其盲区可产生阴影。</p></li><li><p>传感器类型为侧视雷达 方位为雷达天线在左边，因为阴影朝右</p></li><li><p>理由：因为侧视雷达为斜距成像</p></li></ul></li><li><p><u>说明图1、图2中每个参数的含义，并对图所含的意义做出解释</u>。</p><ul><li><p>图 1 中 A 表示遥感图像的解像力（以米计）P 为识别概率 </p></li><li><p>图 1 表现的是几种地物的识别曲线，由图分析各类地物识别过程的性质</p><ul><li><p>第一类包括具有与人工地物识别曲线相似的特征识别曲线的地物，具有指数性质。</p></li><li><p>第二类的识别曲线的特点是在图像解像力值小的范围内能被识别的概率较大，随着图像解像力值增大，识别概率快速下降，最后又趋于平缓。</p></li><li><p>第三类的识别曲线在图像解像力值小的范围内位于较高的水平，并且状态在一段区间内基本不变。</p></li><li><p>第四类与第一类类似。</p></li></ul></li><li><p>图 2 中 K 表示要素数量 C 表示识别概率增加的倍数</p><ul><li>图 2 表示在复杂地物要素的 K 增加时，地物识别概率 P 增长到多少倍 C</li></ul></li></ul></li><li><p><u>叙述遥感图像时间分辨力的作用。</u></p><ul><li><p>选择最佳成像时间的决定因素</p></li><li><p>遥感动态应用方面的重要作用</p></li><li><p>利用时间差以提高遥感的成像率和解像率。</p></li><li><p>数据库更新的重要参考因素</p></li><li><p>利用遥感图像解译监测地面的动态变化</p></li></ul></li><li><p><u>选择一个你熟悉的对象，详细描述其特征</u></p><ul><li><p>居民地</p><ul><li>居民地在影像上呈由若干小的矩形（屋顶形状）紧密相连在一起的成片图形。由于阴影的存在，居民地更易判别。居民地色调一般呈灰或灰白。城市居民地一般面积大、街道比较规则，常有林荫大道、公园、广场等；城镇居民地一般分布在公路、铁路沿线，房屋多而密集；农村居民地一般与农田联系在一起，有道路相连。</li></ul></li><li><p>道路</p><ul><li>道路指铁路、公路、农村道路。道路在影像上呈细而长的条状。色调由白到黑，随路面的湿度和光滑程度不同而变化。一般湿度小、光滑，色调浅，反之深暗。铁路一般呈浅灰色或灰色的线状图形，转弯处圆滑或为弧形，且一般与其它道路直角相交；公路一般为白色或浅灰色的带状，山区公路常有迂回曲折的形状，公路两侧一般有树和道沟，呈较暗的线条；土路一般呈浅灰色的线条，边缘不太清晰；小路成曲折的细线条状，浅灰色。</li></ul></li><li><p>水域</p><ul><li>水的色调是由白到黑，色调的深浅与水的深浅、浑浊程度、光照条件等有关，水深则色调暗、水浅则色调浅；水越浑浊则色调越暗，反之越浅；光照越强则色调越浅，反之越深。河流在影像上一般较宽并呈弯曲带状，色调由白到黑；小溪呈弯曲不规则的细线条，色调较暗，常被岸上树木、灌木掩盖；湖泊和坑塘的水面色调呈均匀的浅黑色或灰色，且面积大小相差甚大；沟渠为色调呈暗色的线状影像，灌渠的一端总与水源相连，排水渠的一端总与河流相通</li></ul></li></ul></li><li><p><u>现在媒体提供的信息除了文字声音外还有大量的图片，结合本课程所学知识，如何判断图片所具有信息的准确性？</u></p><ul><li><p>图像上目标的颜色，色调是否正常</p></li><li><p>看图像上各个物体的比例，比如“华南虎”事件中，那个老虎的比例明显有问题；再如很多女明星为了显示自己的身材，将自己的腿拉长，这样显得比例极不协调。</p></li><li><p>看各个物体的接边是否正常，很多时候抠图之后的边缘处理之后就会显得不自然，很容易看出来</p></li><li><p>根据生活经验判断是否正常，许多媒体，尤其是网络媒体上面的图片是虚假的，只为了一个噱头，在经过生活的判断之后，就能很快明白不可能发生，比如：之前有一张公安局门口挂的宣传横幅，除了它的接边处理不当之外，根据生活经验也会觉得不可能，国家明确规定，政府机关不能做广告，只有公安机关的领导人员不想干了，否则不可能。</p></li></ul></li><li><p><u>说明遥感图像解译及时性的重要意义。</u></p><ul><li>解译的及时性包括图像资料的及时使用。如果被获取的图像数据长期不能交付解译使用，实时地物与图像之间变化太多会造成数据的浪费。另一方面，解译的及时性是说在指定的期限内工作的完成情况。这对于所有类型的解译都是重要的，而对于气象、农业、灾害调查及其他一些部门的解译来讲尤其重要。</li></ul></li><li><p><u>比较太空获取的遥感影像与生活中拍摄的影像的相同点与不同点。</u></p><ul><li><p>不同点</p><ul><li><p>摄影目的不同</p><ul><li><p>遥感：为了获取地物信息，影像要有利于量测与地理信息的提取</p></li><li><p>普通风景：为了获取美观相片</p></li></ul></li><li><p>对地物的保真度</p></li><li><p>波段范围不同</p></li><li><p>摄影方向的不同（水平，竖直）</p></li><li><p>需不需要内外方位元素</p></li><li><p>是否受大气影响</p></li><li><p>平台不同</p></li><li><p>比例尺不同</p></li><li>遥感影像多为拼接影像，而生活中拍摄的影像为中心投射成像</li></ul></li><li><p>相同点</p><ul><li>成像原理相同</li><li>有相似相机性能参数</li><li>存储方式类似</li><li>都可以反映物体特征，如形状、大小等等</li></ul></li></ul></li><li><p><u>遥感图像解译方法中，有直接解译和间接解译之分，根据本课程的介绍，请总结间接解译的方法有哪些？</u></p><ul><li>地理相关分析</li><li><p>地物关系：这种方法的主要依据就是一种地物的存在常与其它一些地物的存在有关系，因而地物关系成为了一个间接的解译标志。位置与位置算子 ：位置是指地物所处环境在图像上的反映。为了在图像上的特定位置识别某些地物，可针对这些特别的位置设定一些特别的处理方法，称为位置算子。</p></li><li><p>人类活动的结果：古代与现代的采场、采坑、矿冶遗址、渣堆是地质找矿的标志，耕地的排布反应地形地貌的特征，是历史上活动与地质体有关的痕迹。</p></li></ul></li><li><p><u>遥感图像中的独立变量有哪些，说明其含义</u>。</p><ul><li><p>亮度</p></li><li><p>湿度</p></li><li><p>色彩和色扇：半径大小反映了饱和度的变化， 扇形弧度反应色调标志。色扇分析：通过将作为标准的地物按光谱属性的差异分别将它们标在扇形相应的位置上，可以得到地物解译的色彩标准， 可进行解译工作。</p></li><li><p>绿度（植被指数）</p><ul><li>$NVI =\cfrac{(IR- R)}{(IR+ R)}$采用该公式的依据：植被在近红外波段上有高反射</li></ul></li><li><p>反照度：太阳入射地面后，地面照度发射到卫星上去的物理总量</p></li><li><p>湿度：与土壤含水量和土壤湿度有关</p></li></ul></li><li><p><u>什么是混合像元，混合像元对提取信息有什么影响？有哪些处理混合像元的方法？ 选择一种方法说明其基本思想。</u>（建议按ppt答）</p><ul><li><p>混合像元：一个像元内包含几种地物，称该像元为混合像元。混合像元的辐射特性是几种地物光谱特征的混合反映，混合像元无论归于哪一种典型地物都是错误的。</p></li><li><p>为了解决混合像元的问题，提出了子像元分析法和空域分辨增强法。（？）</p><ul><li><p>子像元分析法：针对混合像元的特点，利用地物波谱组合等研究成果，对遥感数据每一个像元进行波谱分离，从而计算出每个像元中含有某类地物的含量，达到解决混合像元问题的目的；</p></li><li><p>空域分辨增强法：为了增强小于或接近一个像元的地物。由于混合像元造成了接近一个像元或小于一个像元的地物边界不清，从而减少了此类地物的识别能力。空域分辨增强利用地物纹理特点和空间卷积算法，增强此类地物的识别能力。</p></li></ul></li></ul></li><li><p><u>遥感图像解译要求掌握研究对象的哪些属性？举一个例子说明。</u></p><ul><li><p>色调与色彩：色调与色彩对不同类型的遥感图像其意义不一样的</p></li><li><p>形状 (轮廓) ：形状一般指物体或图形由外部的面或线条组合而呈现的外表。对于图像上的形状或轮廓标志可以有如下几个检测方法</p><ul><li><p>度量属性</p></li><li><p>拓扑属性</p></li><li><p>解析属性</p></li></ul></li><li><p>大小(尺寸)：与图像的空间分辨率有关，地物本身的尺寸有关。其与构像比例尺的关系，常常形成所谓的混合像元。</p></li><li><p>阴影</p><ul><li><p>可见光范围内的阴影 ：分为本影和落影。</p></li><li><p>热红外图像上的阴影一般由温度较低的地段所致。</p></li><li><p>对于雷达图像而言，其盲区可产生阴影。</p></li></ul></li><li><p>图案（细部） ：图案指地物的某种组合， 可以是同类地物的组合， 也可以是不同类地物的组合， 它与纹理的主要区别在于前者重复出现。</p></li><li><p>纹理（结构） ：纹理是由许多细小的地物的色调重复出现组合而成，是单一的细部特征的集合。依据它的图像特征，将纹理的的图像特征与它的地理意义相联系来进行纹理分析。</p></li><li><p>地物关系 ：这种方法的主要依据就是一种地物的存在常与其它一些地物的存在有关系，因而地物关系成为了一个间接的解译标志。</p></li><li><p>位置与位置算子 ：位置是指地物所处环境在图像上的反映</p></li></ul></li><li><p><u>说明图像解译过程中参考数据的重要性。如何使用需要的参考数据？</u>（我觉得还有样本数据的作用）</p><ul><li><p>重要性：由于光谱响应标志的可变性，遥感中经常使用某种形式的参比数据的。</p></li><li><p>如何使用</p><ul><li><p>帮助遥感数据的分析和解译</p></li><li><p>校准传感器</p></li><li><p>验证遥感数据所提取的信息</p></li><li>样本数据：计算模型参数、检查、评定精度</li></ul></li></ul></li><li><p><u>比较遥感图像解译中的事后评价与事先评价的区别与联系</u></p><ul><li><p>事先评价为预测。</p><ul><li>事先评价可以及早地评论遥感图像的可解译性，并对影响解译结果的主要因素予以考虑。在它的基础上可以选择图像获取和处理的最佳方法和技术手段，力求以给定的完整性、详细性和置信度完成解译工作。其基本依据是待识别地物图像的成像性能和量测性能。</li></ul></li><li><p>事后评价是影像解译之后进行评价，通常采用四个标准：解译的完整性、解译的可靠性、解译的及时性、解译的明显性。</p><ul><li>作用：解译的完整性标志着所得出结果与给定任务的符合程度，他提供关于在解译当中得到底物特性细节的概念。 解译的可靠性指出了解译结果与实际的符合程度。 解译的及时性包括图像资料的即时使用。 解译结果的明显性是指解译出来的成果，应当根据任务的目标，用相应的符号、线画清晰地绘出来，或者使成果尽可能可视化，以便人们理解和应用。</li></ul></li><li>联系<ul><li>事先和事后评价都是为了保证和提高遥感图像解译的质量进行的评价</li></ul></li></ul></li><li><p><u>遥感图像解译需要哪些非遥感数据辅助？如何获取？有何要求？</u></p><ul><li>非遥感数据<ul><li>踏勘数据</li><li>高程数据</li><li>波谱特性曲线</li><li>相关区域的地形图</li></ul></li><li>获取和要求</li></ul></li><li><p><u>说明环境本底法解译的基本原理，给出其解译流程。</u></p><ul><li>基本思想<ul><li>环境本底：了解一个地区的区域概况以及分析该地区地理环境的总体规律，在分析环境背景中，搞清区域内正常的组合关系、空间分布规律、正常背景值。</li><li>在这个基础上，寻找异常，并追根求源，找出异常原因，通过成因机制分析在更大范围内，寻找与异常有关的环境特征。</li></ul></li><li>解译流程</li></ul></li><li><p><u>请你评价利用遥感数据获取信息与实际应用之间存在的差距？分析产生的原因，给出你的建议。</u></p></li><li><p><u>给四个关键词遥感图像、图像特征、属性信息、解译方法，给出你的解读。</u></p></li><li><p><u>说明地物波谱特性的含义与作用，举一个例子说明波谱特性的应用</u></p><ul><li>含义：物体的发射、反射电磁波的特性</li><li>作用：</li><li>相同的物体具有相同的电磁波谱特征，不同的物体由于物质组成和结构不同具有相异的电磁波谱特征。可以根据遥感仪器所接收到的电磁波谱特征的差异来识别不同的物体。</li></ul></li><li><p><u>在图像解译，样本数据具有重要作用，请说明样本数据的含义，获取途径，并说明其作用。</u></p><ul><li>含义</li><li>途径</li><li>作用：计算模型参数、检查、评定精度</li></ul></li><li><p><u>遥感图像的解译标志有哪些？除了教材列出的解译标志，是否还有其他的标志？请说明</u></p></li></ul>]]></content>
    
    
    <summary type="html">大三上学期遥感图像解译考试前梳理的东西。</summary>
    
    
    
    <category term="课程学习" scheme="http://zerolacqua.top/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="遥感" scheme="http://zerolacqua.top/tags/%E9%81%A5%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建备忘录</title>
    <link href="http://zerolacqua.top/posts/6b405ec0.html"/>
    <id>http://zerolacqua.top/posts/6b405ec0.html</id>
    <published>2022-02-23T16:05:37.000Z</published>
    <updated>2022-05-17T11:13:30.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里是搭建<code>Hexo</code>博客时遇到的一些问题，因为怕以后忘记了会多走弯路，就记在这里了。</p><p>看了众多大佬的魔改博客，自觉像我这样没有前端基础的人，只能是小打小闹一般图一乐，不专门学习是永远不可能达到那样的高度的……</p><blockquote><p><a href="https://butterfly.js.org/">这里是Butterfly的文档</a></p></blockquote><h2 id="主题优化"><a href="#主题优化" class="headerlink" title="主题优化"></a>主题优化</h2><h3 id="字体修改"><a href="#字体修改" class="headerlink" title="字体修改"></a>字体修改</h3><p>引入字体后，结合样式表筛选器可以设置某一部分的字体。</p><p>详见：<a href="https://www.matemaster.cn/posts/52745.html#toc-heading-2">基于Hexo的博客网站 | MateMaster</a></p><h2 id="相关功能"><a href="#相关功能" class="headerlink" title="相关功能"></a>相关功能</h2><h3 id="隐藏博客"><a href="#隐藏博客" class="headerlink" title="隐藏博客"></a>隐藏博客</h3><p>安装插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-hide-posts --save</span><br></pre></td></tr></table></figure><p>在博客的<code>Front-matter</code>中加入如下参数</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">hidden: false </span><br></pre></td></tr></table></figure><p>可实现对文章的隐藏（虽然还是可以用网址访问就是了）</p><p>参考网站：<a href="https://loafing.cn/posts/hexo-tags.html">「推荐」本站用到的 hexo 插件 | 若风 (loafing.cn)</a></p><h3 id="文字遮盖效果"><a href="#文字遮盖效果" class="headerlink" title="文字遮盖效果"></a>文字遮盖效果</h3><p>安装插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-spoiler --save</span><br></pre></td></tr></table></figure><p>站点根目录配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spoiler:</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">blur</span> <span class="comment"># 或者box</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">black</span> <span class="comment"># 仅当 style 为 box 时起效</span></span><br><span class="line">  <span class="attr">p:</span> <span class="literal">false</span> <span class="comment"># 没懂啥意思，不管它</span></span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% spoiler 默认配置效果 %&#125;</span><br></pre></td></tr></table></figure><p>效果：<!-- spoiler-1ffd9:black -->  <span class="spoiler" onclick="this.classList.toggle('spoiler')">    <span class="spoiler-blur spoiler-1ffd9">默认配置效果</span>  </span></p><p>参考网站：<a href="https://loafing.cn/posts/hexo-tags.html">「推荐」本站用到的 hexo 插件 | 若风 (loafing.cn)</a></p><h3 id="跳转站内文章"><a href="#跳转站内文章" class="headerlink" title="跳转站内文章"></a>跳转站内文章</h3><p>可以使用以下方式</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_link 日常记录 %&#125;</span></span><br></pre></td></tr></table></figure><p>其效果是这样的</p><a href="/posts/535d1ea3.html" title="日常记录">日常记录</a><h3 id="跳转文章锚点"><a href="#跳转文章锚点" class="headerlink" title="跳转文章锚点"></a>跳转文章锚点</h3><ul><li><p>方法一</p>  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">这是一个跳转</span>](<span class="link">&#123;% post_path &#x27;近景摄影测量编程&#x27;&#125;#课间实习% </span>)</span><br></pre></td></tr></table></figure><p>  此方法目前还无法实现，还没找到问题所在。</p></li><li><p>方法二</p>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% post_path &#x27;近景摄影测量编程&#x27; %&#125;#课间实习&quot;</span>&gt;</span>这是一个跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  此方法效果如下</p><p>  <a href="#课间实习">这是一个跳转</a></p></li></ul><p>注意：</p><ol><li>如果文章中有图片，可能会出现锚点位置不准确问题，原因是图片加载成功之后会把内容高度撑开。</li><li>如果如果有空格，需要把空格换成连字符 <code>-</code>。</li></ol><p>可以参考以下文章</p><p><a href="https://blog.jijian.link/2020-01-08/hexo-anchor-link/#hexo-标题与-id-关系">hexo 链接到站内文章指定锚点 | 极简前端 (jijian.link)</a></p><h3 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h3><ul><li><p>使用如下方法插入视频</p>  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">![IMAGE ALT TEXT HERE</span>](<span class="link">https://img.youtube.com/vi/ARted4RniaU/0.jpg</span>)](<span class="link">https://www.youtube.com/watch?v=ARted4RniaU</span>)</span><br></pre></td></tr></table></figure><p>  <a href="https://www.youtube.com/watch?v=ARted4RniaU"><img src="https://img.youtube.com/vi/ARted4RniaU/0.jpg" alt="IMAGE ALT TEXT HERE"></a></p></li><li><p>嵌入视频</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=460816113&amp;bvid=BV1j5411g7m5&amp;cid=345672460&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; Left: 0; top: 0;&quot; &gt;&lt;/iframe&gt;&lt;/div&gt;</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>    <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=460816113&bvid=BV1j5411g7m5&cid=345672460&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div>    <p>或</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt;</span><br><span class="line">&lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;https://player.bilibili.com/player.html?aid=460816113&amp;bvid=BV1j5411g7m5&amp;cid=345672460&amp;page=1&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>    <div style="position: relative; padding: 30% 45%;">  <iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?aid=460816113&bvid=BV1j5411g7m5&cid=345672460&page=1" frameborder="no" scrolling="no"></iframe>  </div>    <p>可以参考：</p><ul><li><p><a href="https://www.jianshu.com/p/9b4d5903dfc8">Hexo博客如何加入B站视频/How to add bilibili shared video in Hexo - 简书 (jianshu.com)</a></p></li><li><p><a href="https://www.cnblogs.com/wkfvawl/p/12268980.html">关于博客园内嵌入bilibili视频 - 王陸 - 博客园 (cnblogs.com)</a></p></li></ul></li></ul><h3 id="图库"><a href="#图库" class="headerlink" title="图库"></a>图库</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">/images/blogs/可爱的水伊布/Vaporeon1.png</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>效果见<a href="/posts/a04972d8.html" title="可爱的水伊布">可爱的水伊布</a></p><h2 id="Markdown与数学公式"><a href="#Markdown与数学公式" class="headerlink" title="Markdown与数学公式"></a>Markdown与数学公式</h2><h3 id="Hexo中数学公式渲染错误"><a href="#Hexo中数学公式渲染错误" class="headerlink" title="Hexo中数学公式渲染错误"></a>Hexo中数学公式渲染错误</h3><p>可以参见这几篇文章进行修改：</p><ul><li><a href="https://www.jianshu.com/p/7ab21c7f0674">在Hexo中渲染MathJax数学公式 - 简书 (jianshu.com)</a></li><li><a href="https://corecabin.cn/2021/08/14/solve-some-problems-of-hexo-renderer-kramed-rendering-conflicts/">解决hexo-renderer-kramed渲染冲突的部分问题 | 卡洛的核心舱 (corecabin.cn)</a></li></ul><div class="note warning modern"><p>注意：由于渲染效果很迷，经常无法复现问题，有时重新部署一下全部都变了，所以以下的内容参考价值不大！</p></div><p>但是公式中还是会出现<code>\\</code>被转义成<code>\</code>的问题：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CCW(c,a,b)=</span><br><span class="line">\begin&#123;vmatrix&#125;</span><br><span class="line">a<span class="emphasis">_x&amp;a_</span>y&amp;1\\</span><br><span class="line">b<span class="emphasis">_x&amp;b_</span>y&amp;1\\</span><br><span class="line">c<span class="emphasis">_x&amp;c_</span>y&amp;1\\</span><br><span class="line">\end&#123;vmatrix&#125;=</span><br><span class="line">\begin&#123;vmatrix&#125;</span><br><span class="line">a<span class="emphasis">_x-c_</span>x&amp;a<span class="emphasis">_y-c_</span>y\\</span><br><span class="line">b<span class="emphasis">_x-c_</span>x&amp;b<span class="emphasis">_y-c_</span>y\\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure><p>其效果为：$CCW(c,a,b)=<br>\begin{vmatrix}<br>a_x&amp;a_y&amp;1\\<br>b_x&amp;b_y&amp;1\\<br>c_x&amp;c_y&amp;1\\<br>\end{vmatrix}=<br>\begin{vmatrix}<br>a_x-c_x&amp;a_y-c_y\\<br>b_x-c_x&amp;b_y-c_y\\<br>\end{vmatrix}$</p><p>妥协办法也有，但是太蠢，将就用吧</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">CCW(c,a,b)=</span><br><span class="line">\begin&#123;vmatrix&#125;</span><br><span class="line">a<span class="emphasis">_x&amp;a_</span>y&amp;1\\\\</span><br><span class="line">b<span class="emphasis">_x&amp;b_</span>y&amp;1\\\\</span><br><span class="line">c<span class="emphasis">_x&amp;c_</span>y&amp;1\\\\</span><br><span class="line">\end&#123;vmatrix&#125;=</span><br><span class="line">\begin&#123;vmatrix&#125;</span><br><span class="line">a<span class="emphasis">_x-c_</span>x&amp;a<span class="emphasis">_y-c_</span>y\\\\</span><br><span class="line">b<span class="emphasis">_x-c_</span>x&amp;b<span class="emphasis">_y-c_</span>y\\\\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure><p>其效果为：$CCW(c,a,b)=<br>\begin{vmatrix}<br>a_x&amp;a_y&amp;1\\\\<br>b_x&amp;b_y&amp;1\\\\<br>c_x&amp;c_y&amp;1\\\\<br>\end{vmatrix}=<br>\begin{vmatrix}<br>a_x-c_x&amp;a_y-c_y\\\\<br>b_x-c_x&amp;b_y-c_y\\\\<br>\end{vmatrix}$</p><p>此外，公式块中 <code>&#123;y&#125;_&#123;t&#125;</code>的<code>_</code>会被渲染成斜体</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\hat &#123;y&#125;<span class="emphasis">_&#123;t&#125;=\cfrac&#123;1&#125;&#123;2l+1&#125;(y_</span>&#123;t-l&#125;+y<span class="emphasis">_&#123;t-(l-1)&#125;+\cdots+y_</span>&#123;t-1&#125;+y<span class="emphasis">_&#123;t&#125;+y_</span>&#123;t+1&#125;+\cdots+y<span class="emphasis">_&#123;t+l&#125;)</span></span><br><span class="line"><span class="emphasis">\end&#123;equation&#125;</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>其效果为：</p><script type="math/tex; mode=display">\begin{equation}\hat {y}_{t}=\cfrac{1}{2l+1}(y_{t-l}+y_{t-(l-1)}+\cdots+y_{t-1}+y_{t}+y_{t+1}+\cdots+y_{t+l})\end{equation}</script><p>需要改成<code>&#123;y&#125;_ &#123;t&#125;</code></p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\hat &#123;y&#125;<span class="emphasis">_ &#123;t&#125;=\cfrac&#123;1&#125;&#123;2l+1&#125;(y_</span>&#123;t-l&#125;+y<span class="emphasis">_&#123;t-(l-1)&#125;+\cdots+y_</span>&#123;t-1&#125;+y<span class="emphasis">_&#123;t&#125;+y_</span>&#123;t+1&#125;+\cdots+y<span class="emphasis">_&#123;t+l&#125;)</span></span><br><span class="line"><span class="emphasis">\end&#123;equation&#125;</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>其效果为</p><script type="math/tex; mode=display">\begin{equation}\hat {y}_ {t}=\cfrac{1}{2l+1}(y_{t-l}+y_{t-(l-1)}+\cdots+y_{t-1}+y_{t}+y_{t+1}+\cdots+y_{t+l})\end{equation}</script><p>目前测试发现和<code>&#123;y&#125;_</code>的<code>&#123;&#125;</code>有相关，若是<code>\hat y_&#123;t&#125;</code>则不会出现问题。且只会在本地测试时出问题</p><h3 id="公式块自动编号"><a href="#公式块自动编号" class="headerlink" title="公式块自动编号"></a>公式块自动编号</h3><p>可以用以下方式对公式进行自动编号</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">1+1=2</span><br><span class="line">\end&#123;equation&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>这是没用的：</p><script type="math/tex; mode=display">1+1=2</script><p>这是用了的：</p><script type="math/tex; mode=display">\begin{equation}1+1=2\end{equation}</script><h3 id="页面显示出问题，本地与部署端显示效果不同"><a href="#页面显示出问题，本地与部署端显示效果不同" class="headerlink" title="页面显示出问题，本地与部署端显示效果不同"></a>页面显示出问题，本地与部署端显示效果不同</h3><p>遇到显示错误不决，请先用<code>Enter</code>将各部分隔开。</p><h2 id="其他参考网站"><a href="#其他参考网站" class="headerlink" title="其他参考网站"></a>其他参考网站</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)</a></li><li><a href="https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/dependents/">Step.1 依赖插件 - Theme Shoka Documentation - 二进制杂谈 - 计算机科学 | Yume Shoka = 優萌初華 = 有夢書架 (lostyu.me)</a></li><li><a href="https://www.cnblogs.com/glassysky/p/13394579.html">Hexo博客美化之蝴蝶(butterfly)主题魔改 - 远方有你，伴余生 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.zhihu.com/question/21193762">使用hexo，如果换了电脑怎么更新博客？ - 知乎 (zhihu.com)</a></li><li><a href="https://swayye.xyz/2020/01/10/hexo博客迁移/">hexo博客迁移 | 一葉扁舟 (swayye.xyz)</a></li><li><a href="https://loafing.cn/posts/hexo-tags.html">「推荐」本站用到的 hexo 插件 | 若风 (loafing.cn)</a></li></ul>]]></content>
    
    
    <summary type="html">记下一些可能会忘的东西。</summary>
    
    
    
    <category term="课外学习" scheme="http://zerolacqua.top/categories/%E8%AF%BE%E5%A4%96%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="博客搭建" scheme="http://zerolacqua.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>欢迎光临小店</title>
    <link href="http://zerolacqua.top/posts/c0297c2d.html"/>
    <id>http://zerolacqua.top/posts/c0297c2d.html</id>
    <published>2022-02-23T03:06:51.000Z</published>
    <updated>2022-05-16T00:29:21.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><font size=5px>“这里是</font><font size=1px>被迫营业的</font><font size=5px>看板娘</font><font size=5px font color='A2E5F4'>丘卡</font><font size=5px>，请多指教！”</font><div class="fj-gallery"><p><img src="/images/blogs/欢迎光临小店/1.png" alt="零醇丘卡"> </p>          </div><blockquote><p> 当然哈，关于我本人的一些信息在<a href="/about">这里</a></p></blockquote><h2 id="这个博客"><a href="#这个博客" class="headerlink" title="这个博客"></a>这个博客</h2><p>博客主要是关于个人学习方面的总结，包括一些作业、复习内容和自学知识等毫无营养的东西。此外还会有一些日常或者休闲相关的内容。总之，欢迎大家来阅读、学习，或是提出建议！</p><blockquote><p>如果有什么话要和我说，就请在这里留言吧。不过不要打坏主意，不好的评论会被丘卡删掉的哦~</p></blockquote>]]></content>
    
    
    <summary type="html">干嘛？看什么看，没见过cos笨蛋阿库娅的啊！</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>日常记录</title>
    <link href="http://zerolacqua.top/posts/535d1ea3.html"/>
    <id>http://zerolacqua.top/posts/535d1ea3.html</id>
    <published>2021-12-30T16:05:37.000Z</published>
    <updated>2022-04-22T12:18:18.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一次草草写日记，都已经是2021年的事了，到现在也已经过了一年了。刚开始写日记的时间应该是高二的时候了，那时候还用的是纸质的日记本，后来上了大学，才开始用<strong>OneNote</strong>记日记。现在翻一翻以前记的日记，多半是感觉日记幼稚好笑，一小部分阴郁的部分也让我感到难过，甚至让我想起来我到现在依然没有解决的问题，不过也有那么几刻，会让我觉得自己在某一天突然变得明事理起来……总之，希望借着小小的<strong>Blog</strong>，能够找回点当初的感觉吧。</p><hr><h2 id="2022年"><a href="#2022年" class="headerlink" title="2022年"></a>2022年</h2><h3 id="2月"><a href="#2月" class="headerlink" title="2月"></a>2月</h3><h4 id="2月28日"><a href="#2月28日" class="headerlink" title="2月28日"></a>2月28日</h4><p>今天再仔细翻看以前的日记时，我又发现了不少的东西。总体来说，高中那段时间的日记是很压抑的，但反倒是最丰富的，等到了大学的时候，时间多了，反而没有高中的时候写得勤了。高中主要内容就是奥赛、学习成绩，一些自己听说的消息。大学时间依然是担心考试成绩，不过多了很多在马圈中痛苦的感受。由于是以前的自己的感受，所以隔了这么久，代入感还是很强的，但能引起我内心强烈波动的，还是那些不好的感情。</p><p>在这将近三年的日记中，有各种各样的“短日记”，充数日记太多了，随便放几个：</p><div class="timeline  blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>原来每天我都好无聊</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2018.9.12</p></div></div><div class='timeline-item-content'><p>中午不睡，again</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2019.1.19</p></div></div><div class='timeline-item-content'><p>(写了日期，但没有写任何的东西)</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2019.3.2</p></div></div><div class='timeline-item-content'><p>黑夜从未远去</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2019.9.29</p></div></div><div class='timeline-item-content'><p>好累呀，就是累</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020.2.11</p></div></div><div class='timeline-item-content'><p>最近脖子有点不舒服。</p></div></div></div><p>有让我看了觉得很二很尬的不知所云的（但我现在还时不时发这种说说），这里都选我参加化学竞赛国初之前的”日记“：</p><div class="timeline  purple"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>地铁老人手机</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2018.8.9（国初24天）（高考301天）</p></div></div><div class='timeline-item-content'><p>赌局——雨水与电子设备的对弈</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2018.8.14（国初19天）（高考296天）</p></div></div><div class='timeline-item-content'><p>平静——风雨到来的开幕曲</p><p>永远都是一念之差，<del>成功</del>（雾）与失败。勾心斗角只为迎合出题者。这一切都是一场赌局，只是我们还未长大，就被拖去直面风雨。羡慕那些学起来轻松的人儿呵！</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2018.9.1（国初-1+2天）（高考278天）</p></div></div><div class='timeline-item-content'><p>出发——不得不面对的一劫</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2018.9.1（国初0天）（高考277天）</p></div></div><div class='timeline-item-content'><p>落定——弱肉强食之伤</p><p>鄂19 Acqua已退役</p></div></div></div><p>还有的，看得让我心碎。看着当时满怀希望的自己，我的心在滴血。就像是从上帝视角看去，明知道眼前的这个傻孩子要受伤，却没办法阻止。对不起那时的自己：</p><div class="timeline  red"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>知道的结局的我眼泪掉下来</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2018.8.31（国初0+2天）（高考279天）</p></div></div><div class='timeline-item-content'><p>从容——也无风雨也无晴</p><p>明天就要出发了，心情波动却毫无焦虑。褪去高二的稚气，我相信，我，我们大家，一定能秀出最真的自己</p><blockquote><p>结局如之前所见，我在国初就出局了（教练表示不能理解）。我只不过一直在假努力吧……不然我就完全说服不了自己了。最后喜提（一文不值的）省二</p></blockquote></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2019.6.3（高考4天）</p></div></div><div class='timeline-item-content'><p>也不过就这样嘛，一千天也就这样过去了</p><p>人生强大，舍我其谁。</p><blockquote><p>PS：语文老师临考前几天，送给同学们她订制的书签。我的书签上写的是”人生强大，舍我其谁“。</p><p>至于结局……我成了一只WHUer，已经低于我的心理预期很多了，我真的到现在都不能接受，奇迹只发生在我旁边的人身上，我只不过一直在假努力吧。</p></blockquote></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2019.6.9</p></div></div><div class='timeline-item-content'><p>一切的一切都从今天开始。</p><p>▓▓▓▓▓，开始，▓▓，你好啊</p><blockquote><p>PS：不想涉及到他，他其实也没做错任何事，只是我完全不能接受这种结果。</p></blockquote></div></div></div><p>高考之前的路是很漫长很痛苦的，我一直都在挣扎。我并不是有天赋的人，竞赛输了以后，上清北的想法就非常非常愚蠢了，追赶文化课的时间真的不多，我每天都在思考我各个学科的问题到底出在哪里……</p><p>总之心路历程很长很单调，就不放出来了。</p><p>有些还比较正经，或者有那么一瞬间让我有了时空错位的感觉：</p><div class="timeline  green"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>自我感觉良好</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2018.8.25（国初6+2天）（高考285天）</p></div></div><div class='timeline-item-content'><p>如果不能一鸣惊人，那也应该清清嗓子，一展歌喉对吧！</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2019.1.2（高考155天）</p></div></div><div class='timeline-item-content'><p>卖弱文化，不知道是什么时候兴起。别人很强，我比不上他们，怎么办？禁不住别人的奚落？好，索性我先人一步坦言自己不行、水平差，先把自尊的外壳脱下去，任人进攻，恬不知耻，让对方哑口无言。更有甚者反呛一口，让人不知所措。</p><p>或许对方只是一种提醒，另一方就开启程序性保护，正常的交流（交流）瞬间固化。硬化自己却也失去了交往的温柔。</p><p>与卖弱相应的，还有”膜人“。本来应该是对有本事的人的称赞，然而，如今”膜“早已经失了本味。”膜人“比”卖弱“更毒，”卖弱“只是自我沉沦，”膜人“则是踹人下水的捧杀。</p><p>本该是赞赏之情，言语之中却饱含蔑视，好似他才是该受赞赏的人。最可怕莫过于这种恶心人的心态是会传染的，顺着原本意义上的鄙视链逆火而上，或者叫”反鄙视链“</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2019.4.19（高考49天）</p></div></div><div class='timeline-item-content'><p>是世界运转得太快，还是我走得太慢了？</p><p>再把日记往前翻。49天，就像从天上看着无知的过去的怀着愚蠢希望的我。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2019.5.10（高考28天）（冬奥会1000天）</p></div></div><div class='timeline-item-content'><p>挂了……</p><blockquote><p>说真的，当我翻日记时发现我还记了冬奥会倒时计的时候，那种恍惚感，真的奇妙</p></blockquote></div></div></div><p>日记里还有一些关于我与我的oc们一起对话的内容，太过精分，我也不放出来了。不过今天这么一温习，我倒是想起来了oc们的一些设定信息。</p><p>比如丘卡是16年诞生的（具体日期确实不记得了），而且一口认定自己是男孩子，2019年10月28日才正式接受自己的小雌驹身份。索莫的cm只有在日食的情况下才能显现出来……总之脑补oc们之间的对话确实是oc设定的主要产出方式。</p><p>之前写的日记虽然是零零散散的，但是回顾起来还是很花时间的，我只能摘选其中的一点点，作为这次新开始之前的总结（<del>有些太羞耻了，实在不想放上来</del>）。其实这些在现在看起来，真的真的真的挺傻挺幼稚的，但是它却帮我挺过了那段最黑暗的时间，重新阅读它，就像找回了不小心弄丢的记忆，也让我能从过去那个屡战屡败屡败屡战的坚强的小家伙身上汲取毅力与勇气。</p><h3 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h3><h4 id="3月6日"><a href="#3月6日" class="headerlink" title="3月6日"></a>3月6日</h4><p>写这次日记的时候已经是凌晨0：34了，配置cordova卡了一晚上，挺让人心累的，本来打算今天（3.6之前）把空间信息移动编程的作业搞定的，结果又得拖到明天（3.6）了，明天还得把数字摄影测量的论文写一写，不然到时候编程作业更没时间了。今天难得抽了点时间，写一点感受，以后再搞这个Blog就不知道是什么时候了，希望有空能继续把<a href="/posts/79ac647.html" title="移动编程记录">移动编程记录</a>补上。</p><p>很累很累，为了这门课已经花了我接近两天的时间……说实话我其实有点后悔当初没有把这门课给撤掉了，希望最后的结果能够好一点。</p><h4 id="3月8日"><a href="#3月8日" class="headerlink" title="3月8日"></a>3月8日</h4><p>希望这周末能有时间静下来好好写一篇长点的日记。</p><p>现在有些课程的进度已经快过半了，作业难度确实大，赶作业挺累的。卫星摄影测量的编程虽然是小组任务，但是太硬核，我现在碰都不想碰。数字摄影测量的小论文着实恶心到我了，一想到后面还有书面作业，我就头大。而且数字摄影测量马上也要布置编程任务了。近景摄影测量作业阳间，但最近也有一个课间实习需要编程。空间信息移动编程一周一次作业很折磨。地理建模方法和地理监测与应用的大论文还没定，应该也不远了（砸桌）……（果然还是多媒体技术这种外院课最好啊……）</p><p>之后有空把自己写的矩阵类还有 Manim 代码给搬过来，还有以前写的<a href="/posts/8baa3f41.html" title="坦克大战记录">坦克大战记录</a>代码啥的，也分享出来。</p><h4 id="3月11日"><a href="#3月11日" class="headerlink" title="3月11日"></a>3月11日</h4><p>我真的是无语了，这老师布置作业怎么还带把 DDL 提前的，真当我们只上他一门课啊？看来这周末要狂赶论文了……</p><h4 id="3月20日"><a href="#3月20日" class="headerlink" title="3月20日"></a>3月20日</h4><p>像这样天天宅在寝室里要么是摸鱼要么是写代码，我都不知道有什么好写的东西了。难道说我已经失去了对美好事物的嗅觉了吗，还是说天天沉浸在这么个紧张节奏中对其他事情都提不起兴趣了？</p><p>生活中琐碎的事太多了，好事往往都马上忘掉了，难过的事却能一直留到晚上……躺在床上睡不着的时候，常常想起的，也都是一些悲伤的事情。明明有那么多开心的事啊，我的脑子却总喜欢放一些难过的“电影”。有的时候半夜醒来的时候，眼角都还是润润的。也许这是我在寻求我自己的怜悯吧。</p><h3 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h3><h4 id="4月8日"><a href="#4月8日" class="headerlink" title="4月8日"></a>4月8日</h4><p>每次小组作业我都能感觉到我的编程水平有多么低，同样是大学三年，为什么我就没什么长进呢？别人也是该玩就玩，为什么他们效率就这么高呢？看到别人有那么多事情要做还能安排得井井有条，我真的是佩服他们。难道我就只是那种要靠大把时间顶着低效率干活的人吗？</p><h4 id="4月22日"><a href="#4月22日" class="headerlink" title="4月22日"></a>4月22日</h4><p>核酸卡片真不错！</p><div class="fj-gallery"><p><img src="/images/blogs/日常记录/1.jpg" alt=""></p><p><img src="/images/blogs/日常记录/2.jpg" alt=""></p><p><img src="/images/blogs/日常记录/3.jpg" alt=""></p><p><img src="/images/blogs/日常记录/4.jpg" alt=""></p>          </div>]]></content>
    
    
    <summary type="html">每天的一些碎碎念。</summary>
    
    
    
    <category term="日记" scheme="http://zerolacqua.top/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="日常" scheme="http://zerolacqua.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
    <category term="吐槽" scheme="http://zerolacqua.top/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>《相遇的开始》与《变奏曲》</title>
    <link href="http://zerolacqua.top/posts/36600b09.html"/>
    <id>http://zerolacqua.top/posts/36600b09.html</id>
    <published>2021-08-31T04:15:37.000Z</published>
    <updated>2022-04-11T10:49:04.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相遇的开始"><a href="#相遇的开始" class="headerlink" title="相遇的开始"></a>相遇的开始</h2><p><em>“宝□儿，□点□来啊！”</em></p><p><em>“知道啦！”</em></p><p><em>……</em></p><p><em>“请签□您的□字，丘□小姐。”</em></p><p><em>“照顾好我的家人，好吗。”</em></p><p><em>……</em></p><p><em>“□划□□中□了。”</em></p><p><em>“■■□■办？！”</em></p><p><em>……</em></p><p><em>“或■□里□她□□■安全”</em></p><p><em>……</em></p><p><em>……</em></p><p><em>■□■□■□■□■□■□■□■□■□■▆▄▃▂▁▁▁<strong><strong>_</strong></strong> _ _  _  _   _</em> </p><p>* <em> </em> <em> </em></p><p>液体压迫着她的耳膜，但嗡嗡的水声并没有打扰到她的睡眠。她头上的装置守护着她甜美的梦境，装置的指示灯如眼睛一般不时地眨着，监视着可能的冒犯者。独角兽角上晕着的微弱品红色光芒，正服从指示灯的指挥摇曳着。她胸前的橙色护身符却一直散发着虚弱的磷光，叛逆地强调着自己的存在。除了有时突然工作的水泵和循环机，一切似乎都那么的平静正常……</p><p>* <em> </em> <em> </em></p><p>“警告！警告！核心电力供应异常！自检中……修复失败……应急供电设备启动。净水区将按特殊规程，中断主供电……”</p><p>我仿佛触电一般从沉睡中惊醒，肺部的异物感让我剧烈地咳嗽起来。搞什么嘛，我这是……诶，我怎么泡在水里？！我赶忙点亮独角，想要变出一个呼吸泡泡。但随之而来的疲劳和晕眩感，差点让我失去意识。魔法怎么用不了了？不会游泳的我慌了神，四个蹄子开始在水中拼命地扑腾，试图让头伸出水面，童年的阴影开始占据脑——</p><p>“砰！”我的脸好像撞到了什么东西，沉闷的撞击打断了我不好的回忆，也让我冷静了些。我发现，我似乎被困在了像“鱼缸”一样的东西里，周围都是玻璃。而且这么折腾了一会后，虽然肺里很不舒服，但是我好像并没有缺氧的感觉。我低头看了看胸前的护身符，才发现它正发出强烈的磷光。这是母亲给我的护身符，能帮我抵御精神魔法。但这是怎么回事，我已经中招了吗？这莫名其妙的诡异情景，说是精神魔法产生的幻觉也不为过。奇怪了，我明明是今天上午出门去找朋友玩的，怎么会在这种鬼地方醒过来。这种幻觉要也是她的恶作剧的话，那可就太过火了，我一定饶不了她！</p><p>“嘀——”泡在水中思考的我，突然听见了先前没有注意到的声音，它好像是从我头上传来的。我往上一瞥，发现我的角居然正不停地闪烁着，而且这个“嘀”声似乎正控制着我的角。我十分诧异，用蹄子挠了挠头。结果本该是鬃毛的地方，竟然有奇怪的金属质感。这好像是个“头盔”？我赶紧把“头盔”取了下来。刹那间，护身符和独角的光芒一同熄灭，奇怪的“滴”声也随之停止，一切又陷入了死一般的黑暗中。我点亮独角，品红色的光芒终于如我所愿地划破了黑暗。至少现在，我的独角能乖乖听我的话了……</p><p>突然，我的眼前冒起金星，眼睛再也无力聚焦，思绪也开始变得迟滞。我下意识地看向自己的护身符，这一次，它只是静静地在我胸前漂浮。沉重的眼皮再也支持不住了，魔法光也已经褪去。即将消散殆尽的意识却捕捉到了来自外面的一丝光亮。</p><p>“终于……来……了吗？”</p><p>* <em> </em> <em> </em></p><p><em>“宝贝儿，早点回来啊！”</em></p><p><em>……</em></p><p><em>时候不早了，我是不是该回家了？</em></p><p><em>可回家的路呢？</em></p><p><em>熟悉的一切面目全非，大地燃烧，火舌烧穿天空。天堂在哭泣，泪水却无法平息怒火。毒气弥漫，辐射所至生命凋灵……</em></p><p><em>……</em></p><p><em>我回不去了，仇恨的烈火横亘在我与家之间。</em></p><p><em>……</em></p><p><em>这就是炼狱吗？</em></p><p><em>……</em></p><p><em>世界一片片地剥离崩塌，时间开始扭曲断裂……</em></p><p>* <em> </em> <em> </em></p><p>“你醒了？”</p><p>什么？一只雄驹的声音？我心头一惊，竖起耳朵，努力挣开双眼，想要搞清楚情况。自己昏迷的时候身边有只雄驹，想想都可怕，天知道他对我做了什么？我点亮独角以示警戒……又一阵晕眩感立马袭来。</p><p>“好好休息。两百多年来一直被强制释放魔法，你已经魔法枯竭了。不过我刚刚给你喝了瓶魔法药剂，再过会儿你应该就脱离枯竭状态了。另外，呃……除了把昏迷的你拖出那个罐子的时候……我可与你没有任何的肢体接触。如果我对你有恶意，你压根就没有醒的机会。所以，别摆着一幅恶狠狠的架势了，与其浪费体力，不如赶快休息好。”</p><p>他说的很有道理。我如果不能用魔法防身，大概只能任他宰割。短暂休息之后，我的眼睛终于适应了环境，雄驹的形体逐渐明晰。他的个头比我高出不少，似乎是一只陆马，不过他那黑白相间的鬃毛，总是让我觉得他是只斑马。要不是他身体是全白的，我真就把他当斑马了。</p><p>不过，我连现在的情况都没搞清楚，突然又来了这么多难以理解的信息。我感觉我本来就昏昏沉沉的脑袋马上就要宕机了。他说的“两百多年来”是什么意思？难道说……</p><p>他似乎看出了我的困惑：“你叫零醇丘卡，对吧。”</p><p>“叫我丘卡就好了。”我点了点头，心里却十分纳闷：他怎么知道我的名字？</p><p>“看来你确实是资料里那只擅长操控水分子的雌驹了。可能是因为你参加的秘密科研计划，你在两百年前的战争中幸存，并休眠到现在……”</p><p>我沉默了。我在脑海中一遍遍地回想之前发生的事情，却只记得自己才和母亲告别没多久。这不可能。这怎么可能？！他是在开玩笑吧，我才刚出家门！</p><p>“你参加了一个科研项目，然后被清除了项目相关的所有记忆。所以，你可能记不起来了。”</p><p>“你骗我，我不信！”我终于开口反驳道。</p><p>“那看看这份文档吧。”他点了点蹄子上的装置，屏幕上弹出一串文字。</p><p>“那是你编的！”我连看都没看一眼，就脱口而出，只是不愿让自己接受这可怕的事实。</p><p>“你就算争赢了又有什么用？接受现实好吗！两百年！只剩下你自己了，你的家人和朋友就算没被炸死毒死，也早就归西了！”</p><p>他还是说出了我最害怕，最不愿意接受的事情。我瘫软在地，泪水终于夺眶而出。</p><p>“明明上一秒我还在去朋友家的路上，为什么这一秒大家就离我而去了？？”</p><p>“我妈还在等我回……回家……”</p><p>“十九岁……生日还……大……大家就……”</p><p>“一切都都……为……什么一起走……不叫我……好好的……本来……”</p><p>我的头一片混乱，美好的回忆在脑海中闪回，然后又湮灭在黑雾之中。他们都活在了昨天，只丢下我活在今天。一股绝望的无助感紧紧地缠绕着我，伴随着我的每一次啜泣越绞越紧。</p><p>“我还……没准备好！！你们……怎么……能抛下我……你们好自私……”</p><p>雄驹尴尬地站在一旁，为自己说话不留分寸而懊恼不已，似乎他并不擅长处理这种情况。他刚想上前一步说些什么，就被我的哭声给压了下去。</p><p>“……为什么还要……叫醒我？”我朝着雄驹哭喊，把一切的怒火都撒在了他的身上，但内心又把全部的希望寄托在他身上，要求他、恳求他回答我的问题。但是他只是低头沉默地站在那里，没有任何的回应。</p><p>终于，无助与绝望冲垮了我的精神防线。</p><p>“既然……这样……去陪他们……还不如我……”我用蹄子拿起旁边“鱼缸”的碎片，试图扎向自己的脖子，却被雄驹上前一把夺下。</p><p>“你冷静点丘卡！”他放下了抓住我的蹄子，又退了回去。</p><p>“为什么……不让我……回去？为什么……非要是我？”泪水已经哭干，我渴望他的回答。</p><p>“对不起，我和你一样，也刚失去身边的一切……”</p><p>我一下愣住了，一时间不知道怎么回应他这句话，只能继续以啜泣声相对。</p><p>“我不怎么会安慰别人，更别说安慰女孩子了。很抱歉让你一醒来就接受这么残酷的现实。但是我希望你能活下来，这也是为什么我非要把你从装置中救出来。如果丢下你你肯定会死，我不敢想，我因为我接受不了！我已经失去太多了，我不会再让其他小马在我面前死去！”</p><p>“那……让我静静好吗……”</p><p>“好的，我会去房间另一头待着……”</p><p>我看到蹄边的碎片上，粘了不少血迹，可我身上并没有伤口。这家伙……</p><p>为什么非要救我……</p><p>他这是何苦呢？铁了心要救一个被时代抛弃的马？</p><p>伴随一生的愧疚。</p><p>无依无靠的孤独。</p><p>长路漫漫的迷茫。</p><p>失去挚爱的痛苦。</p><p>……</p><p>就为换一次“新生”？</p><p>幸存，到底是幸运还是不幸？</p><p>我不想思考了……</p><p>现实打败了我。</p><p>* <em> </em> <em> </em></p><p>“想通了吗？”</p><p>“我有罪……”</p><p>“我也有。”</p><p>“我本不该活下来……”</p><p>“我也是。”</p><p>眼前这个说话不中听的呆木头也打败了我。</p><p>“我老爸希望我活下来。你父母肯定也希望你能好好活着。”</p><p>“那我这么苟活又有什么意义呢？”我叹了一口气，试图调整自己的呼吸。</p><p>“我也想知道。”他看了看那个破了个大口的“鱼缸”，笑了笑。</p><p>“你怎么能不知道？”我显然不能接受这个答案，转身佯装要拿起玻璃碎片。</p><p>“那就陪我一起找寻意义吧，我会保护你的。”这次他没有上前阻止。显然他不吃我这套。</p><p>“听起来，怎么感觉陪着你我还死得更快呢？”他那坚定的语气，终于把我给逗笑了。我抹了抹眼角的泪水，站起来说：“反正我也没有什么挂念的了，打个赌吧，我倒要看看我能不能过上两百岁之后的第一个生日。”</p><p>“我会监督你的，你不许作弊。”</p><p>* <em> </em> <em> </em></p><p>“对了，丘卡。我在这个地方，找到了一个哔哔小马，似乎是专门为你准备的。”雄驹递给我一个奇怪的装置，又补充道，“其实这整个净水区似乎都是为你准备的。”</p><p>我用魔法接过哔哔小马，歪头看着他：“这个要怎么用啊？” </p><p>他抬起了前蹄，我才注意到他有一个一模一样的哔哔小马。</p><p>“这样啊，好。”我把哔哔小马戴在前蹄上，然后随便地按了按。哔哔小马的屏幕就亮了起来，片刻后屏幕显示身份检验通过。</p><p>“学得真快啊。”雄驹表扬道。</p><p>“你刚刚说要给我看的文档，我还没看。”我低下头小声地说道。</p><p>“我知道，我已经传到你的哔哔小马里了。晚点你按一下这个键就能查看了。”雄驹顿了顿，“丘卡，你要看看怎么用枪吗？独角兽用起来会舒服很多。”</p><p>“枪？我好像有点印——”我话还没说完，雄驹就熟练地用嘴扣动了扳机，打中了房间另一头的水瓶。水瓶迸裂，液体洒了一地。刚才那枪声可把我吓了一大跳。</p><p>“呀！！呃……那还是算了，我接受不了。”我摇了摇头。</p><p>“那我们走吧……晚点教你用哔哔小马吧，你这个哔哔小马似乎特殊一点，能给你的魔法充能。”</p><p>“对了，你叫什么名字啊？”我一边整理着雄驹给我的鞍包一边问道。 </p><p>雄驹挠了挠头：“啊，之前忘记自我介绍了，我叫闪影。”</p><p>“唔，那个……闪影……”</p><p>“嗯？”</p><p>“你说，我到底忘记了些什么？” </p><p>“我不知道，但我会和你一起去找的。”</p><p>“谢谢你，闪影。”</p><hr><h2 id="变奏曲"><a href="#变奏曲" class="headerlink" title="变奏曲"></a>变奏曲</h2><p>闪影把找到的木柴慢慢累成一个圆锥，架好行军锅，点燃篝火。</p><p>零醇丘卡乖乖地坐在一旁，看着闪影从鞍包里掏出一个又一个稀奇古怪的食材和调味料。</p><p>“这是什么？”</p><p>“从天空马车里翻出来的盐。”</p><p>“那这个呢？”</p><p>“我在路上顺到的野菜，辐射量勉强能吃。”</p><p>“锅你是哪来的？</p><p>“抢的奴隶贩子的。”</p><p>丘卡嘟着嘴，似乎对闪影呆板的回答略有不满。</p><p>“不是我说，你怎么比我这个在休眠仓里冻了两百年的马还要无聊？”</p><p>“我看起来很无聊？”</p><p>“你难道一点自觉都没有吗？”</p><p>“没有。”</p><p>似乎是被雌驹打破砂锅问到底的精神所折服，</p><p>闪影转过头去操心锅里的食材；</p><p>似乎是对自己的厨艺略有自信，</p><p>丘卡的脸色已经能看得见有点不满。</p><p>但是她目前拿这匹雄驹没有办法，自己还很虚弱，用不了什么有实际作用的魔法，更不用说跟一匹雄性陆马比力气。</p><p>她看看雄驹强壮、带有疤痕的前蹄，一度怀疑他一只蹄子就可以把她提起来。</p><p><em>太可怕了！</em></p><p>丘卡没好气地转过身，躺下，任闪影在锅前忙碌。</p><p><img src="/images/blogs/《相遇的开始》与《变奏曲》/丘卡&amp;闪影1.png" alt="丘卡和闪影"></p><p>似乎是该忙都已经忙完了，闪影找了块木头，掏出小刀，在上面刻刻画画。</p><p>废土并不怎么温暖的中午，篝火补足了温度，雌驹听见刀削声，抬起头看。</p><p>然后她就看见了一把匕首，在距离她不到三十公分的地方晃悠。</p><p>“啊！你干什么？！”</p><p>“冷静，我只是在打发时间，菜还没熟。”</p><p>雌驹定睛一看，原来是蹄工。</p><p>“你还会做这个吗？”</p><p>“我以前在避难厩的时候就会这个，不算太难。”</p><p>“你也是避难厩居民？”</p><p>“是的。”</p><p>“那……”</p><p>“……”</p><p>显然雄驹并不愿意分享他在避难厩里的日子.</p><p>“菜熟了，你找找我鞍包里应该有碗什么的。”</p><p>“噢。”</p><p>雌驹拉开他鼓鼓囊囊的鞍包，被惊到：</p><p>弹夹弹鼓塞满了边袋.</p><p>破片雷满计挂了十二个.</p><p>榴弹整整齐齐塞在弹带上.</p><p>大包里塞了一把截短的单筒榴弹发射器和一把紧凑型军用弹鼓式霰弹枪。</p><p>甚至还有几个c4塑型炸弹。</p><p>她不由自主地看了看雄驹身上从没脱下来过的战斗鞍，上面的三管转管机枪和大口径狙击枪再一次冲击着她的认知。</p><p>这家伙……移动军火库吗？</p><p>“你这里面只有子弹啊？”</p><p>“侧袋。”</p><p>丘卡费了老大劲才从一堆弹夹和破片雷里掏出锅碗瓢盆，递给闪影。</p><p>闪影抬起头看了一眼她，盯得丘卡直发毛，脸也慢慢地红起来。</p><p><em>这个傻子为什么一直盯着我看啊？</em></p><p>就在气氛一度尴尬到了极致时，闪影提醒道：</p><p>“你踩到我尾巴了，松蹄。”</p><p>丘卡像触电一样赶忙从闪影身边跳开，甩开了脑子里一些在她看来不合时宜、十分不成熟的想法。</p><p><em>你在想什么啊丘卡？这个木头有什么好的?</em></p><p>“你发烧了？脸这么红？”</p><p>闪影把脸凑近，蹄子扶上了丘卡的额头。</p><p><em>啊啊啊啊啊啊啊，他在干什么啊？!</em></p><p>丘卡的脸再次升温，头顶甚至一度有水汽冒出。</p><p>“我我我我……没事……你你你不用操心。”</p><p>丘卡赶忙把蹄子拨开。</p><p>“一些辐射病的初期状况就是发烧和咳嗽，让我看看。”</p><p>陆马强有力地拉开丘卡护在脸前的蹄子，仔细观察丘卡略有一丝慌乱的眼瞳。</p><p>心跳加速，咚咚地跳，这一刻的时间仿佛被无限拉长，慢得出奇。</p><p>“嗯，没事。奇了怪了，你为什么体温这么高？”</p><p>丘卡实在忍不住把雄驹推开，夺过闪影蹄里的碗，埋头苦干，装作看不见闪影奇怪的眼神。</p><p>闪影也一脸莫名其妙，但是看丘卡生龙活虎的样子，也就没说什么，又从锅里捞了一碗吃了起来。</p><p>一中午无话，还含着某匹雌驹满满的怨气。</p><p>“休息得差不多了，该出发了，接下来你有什么打算？”</p><p>被叫醒的丘卡睡眼朦胧，摇摇晃晃地看着闪影，突然精神。</p><p><em>自己是什么时候睡着的？他该不会……</em></p><p>“你的被害妄想症该改改了，吃完就睡也不知道是什么毛病。”</p><p>丘卡气得鼓起脸，说不出话。</p><p>“回到最初的问题，接下来你什么打算？”</p><p>闪影一边检查武器一边问。</p><p>“当然是……暂时跟着你咯。”</p><p>丘卡满不在意。</p><p>闪影先是一愣，沉思了许久，抬起头，语言斩钉截铁：“不行，跟着我不行。”</p><p>“为什么？”</p><p>“跟着我……会死。”</p><p>闪影的脸色变得铁青，看向丘卡。</p><p>她被吓了一跳，那样的眼神，丘卡从来没有见到过，那是浓缩到极致的……悔恨，几乎凝成了实质。</p><p>丘卡盯着他的眼睛，也愣住了。</p><p><em>不能就这么撇下他不管。</em></p><p>“我不管，我就跟你了。”</p><p>闪影长叹一口气，从鞍包里叼出一把蹄枪和几个扩容弹夹扔给丘卡。</p><p>“哔哔小马应该会给你使用方法和辅助瞄准……别死那么早。”</p><p>丘卡有点不情愿地捡起蹄枪，却感觉自己好像在哪里用过，熟练地拉开套筒检查枪膛，连自己都开始疑惑。</p><p>闪影瞥了她一眼，说：“你并没有我想象的那么不堪嘛。”</p><p>丘卡没好气地瞪了他一眼，把弹夹塞进闪影给她准备的快速反应背心。</p><p>还挺合身。</p><p>“该走了。”闪影看向前方不远处的工厂。</p><p>丘卡看看闪影，看看自己的快速反应背心。</p><p>“行吧，那接下来的日子里请多指教。”</p><p>虽然她并不指望这截榆木脑袋能明白些什么。</p><p>“请多指教。”</p><p>两匹马，踏上了相互拯救的道路……</p>]]></content>
    
    
    <summary type="html">是21年丘卡和闪影互写的纪念日贺文！由于我俩平时不能联系，双方对整体故事的考量也就不太相同了。欢迎欣赏大型OOC现场！</summary>
    
    
    
    <category term="丘卡和大家的故事" scheme="http://zerolacqua.top/categories/%E4%B8%98%E5%8D%A1%E5%92%8C%E5%A4%A7%E5%AE%B6%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    
    
    <category term="小马" scheme="http://zerolacqua.top/tags/%E5%B0%8F%E9%A9%AC/"/>
    
    <category term="小说" scheme="http://zerolacqua.top/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
</feed>
